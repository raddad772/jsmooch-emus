#include <cassert>
#include "helpers/int.h"
#include "m6502_opcodes.h"
#include "m6502.h"
namespace M6502 {
// This file auto-generated by m6502_core_generator.js in JSMooCh

static void ins_NONE(regs &regs, pins &pins)
{
    assert(1==0);
}
static void ins_00_BRK(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.P.B = 1;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            regs.TR = regs.PC;
            pins.D = (regs.TR >> 8) & 0xFF;
            pins.RW = 1;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.TR & 0xFF;
            break; }
        case 4: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte();
            break; }
        case 5: {
            regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs.P.I = 1;
            pins.RW = 0;
            pins.Addr = (0xFFFE);
            break; }
        case 6: {
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_01_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_02_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_03_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_04_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_05_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_06_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_07_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_08_PHP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte() | 0x30;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_09_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_0A_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = (regs.A & 0x80) >> 7;
            regs.A = (regs.A << 1) & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_0B_ANC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.C = regs.P.N;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_0C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_0D_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_0E_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_0F_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_10_BPL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.N == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_11_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_12_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_13_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_14_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_15_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_16_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_17_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A |= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_18_CLC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_19_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_1A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_1B_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A |= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_1C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_1D_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_1E_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_1F_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A |= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_20_JSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            regs.TA = pins.D;
            regs.TR = regs.PC;
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 3: { //stack write PCH
            pins.RW = 1;
            pins.D = (regs.PC & 0xFF00) >> 8;
            break; }
        case 4: { //stack write PCL
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.PC & 0xFF;
            break; }
        case 5: {
            pins.Addr = regs.TR;
            pins.RW = 0;
            break; }
        case 6: { //cleanup_custom
            regs.PC = regs.TA | (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_21_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_22_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_23_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_24_BIT(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.P.Z = +((regs.A & pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.P.V = (pins.D & 0x40) >> 6;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_25_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_26_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_27_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_28_PLP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S + 1) & 0xFF;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //cleanup_custom
            regs.P.setbyte(pins.D);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_29_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_2A_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            u32 c = regs.P.C;
            regs.P.C = (regs.A & 0x80) >> 7;
            regs.A = ((regs.A << 1) | c) & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_2B_ANC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.C = regs.P.N;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_2C_BIT(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.P.Z = +((regs.A & pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.P.V = (pins.D & 0x40) >> 6;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_2D_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_2E_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_2F_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_30_BMI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.N == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_31_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_32_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_33_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_34_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_35_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_36_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_37_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A &= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_38_SEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_39_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_3A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_3B_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A &= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_3C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_3D_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_3E_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_3F_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A &= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_40_RTI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //spurious read
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            break; }
        case 3: { //Read P
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //Read PCL
            regs.P.setbyte(pins.D);
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 5: { //read PCH
            regs.PC = pins.D;
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 6: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_41_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_42_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_43_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_44_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_45_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_46_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_47_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_48_PHA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_49_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_4A_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = regs.A & 1;
            regs.A >>= 1;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_4B_ALR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.C = regs.A & 1;
            regs.A >>= 1;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_4C_JMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //cleanup_custom
            regs.PC = regs.TA | (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_4D_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_4E_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_4F_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_50_BVC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.V == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_51_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_52_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_53_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_54_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_55_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_56_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_57_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            regs.A ^= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_58_CLI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: { //cleanup_custom
            regs.P.I = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_59_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_5A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_5B_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            regs.A ^= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_5C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_5D_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_5E_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_5F_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            regs.A ^= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_60_RTS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //spurious read
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            break; }
        case 3: { //read PCL
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //read PCH
            regs.PC = pins.D;
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 5: { //spurious read
            regs.PC |= (pins.D << 8);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_61_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_62_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_63_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_64_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_65_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_66_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_67_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_68_PLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //spurious read
            pins.Addr = regs.PC;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            break; }
        case 3: { //good stack read
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_69_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_6A_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            u32 c = regs.P.C;
            regs.P.C = regs.A & 1;
            regs.A = (c << 7) | (regs.A >> 1);
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_6B_ARR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            if (regs.P.D) {
                regs.A &= pins.D;
                u8 unshifted_A = regs.A;
                regs.A = (regs.P.C << 7) | (regs.A >> 1) & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = ((regs.A) & 0x80) >> 7;
                regs.P.V = (regs.A >> 6) ^ (regs.A >> 5) & 1;
                if ((unshifted_A & 15) + (unshifted_A&1) > 5) regs.A = ((regs.A + 6) & 15) | (regs.A & 0xF0) & 0xFF;
                regs.P.C = ((unshifted_A & 0xF0) + (unshifted_A & 0x10) > 0x50) ? 1 : 0;
                if (regs.P.C) regs.A = (regs.A + 0x60) & 0xFF;
            }
            else {
                regs.A &= pins.D;
                regs.A = (regs.A >> 1) | (regs.P.C << 7);
                regs.P.Z = regs.A == 0;
                regs.P.N = ((regs.A) & 0x80) >> 7;
                regs.P.C = (regs.A >> 6) & 1;
                regs.P.V = (regs.A >> 6) ^ (regs.A >> 5) & 1;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_6C_JMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //read ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //read ABSH
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TA = pins.D;
            break; }
        case 3: { //read PCL
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //read PCH
            regs.PC = pins.D;
            pins.Addr = (pins.Addr & 0xFF00) | ((pins.Addr + 1) & 0xFF);
            break; }
        case 5: { //cleanup_custom
            regs.PC |= pins.D << 8;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_6D_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_6E_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_6F_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_70_BVS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.V == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_71_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_72_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_73_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_74_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_75_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_76_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_77_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_78_SEI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: { //cleanup_custom
            regs.P.I = 1;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_NMI_only(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_79_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_7A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_7B_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_7C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_7D_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_7E_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_7F_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR;
            if (regs.P.D) {
                regs.P.Z = ((regs.A + i + regs.P.C) & 0xFF) == 0;
                o = (regs.A & 0x0F) + (i & 0x0F) + (regs.P.C);
                if (o > 0x09) o += 0x06;
                regs.P.C = +(o > 0x0F);
                o = (regs.A & 0xF0) + (i & 0xF0) + (regs.P.C << 4) + (o & 0x0F);
                regs.P.N = (o >> 7) & 1;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                if (o > 0x9F) o += 0x60;
                regs.A = o & 0xFF;
                regs.P.C = o > 0xFF;
            } else {
                o = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
                regs.P.C = o > 0xFF;
                regs.A = o & 0xFF;
                regs.P.Z = regs.A == 0;
                regs.P.N = (regs.A & 0x80) >> 7;
            }
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_80_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_81_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Write result to addr
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_82_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_83_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Write result to addr
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = (regs.A & regs.X);
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_84_STY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = regs.Y;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_85_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_86_STX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = regs.X;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_87_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = (regs.A & regs.X);
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_88_DEY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.Y = (regs.Y - 1) & 0xFF;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_89_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_8A_TXA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.A = regs.X;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_8B_XAA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A = (regs.A | 0xEE) & regs.X & pins.D;
            pins.D = regs.A;
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_8C_STY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.Y;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_8D_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_8E_STX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.X;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_8F_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = (regs.A & regs.X);
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_90_BCC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.C == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_91_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TA = pins.D + regs.Y;
            regs.TR = (pins.D + regs.Y) & 0xFF;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //always idle
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            pins.Addr = (pins.D << 8) | regs.TR;
            regs.TR = regs.TA == pins.Addr;
            break; }
        case 5: { //write data
            pins.Addr = regs.TA;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_92_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_93_SHA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TA = pins.D + regs.Y;
            regs.TR = (pins.D + regs.Y) & 0xFF;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //always idle
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            pins.Addr = (pins.D << 8) | regs.TR;
            regs.TR = regs.TA == pins.Addr;
            break; }
        case 5: { //write data
            pins.Addr = regs.TA;
            pins.RW = 1;
            //SHA!
            if (!regs.TR) {
                pins.D = regs.A & regs.X & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            }
            else {
                pins.D = regs.A & regs.X & (((pins.Addr >> 8) + 1) & 0xFF);
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_94_STY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.X) & 0xFF;
            pins.RW = 1;
            pins.D = regs.Y;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_95_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.X) & 0xFF;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_96_STX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.Y) & 0xFF;
            pins.RW = 1;
            pins.D = regs.X;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_97_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.Y) & 0xFF;
            pins.RW = 1;
            pins.D = (regs.A & regs.X);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_98_TYA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.A = regs.Y;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_99_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_9A_TXS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.S = regs.X;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_9B_SHS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            regs.S = regs.A & regs.X;
            if (!regs.TR) {
                pins.D = regs.S & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            } else {
                pins.D = regs.S & (((pins.Addr >> 8) + 1) & 0xFF);
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_9C_SHY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            if (!regs.TR) {
                pins.D = regs.Y & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            } else {
                pins.D = (regs.Y & ((pins.Addr >> 8) + 1)) & 0xFF;
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_9D_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: {
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_9E_SHX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            if (!regs.TR) {
                pins.D = regs.X & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            } else {
                pins.D = (regs.X & ((pins.Addr >> 8) + 1)) & 0xFF;
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_9F_SHA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            //SHA!
            if (!regs.TR) {
                pins.D = regs.A & regs.X & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            }
            else {
                pins.D = regs.A & regs.X & (((pins.Addr >> 8) + 1) & 0xFF);
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A0_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A1_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A2_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A3_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A4_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A5_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A6_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A7_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A8_TAY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.Y = regs.A;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_A9_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_AA_TAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = regs.A;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_AB_LXA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A = regs.X = (regs.A | 0xEE) & pins.D;
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_AC_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_AD_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_AE_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_AF_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B0_BCS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.C == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B1_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B2_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B3_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B4_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B5_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B6_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.Y) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B7_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.Y) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B8_CLV(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.V = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_B9_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_BA_TSX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = regs.S;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_BB_LAS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D & regs.S;
            regs.X = regs.S = regs.A;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_BC_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_BD_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_BE_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_BF_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C0_CPY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs.Y - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C1_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C2_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C3_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C4_CPY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs.Y - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C5_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C6_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C7_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C8_INY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.Y = (regs.Y + 1) & 0xFF;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_C9_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_CA_DEX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = (regs.X - 1) & 0xFF;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_CB_SBX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.X &= regs.A;
            u16 d = regs.X - pins.D;
            regs.X = d & 0xFF;
            regs.P.N = ((d) & 0x80) >> 7;
            regs.P.Z = +((d) == 0);
            regs.P.C = ((d >> 8) ^ 1) & 1;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_CC_CPY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.Y - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_CD_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_CE_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_CF_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D0_BNE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.Z == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D1_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D2_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D3_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D4_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D5_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D6_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D7_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o = regs.A - regs.TR;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D8_CLD(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.D = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_D9_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_DA_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_DB_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o = regs.A - regs.TR;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_DC_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_DD_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_DE_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_DF_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o = regs.A - regs.TR;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E0_CPX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs.X - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E1_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E2_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E3_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E4_CPX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs.X - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E5_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E6_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E7_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E8_INX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = (regs.X + 1) & 0xFF;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_E9_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_EA_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_EB_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_EC_CPX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.X - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_ED_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_EE_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_EF_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F0_BEQ(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.Z == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F1_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F2_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F3_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F4_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F5_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F6_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F7_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            u32 r;
            u32 i = regs.TR ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F8_SED(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.D = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_F9_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_FA_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_FB_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            u32 r;
            u32 i = regs.TR ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_FC_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_FD_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            u32 r;
            u32 i = pins.D ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_FE_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_FF_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            u32 r;
            u32 i = regs.TR ^ 0xFF;
            if (regs.P.D) {
                r = regs.A + i + regs.P.C;
                regs.P.Z = (r & 0xFF) == 0;
                regs.P.C = r > 0xFF;
                regs.P.N = (r >> 7) & 1;
                regs.P.V = ((r ^ regs.A) & (r ^ i) & 0x80) >> 7;
                if (!((regs.A ^ r ^ i) & 0x10)) r = (r & 0xF0) | ((r + 0xFA) & 0xF);
                r &= 0xFF;
                if (!regs.P.C) r += 0xA0;
                regs.A = r & 0xFF;
            } else {
                r = i + regs.A + regs.P.C;
                regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ r) & 0x80) >> 7;
                regs.P.C = r > 0xFF;
                regs.A = r & 0xFF;
                regs.P.Z = +((regs.A) == 0);
                regs.P.N = ((regs.A) & 0x80) >> 7;
            }
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_100_S_RESET(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //3
            pins.RW = 0;
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 2: { //4
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 3: { //5
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 4: { //6
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 5: { //7
            pins.Addr = (0xFFFC);
            break; }
        case 6: { //8
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_101_S_NMI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.P.B = 0;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            regs.TR = (regs.PC - 2) & 0xFFFF;
            pins.D = (regs.TR >> 8) & 0xFF;
            pins.RW = 1;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.TR & 0xFF;
            break; }
        case 4: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte();
            break; }
        case 5: {
            regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs.P.I = 1;
            pins.RW = 0;
            pins.Addr = (0xFFFA);
            break; }
        case 6: {
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void ins_102_S_IRQ(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.P.B = 0;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            regs.TR = (regs.PC - 2) & 0xFFFF;
            pins.D = (regs.TR >> 8) & 0xFF;
            pins.RW = 1;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.TR & 0xFF;
            break; }
        case 4: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte();
            break; }
        case 5: {
            regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs.P.I = 1;
            pins.RW = 0;
            pins.Addr = (0xFFFE);
            break; }
        case 6: {
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}


ins_func decoded_opcodes[0x103] = {
        &ins_00_BRK,  &ins_01_ORA,  &ins_02_STP,  &ins_03_SLO,  &ins_04_NOP24,  &ins_05_ORA,  &ins_06_ASL,  &ins_07_SLO,
      &ins_08_PHP,  &ins_09_ORA,  &ins_0A_ASL,  &ins_0B_ANC,  &ins_0C_NOP24,  &ins_0D_ORA,  &ins_0E_ASL,  &ins_0F_SLO,
      &ins_10_BPL,  &ins_11_ORA,  &ins_12_STP,  &ins_13_SLO,  &ins_14_NOP24,  &ins_15_ORA,  &ins_16_ASL,  &ins_17_SLO,
      &ins_18_CLC,  &ins_19_ORA,  &ins_1A_NOP,  &ins_1B_SLO,  &ins_1C_NOP24,  &ins_1D_ORA,  &ins_1E_ASL,  &ins_1F_SLO,
      &ins_20_JSR,  &ins_21_AND,  &ins_22_STP,  &ins_23_RLA,  &ins_24_BIT,  &ins_25_AND,  &ins_26_ROL,  &ins_27_RLA,
      &ins_28_PLP,  &ins_29_AND,  &ins_2A_ROL,  &ins_2B_ANC,  &ins_2C_BIT,  &ins_2D_AND,  &ins_2E_ROL,  &ins_2F_RLA,
      &ins_30_BMI,  &ins_31_AND,  &ins_32_STP,  &ins_33_RLA,  &ins_34_NOP24,  &ins_35_AND,  &ins_36_ROL,  &ins_37_RLA,
      &ins_38_SEC,  &ins_39_AND,  &ins_3A_NOP,  &ins_3B_RLA,  &ins_3C_NOP24,  &ins_3D_AND,  &ins_3E_ROL,  &ins_3F_RLA,
      &ins_40_RTI,  &ins_41_EOR,  &ins_42_STP,  &ins_43_SRE,  &ins_44_NOP24,  &ins_45_EOR,  &ins_46_LSR,  &ins_47_SRE,
      &ins_48_PHA,  &ins_49_EOR,  &ins_4A_LSR,  &ins_4B_ALR,  &ins_4C_JMP,  &ins_4D_EOR,  &ins_4E_LSR,  &ins_4F_SRE,
      &ins_50_BVC,  &ins_51_EOR,  &ins_52_STP,  &ins_53_SRE,  &ins_54_NOP24,  &ins_55_EOR,  &ins_56_LSR,  &ins_57_SRE,
      &ins_58_CLI,  &ins_59_EOR,  &ins_5A_NOP,  &ins_5B_SRE,  &ins_5C_NOP24,  &ins_5D_EOR,  &ins_5E_LSR,  &ins_5F_SRE,
      &ins_60_RTS,  &ins_61_ADC,  &ins_62_STP,  &ins_63_RRA,  &ins_64_NOP24,  &ins_65_ADC,  &ins_66_ROR,  &ins_67_RRA,
      &ins_68_PLA,  &ins_69_ADC,  &ins_6A_ROR,  &ins_6B_ARR,  &ins_6C_JMP,  &ins_6D_ADC,  &ins_6E_ROR,  &ins_6F_RRA,
      &ins_70_BVS,  &ins_71_ADC,  &ins_72_STP,  &ins_73_RRA,  &ins_74_NOP24,  &ins_75_ADC,  &ins_76_ROR,  &ins_77_RRA,
      &ins_78_SEI,  &ins_79_ADC,  &ins_7A_NOP,  &ins_7B_RRA,  &ins_7C_NOP24,  &ins_7D_ADC,  &ins_7E_ROR,  &ins_7F_RRA,
      &ins_80_NOP22,  &ins_81_STA,  &ins_82_NOP22,  &ins_83_SAX,  &ins_84_STY,  &ins_85_STA,  &ins_86_STX,  &ins_87_SAX,
      &ins_88_DEY,  &ins_89_NOP22,  &ins_8A_TXA,  &ins_8B_XAA,  &ins_8C_STY,  &ins_8D_STA,  &ins_8E_STX,  &ins_8F_SAX,
      &ins_90_BCC,  &ins_91_STA,  &ins_92_STP,  &ins_93_SHA,  &ins_94_STY,  &ins_95_STA,  &ins_96_STX,  &ins_97_SAX,
      &ins_98_TYA,  &ins_99_STA,  &ins_9A_TXS,  &ins_9B_SHS,  &ins_9C_SHY,  &ins_9D_STA,  &ins_9E_SHX,  &ins_9F_SHA,
      &ins_A0_LDY,  &ins_A1_LDA,  &ins_A2_LDX,  &ins_A3_LAX,  &ins_A4_LDY,  &ins_A5_LDA,  &ins_A6_LDX,  &ins_A7_LAX,
      &ins_A8_TAY,  &ins_A9_LDA,  &ins_AA_TAX,  &ins_AB_LXA,  &ins_AC_LDY,  &ins_AD_LDA,  &ins_AE_LDX,  &ins_AF_LAX,
      &ins_B0_BCS,  &ins_B1_LDA,  &ins_B2_STP,  &ins_B3_LAX,  &ins_B4_LDY,  &ins_B5_LDA,  &ins_B6_LDX,  &ins_B7_LAX,
      &ins_B8_CLV,  &ins_B9_LDA,  &ins_BA_TSX,  &ins_BB_LAS,  &ins_BC_LDY,  &ins_BD_LDA,  &ins_BE_LDX,  &ins_BF_LAX,
      &ins_C0_CPY,  &ins_C1_CMP,  &ins_C2_NOP22,  &ins_C3_DCP,  &ins_C4_CPY,  &ins_C5_CMP,  &ins_C6_DEC,  &ins_C7_DCP,
      &ins_C8_INY,  &ins_C9_CMP,  &ins_CA_DEX,  &ins_CB_SBX,  &ins_CC_CPY,  &ins_CD_CMP,  &ins_CE_DEC,  &ins_CF_DCP,
      &ins_D0_BNE,  &ins_D1_CMP,  &ins_D2_STP,  &ins_D3_DCP,  &ins_D4_NOP24,  &ins_D5_CMP,  &ins_D6_DEC,  &ins_D7_DCP,
      &ins_D8_CLD,  &ins_D9_CMP,  &ins_DA_NOP,  &ins_DB_DCP,  &ins_DC_NOP24,  &ins_DD_CMP,  &ins_DE_DEC,  &ins_DF_DCP,
      &ins_E0_CPX,  &ins_E1_SBC,  &ins_E2_NOP22,  &ins_E3_ISC,  &ins_E4_CPX,  &ins_E5_SBC,  &ins_E6_INC,  &ins_E7_ISC,
      &ins_E8_INX,  &ins_E9_SBC,  &ins_EA_NOP,  &ins_EB_SBC,  &ins_EC_CPX,  &ins_ED_SBC,  &ins_EE_INC,  &ins_EF_ISC,
      &ins_F0_BEQ,  &ins_F1_SBC,  &ins_F2_STP,  &ins_F3_ISC,  &ins_F4_NOP24,  &ins_F5_SBC,  &ins_F6_INC,  &ins_F7_ISC,
      &ins_F8_SED,  &ins_F9_SBC,  &ins_FA_NOP,  &ins_FB_ISC,  &ins_FC_NOP24,  &ins_FD_SBC,  &ins_FE_INC,  &ins_FF_ISC,
      &ins_100_S_RESET,  &ins_101_S_NMI,  &ins_102_S_IRQ
};

}
