#include <assert.h>
#include "helpers/int.h"
#include "nesm6502_opcodes.h"
#include "m6502.h"

// This file auto-generated by m6502_core_generator.js in JSMooCh

static void nesM6502_ins_NONE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    assert(1==0);
}
static void nesM6502_ins_00_BRK(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->P.B = 1;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            regs->TR = regs->PC;
            pins->D = (regs->TR >> 8) & 0xFF;
            pins->RW = 1;
            break; }
        case 3: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = regs->TR & 0xFF;
            break; }
        case 4: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = M6502_regs_P_getbyte(&regs->P);
            break; }
        case 5: {
            regs->P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs->P.I = 1;
            pins->RW = 0;
            pins->Addr = (0xFFFE);
            break; }
        case 6: {
            regs->PC = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs->PC |= (pins->D << 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_01_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_02_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_03_SLO(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //spurious
            pins->RW = 1;
            break; }
        case 7: { //write result
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = (pins->D << 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_04_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_05_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_06_ASL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = (pins->D << 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_07_SLO(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = (pins->D << 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_08_PHP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = M6502_regs_P_getbyte(&regs->P) | 0x30;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_09_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_0A_ASL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->P.C = (regs->A & 0x80) >> 7;
            regs->A = (regs->A << 1) & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_0B_ANC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->P.C = regs->P.N;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_0C_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_0D_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_0E_ASL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = (pins->D << 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_0F_SLO(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = (pins->D << 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_10_BPL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.N == 0);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_11_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_12_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_13_SLO(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: { //idle
            pins->Addr = regs->TA;
            break; }
        case 6: { //spurious write
            pins->RW = 1;
            break; }
        case 7: { //duplicate write cycle
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = (pins->D << 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_14_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_15_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_16_ASL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->TR << 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_17_SLO(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->TR << 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            regs->A |= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_18_CLC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->P.C = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_19_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_1A_NOP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_1B_SLO(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->TR << 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            regs->A |= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_1C_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_1D_ORA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A |= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_1E_ASL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->TR << 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_1F_SLO(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->TR << 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            regs->A |= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_20_JSR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            regs->TA = pins->D;
            regs->TR = regs->PC;
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 3: { //stack write PCH
            pins->RW = 1;
            pins->D = (regs->PC & 0xFF00) >> 8;
            break; }
        case 4: { //stack write PCL
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = regs->PC & 0xFF;
            break; }
        case 5: {
            pins->Addr = regs->TR;
            pins->RW = 0;
            break; }
        case 6: { //cleanup_custom
            regs->PC = regs->TA | (pins->D << 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_21_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_22_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_23_RLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //spurious
            pins->RW = 1;
            break; }
        case 7: { //write result
            u32 c = regs->P.C;
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = ((pins->D << 1) | c) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_24_BIT(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->P.Z = +((regs->A & pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->P.V = (pins->D & 0x40) >> 6;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_25_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_26_ROL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs->P.C;
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = ((pins->D << 1) | c) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_27_RLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs->P.C;
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = ((pins->D << 1) | c) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_28_PLP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: { //spurious stack read
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S + 1) & 0xFF;
            break; }
        case 3: {
            pins->Addr = regs->S | 0x100;
            break; }
        case 4: { //cleanup_custom
            M6502_regs_P_setbyte(&regs->P, pins->D);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_29_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_2A_ROL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            u32 c = regs->P.C;
            regs->P.C = (regs->A & 0x80) >> 7;
            regs->A = ((regs->A << 1) | c) & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_2B_ANC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->P.C = regs->P.N;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_2C_BIT(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->P.Z = +((regs->A & pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->P.V = (pins->D & 0x40) >> 6;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_2D_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_2E_ROL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            u32 c = regs->P.C;
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = ((pins->D << 1) | c) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_2F_RLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            u32 c = regs->P.C;
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = ((pins->D << 1) | c) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_30_BMI(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.N == 1);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_31_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_32_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_33_RLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: { //idle
            pins->Addr = regs->TA;
            break; }
        case 6: { //spurious write
            pins->RW = 1;
            break; }
        case 7: { //duplicate write cycle
            u32 c = regs->P.C;
            regs->P.C = (pins->D & 0x80) >> 7;
            pins->D = ((pins->D << 1) | c) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_34_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_35_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_36_ROL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            u32 c = regs->P.C;
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = ((regs->TR << 1) | c) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_37_RLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            u32 c = regs->P.C;
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = ((regs->TR << 1) | c) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            regs->A &= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_38_SEC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->P.C = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_39_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_3A_NOP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_3B_RLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            u32 c = regs->P.C;
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = ((regs->TR << 1) | c) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            regs->A &= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_3C_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_3D_AND(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_3E_ROL(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            u32 c = regs->P.C;
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = ((regs->TR << 1) | c) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_3F_RLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            u32 c = regs->P.C;
            regs->P.C = (regs->TR & 0x80) >> 7;
            regs->TR = ((regs->TR << 1) | c) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            regs->A &= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_40_RTI(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //spurious read
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            pins->Addr = regs->S | 0x100;
            break; }
        case 3: { //Read P
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->S | 0x100;
            break; }
        case 4: { //Read PCL
            M6502_regs_P_setbyte(&regs->P, pins->D);
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->S | 0x100;
            break; }
        case 5: { //read PCH
            regs->PC = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->S | 0x100;
            break; }
        case 6: { //cleanup_custom
            regs->PC |= (pins->D << 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_41_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_42_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_43_SRE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //spurious
            pins->RW = 1;
            break; }
        case 7: { //write result
            regs->P.C = pins->D & 1;
            pins->D >>= 1;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = 0;
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_44_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_45_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_46_LSR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            regs->P.C = pins->D & 1;
            pins->D >>= 1;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_47_SRE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            regs->P.C = pins->D & 1;
            pins->D >>= 1;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = 0;
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_48_PHA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = regs->A;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_49_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_4A_LSR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->P.C = regs->A & 1;
            regs->A >>= 1;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_4B_ALR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->P.C = regs->A & 1;
            regs->A >>= 1;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_4C_JMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //cleanup_custom
            regs->PC = regs->TA | (pins->D << 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_4D_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_4E_LSR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            regs->P.C = pins->D & 1;
            pins->D >>= 1;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_4F_SRE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            regs->P.C = pins->D & 1;
            pins->D >>= 1;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = 0;
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_50_BVC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.V == 0);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_51_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_52_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_53_SRE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: { //idle
            pins->Addr = regs->TA;
            break; }
        case 6: { //spurious write
            pins->RW = 1;
            break; }
        case 7: { //duplicate write cycle
            regs->P.C = pins->D & 1;
            pins->D >>= 1;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = 0;
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_54_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_55_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_56_LSR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->P.C = regs->TR & 1;
            regs->TR >>= 1;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = 0;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_57_SRE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->P.C = regs->TR & 1;
            regs->TR >>= 1;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = 0;
            regs->A ^= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_58_CLI(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: { //cleanup_custom
            regs->P.I = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_59_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_5A_NOP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_5B_SRE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->P.C = regs->TR & 1;
            regs->TR >>= 1;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = 0;
            regs->A ^= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_5C_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_5D_EOR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A ^= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_5E_LSR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->P.C = regs->TR & 1;
            regs->TR >>= 1;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = 0;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_5F_SRE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->P.C = regs->TR & 1;
            regs->TR >>= 1;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = 0;
            regs->A ^= regs->TR;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_60_RTS(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //spurious read
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            pins->Addr = regs->S | 0x100;
            break; }
        case 3: { //read PCL
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->S | 0x100;
            break; }
        case 4: { //read PCH
            regs->PC = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->S | 0x100;
            break; }
        case 5: { //spurious read
            regs->PC |= (pins->D << 8);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_61_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_62_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_63_RRA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //spurious
            pins->RW = 1;
            break; }
        case 7: { //write result
            u32 c = regs->P.C;
            regs->P.C = pins->D & 1;
            pins->D = (c << 7) | (pins->D >> 1);
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_64_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_65_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_66_ROR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs->P.C;
            regs->P.C = pins->D & 1;
            pins->D = (c << 7) | (pins->D >> 1);
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_67_RRA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs->P.C;
            regs->P.C = pins->D & 1;
            pins->D = (c << 7) | (pins->D >> 1);
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_68_PLA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //spurious read
            pins->Addr = regs->PC;
            break; }
        case 2: { //spurious stack read
            pins->Addr = regs->S | 0x100;
            break; }
        case 3: { //good stack read
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->S | 0x100;
            break; }
        case 4: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_69_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_6A_ROR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            u32 c = regs->P.C;
            regs->P.C = regs->A & 1;
            regs->A = (c << 7) | (regs->A >> 1);
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_6B_ARR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A &= pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            u32 c = regs->P.C;
            regs->P.C = regs->A & 1;
            regs->A = (c << 7) | (regs->A >> 1);
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->P.C = (regs->A >> 6) & 1;
            regs->P.V = ((regs->A >> 6) ^ (regs->A >> 5) & 1);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_6C_JMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //read ABSL
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //read ABSH
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = pins->D;
            break; }
        case 3: { //read PCL
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //read PCH
            regs->PC = pins->D;
            pins->Addr = (pins->Addr & 0xFF00) | ((pins->Addr + 1) & 0xFF);
            break; }
        case 5: { //cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_6D_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_6E_ROR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            u32 c = regs->P.C;
            regs->P.C = pins->D & 1;
            pins->D = (c << 7) | (pins->D >> 1);
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_6F_RRA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            u32 c = regs->P.C;
            regs->P.C = pins->D & 1;
            pins->D = (c << 7) | (pins->D >> 1);
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_70_BVS(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.V == 1);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_71_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_72_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_73_RRA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: { //idle
            pins->Addr = regs->TA;
            break; }
        case 6: { //spurious write
            pins->RW = 1;
            break; }
        case 7: { //duplicate write cycle
            u32 c = regs->P.C;
            regs->P.C = pins->D & 1;
            pins->D = (c << 7) | (pins->D >> 1);
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_74_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_75_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_76_ROR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            u32 c = regs->P.C;
            regs->P.C = regs->TR & 1;
            regs->TR = (c << 7) | (regs->TR >> 1);
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_77_RRA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            u32 c = regs->P.C;
            regs->P.C = regs->TR & 1;
            regs->TR = (c << 7) | (regs->TR >> 1);
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs->TR;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_78_SEI(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: { //cleanup_custom
            regs->P.I = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_79_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_7A_NOP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_7B_RRA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            u32 c = regs->P.C;
            regs->P.C = regs->TR & 1;
            regs->TR = (c << 7) | (regs->TR >> 1);
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs->TR;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_7C_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_7D_ADC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins->D;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_7E_ROR(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            u32 c = regs->P.C;
            regs->P.C = regs->TR & 1;
            regs->TR = (c << 7) | (regs->TR >> 1);
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_7F_RRA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            u32 c = regs->P.C;
            regs->P.C = regs->TR & 1;
            regs->TR = (c << 7) | (regs->TR >> 1);
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs->TR;
            o = i + regs->A + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_80_NOP22(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_81_STA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Write result to addr
            pins->Addr = regs->TA | (pins->D << 8);
            pins->D = regs->A;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_82_NOP22(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_83_SAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Write result to addr
            pins->Addr = regs->TA | (pins->D << 8);
            pins->D = (regs->A & regs->X);
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_84_STY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            pins->D = regs->Y;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_85_STA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            pins->D = regs->A;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_86_STX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            pins->D = regs->X;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_87_SAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            pins->D = (regs->A & regs->X);
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_88_DEY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->Y = (regs->Y - 1) & 0xFF;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_89_NOP22(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_8A_TXA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->A = regs->X;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_8B_XAA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A = (regs->A | 0xEE) & regs->X & pins->D;
            pins->D = regs->A;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->P.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_8C_STY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            pins->D = regs->Y;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_8D_STA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            pins->D = regs->A;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_8E_STX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            pins->D = regs->X;
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_8F_SAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            pins->D = (regs->A & regs->X);
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_90_BCC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.C == 0);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_91_STA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TA = pins->D + regs->Y;
            regs->TR = (pins->D + regs->Y) & 0xFF;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //always idle
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            pins->Addr = (pins->D << 8) | regs->TR;
            regs->TR = regs->TA == pins->Addr;
            break; }
        case 5: { //write data
            pins->Addr = regs->TA;
            pins->RW = 1;
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_92_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_93_SHA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TA = pins->D + regs->Y;
            regs->TR = (pins->D + regs->Y) & 0xFF;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //always idle
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            pins->Addr = (pins->D << 8) | regs->TR;
            regs->TR = regs->TA == pins->Addr;
            break; }
        case 5: { //write data
            pins->Addr = regs->TA;
            pins->RW = 1;
            //SHA!
            if (!regs->TR) {
                pins->D = regs->A & regs->X & (pins->Addr >> 8);
                pins->Addr = (pins->Addr & 0xFF) | (pins->D << 8);
            }
            else {
                pins->D = regs->A & regs->X & (((pins->Addr >> 8) + 1) & 0xFF);
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_94_STY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            break; }
        case 3: { //write data
            pins->Addr = (pins->Addr + regs->X) & 0xFF;
            pins->RW = 1;
            pins->D = regs->Y;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_95_STA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            break; }
        case 3: { //write data
            pins->Addr = (pins->Addr + regs->X) & 0xFF;
            pins->RW = 1;
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_96_STX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            break; }
        case 3: { //write data
            pins->Addr = (pins->Addr + regs->Y) & 0xFF;
            pins->RW = 1;
            pins->D = regs->X;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_97_SAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            break; }
        case 3: { //write data
            pins->Addr = (pins->Addr + regs->Y) & 0xFF;
            pins->RW = 1;
            pins->D = (regs->A & regs->X);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_98_TYA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->A = regs->Y;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_99_STA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ABSL
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: {
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            pins->RW = 1;
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_9A_TXS(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->S = regs->X;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_9B_SHS(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ABSL
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: {
            regs->TR = pins->Addr;
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            regs->TR = regs->TR == pins->Addr;
            regs->S = regs->A & regs->X;
            if (!regs->TR) {
                pins->D = regs->S & (pins->Addr >> 8);
                pins->Addr = (pins->Addr & 0xFF) | (pins->D << 8);
            } else {
                pins->D = regs->S & (((pins->Addr >> 8) + 1) & 0xFF);
            }
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_9C_SHY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ABSL
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: {
            regs->TR = pins->Addr;
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            regs->TR = regs->TR == pins->Addr;
            if (!regs->TR) {
                pins->D = regs->Y & (pins->Addr >> 8);
                pins->Addr = (pins->Addr & 0xFF) | (pins->D << 8);
            } else {
                pins->D = (regs->Y & ((pins->Addr >> 8) + 1)) & 0xFF;
            }
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_9D_STA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ABSL
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: {
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            pins->RW = 1;
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_9E_SHX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ABSL
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: {
            regs->TR = pins->Addr;
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            regs->TR = regs->TR == pins->Addr;
            if (!regs->TR) {
                pins->D = regs->X & (pins->Addr >> 8);
                pins->Addr = (pins->Addr & 0xFF) | (pins->D << 8);
            } else {
                pins->D = (regs->X & ((pins->Addr >> 8) + 1)) & 0xFF;
            }
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_9F_SHA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //get ABSL
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: {
            regs->TR = pins->Addr;
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            regs->TR = regs->TR == pins->Addr;
            //SHA!
            if (!regs->TR) {
                pins->D = regs->A & regs->X & (pins->Addr >> 8);
                pins->Addr = (pins->Addr & 0xFF) | (pins->D << 8);
            }
            else {
                pins->D = regs->A & regs->X & (((pins->Addr >> 8) + 1) & 0xFF);
            }
            pins->RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A0_LDY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->Y = pins->D;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A1_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A2_LDX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A3_LAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A4_LDY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->Y = pins->D;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A5_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A6_LDX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A7_LAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A8_TAY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->Y = regs->A;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_A9_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_AA_TAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->X = regs->A;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_AB_LXA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->A = regs->X = (regs->A | 0xEE) & pins->D;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->P.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_AC_LDY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->Y = pins->D;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_AD_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_AE_LDX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_AF_LAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B0_BCS(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.C == 1);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B1_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B2_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B3_LAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B4_LDY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            regs->Y = pins->D;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B5_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B6_LDX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->Y) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B7_LAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->Y) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B8_CLV(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->P.V = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_B9_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_BA_TSX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->X = regs->S;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_BB_LAS(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A = pins->D & regs->S;
            regs->X = regs->S = regs->A;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_BC_LDY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->Y = pins->D;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_BD_LDA(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_BE_LDX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_BF_LAX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            regs->A = pins->D;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->X = pins->D;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C0_CPY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs->Y - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C1_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C2_NOP22(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C3_DCP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //spurious
            pins->RW = 1;
            break; }
        case 7: { //write result
            pins->D = (pins->D - 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C4_CPY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs->Y - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C5_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C6_DEC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            pins->D = (pins->D - 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C7_DCP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            pins->D = (pins->D - 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C8_INY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->Y = (regs->Y + 1) & 0xFF;
            regs->P.Z = +((regs->Y) == 0);
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_C9_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_CA_DEX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->X = (regs->X - 1) & 0xFF;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_CB_SBX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs->X &= regs->A;
            u16 d = regs->X - pins->D;
            regs->X = d & 0xFF;
            regs->P.N = ((d) & 0x80) >> 7;
            regs->P.Z = +((d) == 0);
            regs->P.C = ((d >> 8) ^ 1) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_CC_CPY(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs->Y - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_CD_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_CE_DEC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            pins->D = (pins->D - 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_CF_DCP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            pins->D = (pins->D - 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D0_BNE(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.Z == 0);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D1_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D2_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D3_DCP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: { //idle
            pins->Addr = regs->TA;
            break; }
        case 6: { //spurious write
            pins->RW = 1;
            break; }
        case 7: { //duplicate write cycle
            pins->D = (pins->D - 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D4_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D5_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D6_DEC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->TR = (regs->TR - 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D7_DCP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->TR = (regs->TR - 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o = regs->A - regs->TR;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D8_CLD(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->P.D = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_D9_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_DA_NOP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_DB_DCP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->TR = (regs->TR - 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o = regs->A - regs->TR;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_DC_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_DD_CMP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            i32 o = regs->A - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_DE_DEC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->TR = (regs->TR - 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_DF_DCP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->TR = (regs->TR - 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o = regs->A - regs->TR;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E0_CPX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs->X - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E1_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E2_NOP22(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E3_ISC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins->Addr = pins->D;
            regs->TA = (pins->D + regs->X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins->Addr = regs->TA;
            break; }
        case 4: { //read ABS H
            regs->TA = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 6: { //spurious
            pins->RW = 1;
            break; }
        case 7: { //write result
            pins->D = (pins->D + 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E4_CPX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs->X - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E5_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = pins->D;
            break; }
        case 3: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E6_INC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            pins->D = (pins->D + 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E7_ISC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //fetch ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins->Addr = pins->D;
            break; }
        case 3: { //spurious read/write
            pins->RW = 1;
            break; }
        case 4: { //real write
            pins->D = (pins->D + 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E8_INX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->X = (regs->X + 1) & 0xFF;
            regs->P.Z = +((regs->X) == 0);
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_E9_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_EA_NOP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_EB_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_EC_CPX(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs->X - pins->D;
            regs->P.C = +(!((o & 0x100) >> 8));
            regs->P.Z = +((o & 0xFF) == 0);
            regs->P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_ED_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_EE_INC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            pins->D = (pins->D + 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_EF_ISC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            break; }
        case 4: {
            pins->RW = 1;
            break; }
        case 5: {
            pins->D = (pins->D + 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F0_BEQ(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->TR = +(regs->P.Z == 1);
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU += 2; break; }
            break; }
        case 2: {
            regs->TA = (((i32)regs->PC) + ((i32)(i8)pins->D)) & 0xFFFF;
            pins->Addr = regs->PC;
            if ((regs->TA & 0xFF00) == (regs->PC & 0xFF00)) { regs->TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins->Addr = (regs->PC & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F1_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: {
            pins->Addr = regs->TA;
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F2_STP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs->STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F3_ISC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //Get ZP
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins->Addr = pins->D;
            break; }
        case 3: { //get ABS H
            regs->TR = pins->D;
            regs->TA = pins->D + regs->Y;
            pins->Addr = (pins->Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs->TR = (regs->TR + (pins->D << 8)) & 0xFFFF;
            regs->TA = (regs->TA + (pins->D << 8)) & 0xFFFF;
            if ((regs->TR & 0xFF00) == (regs->TA & 0xFF00)) { pins->Addr = regs->TA; break; }
            pins->Addr = (regs->TR & 0xFF00) | (regs->TA & 0xFF);
            break; }
        case 5: { //idle
            pins->Addr = regs->TA;
            break; }
        case 6: { //spurious write
            pins->RW = 1;
            break; }
        case 7: { //duplicate write cycle
            pins->D = (pins->D + 1) & 0xFF;
            regs->P.Z = +((pins->D) == 0);
            regs->P.N = ((pins->D) & 0x80) >> 7;
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F4_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F5_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F6_INC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->TR = (regs->TR + 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F7_ISC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs->TA = (pins->D + regs->X) & 0xFF;
            pins->Addr = pins->D;
            break; }
        case 3: {
            pins->Addr = regs->TA;
            break; }
        case 4: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            regs->TR = (regs->TR + 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs->TR ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            break; }
        case 5: {
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F8_SED(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->P.D = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_F9_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->Y) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_FA_NOP(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_FB_ISC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->Y) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->TR = (regs->TR + 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs->TR ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_FC_NOP24(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_FD_SBC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins->Addr = regs->TA | (pins->D << 8);
            regs->TA = (pins->Addr + regs->X) & 0xFFFF;
            if ((regs->TA & 0xFF00) == (pins->Addr & 0xFF00)) { regs->TCU++; pins->Addr = regs->TA; break; }
            pins->Addr = (pins->D << 8) | (regs->TA & 0xFF);
            break; }
        case 4: { //optional
            pins->Addr = regs->TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins->D ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_FE_INC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->TR = (regs->TR + 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_FF_ISC(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TA = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs->TA |= pins->D << 8;
            pins->Addr = (regs->TA & 0xFF00) | ((regs->TA + regs->X) & 0xFF);
            break; }
        case 4: { //real read
            pins->Addr = (regs->TA + regs->X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs->TR = pins->D;
            pins->RW = 1;
            break; }
        case 6: {
            regs->TR = (regs->TR + 1) & 0xFF;
            regs->P.Z = +((regs->TR) == 0);
            regs->P.N = ((regs->TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs->TR ^ 0xFF;
            o = regs->A + i + regs->P.C;
            regs->P.V = ((~(regs->A ^ i)) & (regs->A ^ o) & 0x80) >> 7;
            regs->P.C = +(o > 0xFF);
            regs->A = o & 0xFF;
            regs->P.Z = +((regs->A) == 0);
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RW = 0;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_100_S_RESET(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: { //3
            pins->RW = 0;
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 2: { //4
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 3: { //5
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 4: { //6
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            break; }
        case 5: { //7
            pins->Addr = (0xFFFC);
            break; }
        case 6: { //8
            regs->PC = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs->PC |= (pins->D << 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_101_S_NMI(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->P.B = 0;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            regs->TR = (regs->PC - 2) & 0xFFFF;
            pins->D = (regs->TR >> 8) & 0xFF;
            pins->RW = 1;
            break; }
        case 3: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = regs->TR & 0xFF;
            break; }
        case 4: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = M6502_regs_P_getbyte(&regs->P);
            break; }
        case 5: {
            regs->P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs->P.I = 1;
            pins->RW = 0;
            pins->Addr = (0xFFFA);
            break; }
        case 6: {
            regs->PC = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs->PC |= (pins->D << 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}

static void nesM6502_ins_102_S_IRQ(struct M6502_regs *regs, struct M6502_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->P.B = 0;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            regs->TR = (regs->PC - 2) & 0xFFFF;
            pins->D = (regs->TR >> 8) & 0xFF;
            pins->RW = 1;
            break; }
        case 3: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = regs->TR & 0xFF;
            break; }
        case 4: {
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            pins->D = M6502_regs_P_getbyte(&regs->P);
            break; }
        case 5: {
            regs->P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs->P.I = 1;
            pins->RW = 0;
            pins->Addr = (0xFFFE);
            break; }
        case 6: {
            regs->PC = pins->D;
            pins->Addr = (pins->Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs->PC |= (pins->D << 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            M6502_poll_IRQs(regs, pins);
            regs->TCU = 0;
            break;
    }}
}


M6502_ins_func nesM6502_decoded_opcodes[0x103] = {
        &nesM6502_ins_00_BRK,  &nesM6502_ins_01_ORA,  &nesM6502_ins_02_STP,  &nesM6502_ins_03_SLO,  &nesM6502_ins_04_NOP24,  &nesM6502_ins_05_ORA,  &nesM6502_ins_06_ASL,  &nesM6502_ins_07_SLO,
      &nesM6502_ins_08_PHP,  &nesM6502_ins_09_ORA,  &nesM6502_ins_0A_ASL,  &nesM6502_ins_0B_ANC,  &nesM6502_ins_0C_NOP24,  &nesM6502_ins_0D_ORA,  &nesM6502_ins_0E_ASL,  &nesM6502_ins_0F_SLO,
      &nesM6502_ins_10_BPL,  &nesM6502_ins_11_ORA,  &nesM6502_ins_12_STP,  &nesM6502_ins_13_SLO,  &nesM6502_ins_14_NOP24,  &nesM6502_ins_15_ORA,  &nesM6502_ins_16_ASL,  &nesM6502_ins_17_SLO,
      &nesM6502_ins_18_CLC,  &nesM6502_ins_19_ORA,  &nesM6502_ins_1A_NOP,  &nesM6502_ins_1B_SLO,  &nesM6502_ins_1C_NOP24,  &nesM6502_ins_1D_ORA,  &nesM6502_ins_1E_ASL,  &nesM6502_ins_1F_SLO,
      &nesM6502_ins_20_JSR,  &nesM6502_ins_21_AND,  &nesM6502_ins_22_STP,  &nesM6502_ins_23_RLA,  &nesM6502_ins_24_BIT,  &nesM6502_ins_25_AND,  &nesM6502_ins_26_ROL,  &nesM6502_ins_27_RLA,
      &nesM6502_ins_28_PLP,  &nesM6502_ins_29_AND,  &nesM6502_ins_2A_ROL,  &nesM6502_ins_2B_ANC,  &nesM6502_ins_2C_BIT,  &nesM6502_ins_2D_AND,  &nesM6502_ins_2E_ROL,  &nesM6502_ins_2F_RLA,
      &nesM6502_ins_30_BMI,  &nesM6502_ins_31_AND,  &nesM6502_ins_32_STP,  &nesM6502_ins_33_RLA,  &nesM6502_ins_34_NOP24,  &nesM6502_ins_35_AND,  &nesM6502_ins_36_ROL,  &nesM6502_ins_37_RLA,
      &nesM6502_ins_38_SEC,  &nesM6502_ins_39_AND,  &nesM6502_ins_3A_NOP,  &nesM6502_ins_3B_RLA,  &nesM6502_ins_3C_NOP24,  &nesM6502_ins_3D_AND,  &nesM6502_ins_3E_ROL,  &nesM6502_ins_3F_RLA,
      &nesM6502_ins_40_RTI,  &nesM6502_ins_41_EOR,  &nesM6502_ins_42_STP,  &nesM6502_ins_43_SRE,  &nesM6502_ins_44_NOP24,  &nesM6502_ins_45_EOR,  &nesM6502_ins_46_LSR,  &nesM6502_ins_47_SRE,
      &nesM6502_ins_48_PHA,  &nesM6502_ins_49_EOR,  &nesM6502_ins_4A_LSR,  &nesM6502_ins_4B_ALR,  &nesM6502_ins_4C_JMP,  &nesM6502_ins_4D_EOR,  &nesM6502_ins_4E_LSR,  &nesM6502_ins_4F_SRE,
      &nesM6502_ins_50_BVC,  &nesM6502_ins_51_EOR,  &nesM6502_ins_52_STP,  &nesM6502_ins_53_SRE,  &nesM6502_ins_54_NOP24,  &nesM6502_ins_55_EOR,  &nesM6502_ins_56_LSR,  &nesM6502_ins_57_SRE,
      &nesM6502_ins_58_CLI,  &nesM6502_ins_59_EOR,  &nesM6502_ins_5A_NOP,  &nesM6502_ins_5B_SRE,  &nesM6502_ins_5C_NOP24,  &nesM6502_ins_5D_EOR,  &nesM6502_ins_5E_LSR,  &nesM6502_ins_5F_SRE,
      &nesM6502_ins_60_RTS,  &nesM6502_ins_61_ADC,  &nesM6502_ins_62_STP,  &nesM6502_ins_63_RRA,  &nesM6502_ins_64_NOP24,  &nesM6502_ins_65_ADC,  &nesM6502_ins_66_ROR,  &nesM6502_ins_67_RRA,
      &nesM6502_ins_68_PLA,  &nesM6502_ins_69_ADC,  &nesM6502_ins_6A_ROR,  &nesM6502_ins_6B_ARR,  &nesM6502_ins_6C_JMP,  &nesM6502_ins_6D_ADC,  &nesM6502_ins_6E_ROR,  &nesM6502_ins_6F_RRA,
      &nesM6502_ins_70_BVS,  &nesM6502_ins_71_ADC,  &nesM6502_ins_72_STP,  &nesM6502_ins_73_RRA,  &nesM6502_ins_74_NOP24,  &nesM6502_ins_75_ADC,  &nesM6502_ins_76_ROR,  &nesM6502_ins_77_RRA,
      &nesM6502_ins_78_SEI,  &nesM6502_ins_79_ADC,  &nesM6502_ins_7A_NOP,  &nesM6502_ins_7B_RRA,  &nesM6502_ins_7C_NOP24,  &nesM6502_ins_7D_ADC,  &nesM6502_ins_7E_ROR,  &nesM6502_ins_7F_RRA,
      &nesM6502_ins_80_NOP22,  &nesM6502_ins_81_STA,  &nesM6502_ins_82_NOP22,  &nesM6502_ins_83_SAX,  &nesM6502_ins_84_STY,  &nesM6502_ins_85_STA,  &nesM6502_ins_86_STX,  &nesM6502_ins_87_SAX,
      &nesM6502_ins_88_DEY,  &nesM6502_ins_89_NOP22,  &nesM6502_ins_8A_TXA,  &nesM6502_ins_8B_XAA,  &nesM6502_ins_8C_STY,  &nesM6502_ins_8D_STA,  &nesM6502_ins_8E_STX,  &nesM6502_ins_8F_SAX,
      &nesM6502_ins_90_BCC,  &nesM6502_ins_91_STA,  &nesM6502_ins_92_STP,  &nesM6502_ins_93_SHA,  &nesM6502_ins_94_STY,  &nesM6502_ins_95_STA,  &nesM6502_ins_96_STX,  &nesM6502_ins_97_SAX,
      &nesM6502_ins_98_TYA,  &nesM6502_ins_99_STA,  &nesM6502_ins_9A_TXS,  &nesM6502_ins_9B_SHS,  &nesM6502_ins_9C_SHY,  &nesM6502_ins_9D_STA,  &nesM6502_ins_9E_SHX,  &nesM6502_ins_9F_SHA,
      &nesM6502_ins_A0_LDY,  &nesM6502_ins_A1_LDA,  &nesM6502_ins_A2_LDX,  &nesM6502_ins_A3_LAX,  &nesM6502_ins_A4_LDY,  &nesM6502_ins_A5_LDA,  &nesM6502_ins_A6_LDX,  &nesM6502_ins_A7_LAX,
      &nesM6502_ins_A8_TAY,  &nesM6502_ins_A9_LDA,  &nesM6502_ins_AA_TAX,  &nesM6502_ins_AB_LXA,  &nesM6502_ins_AC_LDY,  &nesM6502_ins_AD_LDA,  &nesM6502_ins_AE_LDX,  &nesM6502_ins_AF_LAX,
      &nesM6502_ins_B0_BCS,  &nesM6502_ins_B1_LDA,  &nesM6502_ins_B2_STP,  &nesM6502_ins_B3_LAX,  &nesM6502_ins_B4_LDY,  &nesM6502_ins_B5_LDA,  &nesM6502_ins_B6_LDX,  &nesM6502_ins_B7_LAX,
      &nesM6502_ins_B8_CLV,  &nesM6502_ins_B9_LDA,  &nesM6502_ins_BA_TSX,  &nesM6502_ins_BB_LAS,  &nesM6502_ins_BC_LDY,  &nesM6502_ins_BD_LDA,  &nesM6502_ins_BE_LDX,  &nesM6502_ins_BF_LAX,
      &nesM6502_ins_C0_CPY,  &nesM6502_ins_C1_CMP,  &nesM6502_ins_C2_NOP22,  &nesM6502_ins_C3_DCP,  &nesM6502_ins_C4_CPY,  &nesM6502_ins_C5_CMP,  &nesM6502_ins_C6_DEC,  &nesM6502_ins_C7_DCP,
      &nesM6502_ins_C8_INY,  &nesM6502_ins_C9_CMP,  &nesM6502_ins_CA_DEX,  &nesM6502_ins_CB_SBX,  &nesM6502_ins_CC_CPY,  &nesM6502_ins_CD_CMP,  &nesM6502_ins_CE_DEC,  &nesM6502_ins_CF_DCP,
      &nesM6502_ins_D0_BNE,  &nesM6502_ins_D1_CMP,  &nesM6502_ins_D2_STP,  &nesM6502_ins_D3_DCP,  &nesM6502_ins_D4_NOP24,  &nesM6502_ins_D5_CMP,  &nesM6502_ins_D6_DEC,  &nesM6502_ins_D7_DCP,
      &nesM6502_ins_D8_CLD,  &nesM6502_ins_D9_CMP,  &nesM6502_ins_DA_NOP,  &nesM6502_ins_DB_DCP,  &nesM6502_ins_DC_NOP24,  &nesM6502_ins_DD_CMP,  &nesM6502_ins_DE_DEC,  &nesM6502_ins_DF_DCP,
      &nesM6502_ins_E0_CPX,  &nesM6502_ins_E1_SBC,  &nesM6502_ins_E2_NOP22,  &nesM6502_ins_E3_ISC,  &nesM6502_ins_E4_CPX,  &nesM6502_ins_E5_SBC,  &nesM6502_ins_E6_INC,  &nesM6502_ins_E7_ISC,
      &nesM6502_ins_E8_INX,  &nesM6502_ins_E9_SBC,  &nesM6502_ins_EA_NOP,  &nesM6502_ins_EB_SBC,  &nesM6502_ins_EC_CPX,  &nesM6502_ins_ED_SBC,  &nesM6502_ins_EE_INC,  &nesM6502_ins_EF_ISC,
      &nesM6502_ins_F0_BEQ,  &nesM6502_ins_F1_SBC,  &nesM6502_ins_F2_STP,  &nesM6502_ins_F3_ISC,  &nesM6502_ins_F4_NOP24,  &nesM6502_ins_F5_SBC,  &nesM6502_ins_F6_INC,  &nesM6502_ins_F7_ISC,
      &nesM6502_ins_F8_SED,  &nesM6502_ins_F9_SBC,  &nesM6502_ins_FA_NOP,  &nesM6502_ins_FB_ISC,  &nesM6502_ins_FC_NOP24,  &nesM6502_ins_FD_SBC,  &nesM6502_ins_FE_INC,  &nesM6502_ins_FF_ISC,
      &nesM6502_ins_100_S_RESET,  &nesM6502_ins_101_S_NMI,  &nesM6502_ins_102_S_IRQ
};
