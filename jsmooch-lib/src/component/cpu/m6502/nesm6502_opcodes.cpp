#include <cassert>
#include "helpers/int.h"
#include "nesm6502_opcodes.h"
#include "m6502.h"
namespace M6502 {
// This file auto-generated by m6502_core_generator.js in JSMooCh

static void nesins_NONE(regs &regs, pins &pins)
{
    assert(1==0);
}
static void nesins_00_BRK(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.P.B = 1;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            regs.TR = regs.PC;
            pins.D = (regs.TR >> 8) & 0xFF;
            pins.RW = 1;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.TR & 0xFF;
            break; }
        case 4: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte();
            break; }
        case 5: {
            regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs.P.I = 1;
            pins.RW = 0;
            pins.Addr = (0xFFFE);
            break; }
        case 6: {
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_01_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_02_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_03_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_04_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_05_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_06_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_07_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_08_PHP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte() | 0x30;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_09_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_0A_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = (regs.A & 0x80) >> 7;
            regs.A = (regs.A << 1) & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_0B_ANC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.C = regs.P.N;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_0C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_0D_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_0E_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_0F_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_10_BPL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.N == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_11_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_12_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_13_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = (pins.D << 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_14_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_15_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_16_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_17_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A |= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_18_CLC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_19_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_1A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_1B_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A |= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_1C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_1D_ORA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A |= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_1E_ASL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_1F_SLO(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = (regs.TR << 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A |= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_20_JSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            regs.TA = pins.D;
            regs.TR = regs.PC;
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 3: { //stack write PCH
            pins.RW = 1;
            pins.D = (regs.PC & 0xFF00) >> 8;
            break; }
        case 4: { //stack write PCL
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.PC & 0xFF;
            break; }
        case 5: {
            pins.Addr = regs.TR;
            pins.RW = 0;
            break; }
        case 6: { //cleanup_custom
            regs.PC = regs.TA | (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_21_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_22_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_23_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_24_BIT(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.P.Z = +((regs.A & pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.P.V = (pins.D & 0x40) >> 6;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_25_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_26_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_27_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_28_PLP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S + 1) & 0xFF;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //cleanup_custom
            regs.P.setbyte(pins.D);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_29_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_2A_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            u32 c = regs.P.C;
            regs.P.C = (regs.A & 0x80) >> 7;
            regs.A = ((regs.A << 1) | c) & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_2B_ANC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.C = regs.P.N;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_2C_BIT(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.P.Z = +((regs.A & pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.P.V = (pins.D & 0x40) >> 6;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_2D_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_2E_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_2F_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_30_BMI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.N == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_31_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_32_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_33_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            u32 c = regs.P.C;
            regs.P.C = (pins.D & 0x80) >> 7;
            pins.D = ((pins.D << 1) | c) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_34_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_35_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_36_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_37_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A &= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_38_SEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_39_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_3A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_3B_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A &= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_3C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_3D_AND(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_3E_ROL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_3F_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = (regs.TR & 0x80) >> 7;
            regs.TR = ((regs.TR << 1) | c) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            regs.A &= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_40_RTI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //spurious read
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            break; }
        case 3: { //Read P
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //Read PCL
            regs.P.setbyte(pins.D);
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 5: { //read PCH
            regs.PC = pins.D;
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 6: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_41_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_42_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_43_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_44_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_45_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_46_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_47_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_48_PHA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_49_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_4A_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.C = regs.A & 1;
            regs.A >>= 1;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_4B_ALR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.C = regs.A & 1;
            regs.A >>= 1;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_4C_JMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //cleanup_custom
            regs.PC = regs.TA | (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_4D_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_4E_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_4F_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_50_BVC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.V == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_51_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_52_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_53_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            regs.P.C = pins.D & 1;
            pins.D >>= 1;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = 0;
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_54_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_55_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_56_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_57_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            regs.A ^= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_58_CLI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: { //cleanup_custom
            regs.P.I = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_59_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_5A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_5B_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            regs.A ^= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_5C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_5D_EOR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A ^= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_5E_LSR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_5F_SRE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.P.C = regs.TR & 1;
            regs.TR >>= 1;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = 0;
            regs.A ^= regs.TR;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_60_RTS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //spurious read
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            break; }
        case 3: { //read PCL
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //read PCH
            regs.PC = pins.D;
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 5: { //spurious read
            regs.PC |= (pins.D << 8);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_61_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_62_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_63_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_64_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_65_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_66_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_67_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_68_PLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //spurious read
            pins.Addr = regs.PC;
            break; }
        case 2: { //spurious stack read
            pins.Addr = regs.S | 0x100;
            break; }
        case 3: { //good stack read
            regs.S = (regs.S + 1) & 0xFF;
            pins.Addr = regs.S | 0x100;
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_69_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_6A_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            u32 c = regs.P.C;
            regs.P.C = regs.A & 1;
            regs.A = (c << 7) | (regs.A >> 1);
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_6B_ARR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A &= pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            u32 c = regs.P.C;
            regs.P.C = regs.A & 1;
            regs.A = (c << 7) | (regs.A >> 1);
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.C = (regs.A >> 6) & 1;
            regs.P.V = ((regs.A >> 6) ^ (regs.A >> 5) & 1);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_6C_JMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //read ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //read ABSH
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TA = pins.D;
            break; }
        case 3: { //read PCL
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //read PCH
            regs.PC = pins.D;
            pins.Addr = (pins.Addr & 0xFF00) | ((pins.Addr + 1) & 0xFF);
            break; }
        case 5: { //cleanup_custom
            regs.PC |= pins.D << 8;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_6D_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_6E_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_6F_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_70_BVS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.V == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_71_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_72_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_73_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            u32 c = regs.P.C;
            regs.P.C = pins.D & 1;
            pins.D = (c << 7) | (pins.D >> 1);
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_74_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_75_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_76_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_77_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_78_SEI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: { //cleanup_custom
            regs.P.I = 1;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_NMI_only(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_79_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_7A_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_7B_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_7C_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_7D_ADC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins.D;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_7E_ROR(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_7F_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            u32 c = regs.P.C;
            regs.P.C = regs.TR & 1;
            regs.TR = (c << 7) | (regs.TR >> 1);
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR;
            o = i + regs.A + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_80_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_81_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Write result to addr
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_82_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_83_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Write result to addr
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = (regs.A & regs.X);
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_84_STY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = regs.Y;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_85_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_86_STX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = regs.X;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_87_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            pins.D = (regs.A & regs.X);
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_88_DEY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.Y = (regs.Y - 1) & 0xFF;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_89_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_8A_TXA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.A = regs.X;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_8B_XAA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A = (regs.A | 0xEE) & regs.X & pins.D;
            pins.D = regs.A;
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_8C_STY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.Y;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_8D_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.A;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_8E_STX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = regs.X;
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_8F_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            pins.D = (regs.A & regs.X);
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_90_BCC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.C == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_91_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TA = pins.D + regs.Y;
            regs.TR = (pins.D + regs.Y) & 0xFF;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //always idle
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            pins.Addr = (pins.D << 8) | regs.TR;
            regs.TR = regs.TA == pins.Addr;
            break; }
        case 5: { //write data
            pins.Addr = regs.TA;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_92_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_93_SHA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TA = pins.D + regs.Y;
            regs.TR = (pins.D + regs.Y) & 0xFF;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //always idle
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            pins.Addr = (pins.D << 8) | regs.TR;
            regs.TR = regs.TA == pins.Addr;
            break; }
        case 5: { //write data
            pins.Addr = regs.TA;
            pins.RW = 1;
            //SHA!
            if (!regs.TR) {
                pins.D = regs.A & regs.X & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            }
            else {
                pins.D = regs.A & regs.X & (((pins.Addr >> 8) + 1) & 0xFF);
            }
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_94_STY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.X) & 0xFF;
            pins.RW = 1;
            pins.D = regs.Y;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_95_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.X) & 0xFF;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_96_STX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.Y) & 0xFF;
            pins.RW = 1;
            pins.D = regs.X;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_97_SAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            break; }
        case 3: { //write data
            pins.Addr = (pins.Addr + regs.Y) & 0xFF;
            pins.RW = 1;
            pins.D = (regs.A & regs.X);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_98_TYA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.A = regs.Y;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_99_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_9A_TXS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.S = regs.X;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_9B_SHS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            regs.S = regs.A & regs.X;
            if (!regs.TR) {
                pins.D = regs.S & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            } else {
                pins.D = regs.S & (((pins.Addr >> 8) + 1) & 0xFF);
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_9C_SHY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            if (!regs.TR) {
                pins.D = regs.Y & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            } else {
                pins.D = (regs.Y & ((pins.Addr >> 8) + 1)) & 0xFF;
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_9D_STA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: {
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            pins.RW = 1;
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_9E_SHX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            if (!regs.TR) {
                pins.D = regs.X & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            } else {
                pins.D = (regs.X & ((pins.Addr >> 8) + 1)) & 0xFF;
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_9F_SHA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //get ABSL
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABSH
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //idle incorrect
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: {
            regs.TR = pins.Addr;
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            regs.TR = regs.TR == pins.Addr;
            //SHA!
            if (!regs.TR) {
                pins.D = regs.A & regs.X & (pins.Addr >> 8);
                pins.Addr = (pins.Addr & 0xFF) | (pins.D << 8);
            }
            else {
                pins.D = regs.A & regs.X & (((pins.Addr >> 8) + 1) & 0xFF);
            }
            pins.RW = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A0_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A1_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A2_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A3_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A4_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A5_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A6_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A7_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A8_TAY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.Y = regs.A;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_A9_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_AA_TAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = regs.A;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_AB_LXA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.A = regs.X = (regs.A | 0xEE) & pins.D;
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.P.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_AC_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_AD_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_AE_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_AF_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B0_BCS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.C == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B1_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B2_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B3_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B4_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B5_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B6_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.Y) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B7_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.Y) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B8_CLV(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.V = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_B9_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_BA_TSX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = regs.S;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_BB_LAS(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D & regs.S;
            regs.X = regs.S = regs.A;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_BC_LDY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.Y = pins.D;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_BD_LDA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_BE_LDX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_BF_LAX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            regs.A = pins.D;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            regs.X = pins.D;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C0_CPY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs.Y - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C1_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C2_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C3_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C4_CPY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs.Y - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C5_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C6_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C7_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C8_INY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.Y = (regs.Y + 1) & 0xFF;
            regs.P.Z = +((regs.Y) == 0);
            regs.P.N = ((regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_C9_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_CA_DEX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = (regs.X - 1) & 0xFF;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_CB_SBX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            regs.X &= regs.A;
            u16 d = regs.X - pins.D;
            regs.X = d & 0xFF;
            regs.P.N = ((d) & 0x80) >> 7;
            regs.P.Z = +((d) == 0);
            regs.P.C = ((d >> 8) ^ 1) & 1;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_CC_CPY(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.Y - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_CD_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_CE_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_CF_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D0_BNE(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.Z == 0);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D1_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D2_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D3_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            pins.D = (pins.D - 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D4_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D5_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D6_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D7_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o = regs.A - regs.TR;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D8_CLD(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.D = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_D9_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_DA_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_DB_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o = regs.A - regs.TR;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_DC_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_DD_CMP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o = regs.A - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_DE_DEC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_DF_DCP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR - 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o = regs.A - regs.TR;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E0_CPX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o = regs.X - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E1_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E2_NOP22(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E3_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            pins.Addr = pins.D;
            regs.TA = (pins.D + regs.X) & 0xFF;
            break; }
        case 3: { //real read ABS L
            pins.Addr = regs.TA;
            break; }
        case 4: { //read ABS H
            regs.TA = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 5: { //Read from addr
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 6: { //spurious
            pins.RW = 1;
            break; }
        case 7: { //write result
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E4_CPX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o = regs.X - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E5_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = pins.D;
            break; }
        case 3: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E6_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E7_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //fetch ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //capture data
            pins.Addr = pins.D;
            break; }
        case 3: { //spurious read/write
            pins.RW = 1;
            break; }
        case 4: { //real write
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E8_INX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.X = (regs.X + 1) & 0xFF;
            regs.P.Z = +((regs.X) == 0);
            regs.P.N = ((regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_E9_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_EA_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_EB_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_EC_CPX(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o = regs.X - pins.D;
            regs.P.C = +(!((o & 0x100) >> 8));
            regs.P.Z = +((o & 0xFF) == 0);
            regs.P.N = ((o) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_ED_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_EE_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_EF_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            break; }
        case 4: {
            pins.RW = 1;
            break; }
        case 5: {
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F0_BEQ(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.TR = +(regs.P.Z == 1);
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!regs.TR) { regs.TA = regs.PC; regs.TCU += 2; break; }
            break; }
        case 2: {
            regs.TA = (static_cast<i32>(regs.PC) + static_cast<i32>(static_cast<i8>(pins.D))) & 0xFFFF;
            pins.Addr = regs.PC;
            if ((regs.TA & 0xFF00) == (regs.PC & 0xFF00)) { regs.TCU++; break; } // Skip to end if same page
            break; }
        case 3: { //extra idle on page cross
            pins.Addr = (regs.PC & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 4: { //cleanup_custom
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F1_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: {
            pins.Addr = regs.TA;
            break; }
        case 6: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F2_STP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            break; }
        case 2: {
            break; }
        case 3: { //cleanup_custom
            regs.STP = TRUE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F3_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //Get ZP
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //get ABS L
            pins.Addr = pins.D;
            break; }
        case 3: { //get ABS H
            regs.TR = pins.D;
            regs.TA = pins.D + regs.Y;
            pins.Addr = (pins.Addr + 1) & 0xFF;
            break; }
        case 4: { //idle if crossed
            regs.TR = (regs.TR + (pins.D << 8)) & 0xFFFF;
            regs.TA = (regs.TA + (pins.D << 8)) & 0xFFFF;
            if ((regs.TR & 0xFF00) == (regs.TA & 0xFF00)) { pins.Addr = regs.TA; break; }
            pins.Addr = (regs.TR & 0xFF00) | (regs.TA & 0xFF);
            break; }
        case 5: { //idle
            pins.Addr = regs.TA;
            break; }
        case 6: { //spurious write
            pins.RW = 1;
            break; }
        case 7: { //duplicate write cycle
            pins.D = (pins.D + 1) & 0xFF;
            regs.P.Z = +((pins.D) == 0);
            regs.P.N = ((pins.D) & 0x80) >> 7;
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F4_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F5_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F6_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F7_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { //spurious read
            regs.TA = (pins.D + regs.X) & 0xFF;
            pins.Addr = pins.D;
            break; }
        case 3: {
            pins.Addr = regs.TA;
            break; }
        case 4: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            break; }
        case 5: {
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F8_SED(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.P.D = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_F9_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.Y) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_FA_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_FB_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.Y) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.Y) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_FC_NOP24(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_FD_SBC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            pins.Addr = regs.TA | (pins.D << 8);
            regs.TA = (pins.Addr + regs.X) & 0xFFFF;
            if ((regs.TA & 0xFF00) == (pins.Addr & 0xFF00)) { regs.TCU++; pins.Addr = regs.TA; break; }
            pins.Addr = (pins.D << 8) | (regs.TA & 0xFF);
            break; }
        case 4: { //optional
            pins.Addr = regs.TA;
            break; }
        case 5: { //cleanup_custom
            i32 o;
            i32 i = pins.D ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_FE_INC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_FF_ISC(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TA = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { //spurious read
            regs.TA |= pins.D << 8;
            pins.Addr = (regs.TA & 0xFF00) | ((regs.TA + regs.X) & 0xFF);
            break; }
        case 4: { //real read
            pins.Addr = (regs.TA + regs.X) & 0xFFFF;
            break; }
        case 5: { //spurious read/write
            regs.TR = pins.D;
            pins.RW = 1;
            break; }
        case 6: {
            regs.TR = (regs.TR + 1) & 0xFF;
            regs.P.Z = +((regs.TR) == 0);
            regs.P.N = ((regs.TR) & 0x80) >> 7;
            i32 o;
            i32 i = regs.TR ^ 0xFF;
            o = regs.A + i + regs.P.C;
            regs.P.V = ((~(regs.A ^ i)) & (regs.A ^ o) & 0x80) >> 7;
            regs.P.C = +(o > 0xFF);
            regs.A = o & 0xFF;
            regs.P.Z = +((regs.A) == 0);
            regs.P.N = ((regs.A) & 0x80) >> 7;
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { //cleanup
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            pins.RW = 0;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_100_S_RESET(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { //3
            pins.RW = 0;
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 2: { //4
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 3: { //5
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 4: { //6
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            break; }
        case 5: { //7
            pins.Addr = (0xFFFC);
            break; }
        case 6: { //8
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_101_S_NMI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.P.B = 0;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            regs.TR = (regs.PC - 2) & 0xFFFF;
            pins.D = (regs.TR >> 8) & 0xFF;
            pins.RW = 1;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.TR & 0xFF;
            break; }
        case 4: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte();
            break; }
        case 5: {
            regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs.P.I = 1;
            pins.RW = 0;
            pins.Addr = (0xFFFA);
            break; }
        case 6: {
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}

static void nesins_102_S_IRQ(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.P.B = 0;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            regs.TR = (regs.PC - 2) & 0xFFFF;
            pins.D = (regs.TR >> 8) & 0xFF;
            pins.RW = 1;
            break; }
        case 3: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.TR & 0xFF;
            break; }
        case 4: {
            pins.Addr = regs.S | 0x100;
            regs.S = (regs.S - 1) & 0xFF;
            pins.D = regs.P.getbyte();
            break; }
        case 5: {
            regs.P.B = 1; // Confirmed via Visual6502 that this bit is actually set always during NMI, IRQ, and BRK. It basically always stays 1 unless forced to 0
            regs.P.I = 1;
            pins.RW = 0;
            pins.Addr = (0xFFFE);
            break; }
        case 6: {
            regs.PC = pins.D;
            pins.Addr = (pins.Addr + 1) & 0xFFFF;
            break; }
        case 7: { //cleanup_custom
            regs.PC |= (pins.D << 8);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            poll_IRQs(regs, pins);
            regs.TCU = 0;
            break;
    }}
}


ins_func nesdecoded_opcodes[0x103] = {
        &nesins_00_BRK,  &nesins_01_ORA,  &nesins_02_STP,  &nesins_03_SLO,  &nesins_04_NOP24,  &nesins_05_ORA,  &nesins_06_ASL,  &nesins_07_SLO,
      &nesins_08_PHP,  &nesins_09_ORA,  &nesins_0A_ASL,  &nesins_0B_ANC,  &nesins_0C_NOP24,  &nesins_0D_ORA,  &nesins_0E_ASL,  &nesins_0F_SLO,
      &nesins_10_BPL,  &nesins_11_ORA,  &nesins_12_STP,  &nesins_13_SLO,  &nesins_14_NOP24,  &nesins_15_ORA,  &nesins_16_ASL,  &nesins_17_SLO,
      &nesins_18_CLC,  &nesins_19_ORA,  &nesins_1A_NOP,  &nesins_1B_SLO,  &nesins_1C_NOP24,  &nesins_1D_ORA,  &nesins_1E_ASL,  &nesins_1F_SLO,
      &nesins_20_JSR,  &nesins_21_AND,  &nesins_22_STP,  &nesins_23_RLA,  &nesins_24_BIT,  &nesins_25_AND,  &nesins_26_ROL,  &nesins_27_RLA,
      &nesins_28_PLP,  &nesins_29_AND,  &nesins_2A_ROL,  &nesins_2B_ANC,  &nesins_2C_BIT,  &nesins_2D_AND,  &nesins_2E_ROL,  &nesins_2F_RLA,
      &nesins_30_BMI,  &nesins_31_AND,  &nesins_32_STP,  &nesins_33_RLA,  &nesins_34_NOP24,  &nesins_35_AND,  &nesins_36_ROL,  &nesins_37_RLA,
      &nesins_38_SEC,  &nesins_39_AND,  &nesins_3A_NOP,  &nesins_3B_RLA,  &nesins_3C_NOP24,  &nesins_3D_AND,  &nesins_3E_ROL,  &nesins_3F_RLA,
      &nesins_40_RTI,  &nesins_41_EOR,  &nesins_42_STP,  &nesins_43_SRE,  &nesins_44_NOP24,  &nesins_45_EOR,  &nesins_46_LSR,  &nesins_47_SRE,
      &nesins_48_PHA,  &nesins_49_EOR,  &nesins_4A_LSR,  &nesins_4B_ALR,  &nesins_4C_JMP,  &nesins_4D_EOR,  &nesins_4E_LSR,  &nesins_4F_SRE,
      &nesins_50_BVC,  &nesins_51_EOR,  &nesins_52_STP,  &nesins_53_SRE,  &nesins_54_NOP24,  &nesins_55_EOR,  &nesins_56_LSR,  &nesins_57_SRE,
      &nesins_58_CLI,  &nesins_59_EOR,  &nesins_5A_NOP,  &nesins_5B_SRE,  &nesins_5C_NOP24,  &nesins_5D_EOR,  &nesins_5E_LSR,  &nesins_5F_SRE,
      &nesins_60_RTS,  &nesins_61_ADC,  &nesins_62_STP,  &nesins_63_RRA,  &nesins_64_NOP24,  &nesins_65_ADC,  &nesins_66_ROR,  &nesins_67_RRA,
      &nesins_68_PLA,  &nesins_69_ADC,  &nesins_6A_ROR,  &nesins_6B_ARR,  &nesins_6C_JMP,  &nesins_6D_ADC,  &nesins_6E_ROR,  &nesins_6F_RRA,
      &nesins_70_BVS,  &nesins_71_ADC,  &nesins_72_STP,  &nesins_73_RRA,  &nesins_74_NOP24,  &nesins_75_ADC,  &nesins_76_ROR,  &nesins_77_RRA,
      &nesins_78_SEI,  &nesins_79_ADC,  &nesins_7A_NOP,  &nesins_7B_RRA,  &nesins_7C_NOP24,  &nesins_7D_ADC,  &nesins_7E_ROR,  &nesins_7F_RRA,
      &nesins_80_NOP22,  &nesins_81_STA,  &nesins_82_NOP22,  &nesins_83_SAX,  &nesins_84_STY,  &nesins_85_STA,  &nesins_86_STX,  &nesins_87_SAX,
      &nesins_88_DEY,  &nesins_89_NOP22,  &nesins_8A_TXA,  &nesins_8B_XAA,  &nesins_8C_STY,  &nesins_8D_STA,  &nesins_8E_STX,  &nesins_8F_SAX,
      &nesins_90_BCC,  &nesins_91_STA,  &nesins_92_STP,  &nesins_93_SHA,  &nesins_94_STY,  &nesins_95_STA,  &nesins_96_STX,  &nesins_97_SAX,
      &nesins_98_TYA,  &nesins_99_STA,  &nesins_9A_TXS,  &nesins_9B_SHS,  &nesins_9C_SHY,  &nesins_9D_STA,  &nesins_9E_SHX,  &nesins_9F_SHA,
      &nesins_A0_LDY,  &nesins_A1_LDA,  &nesins_A2_LDX,  &nesins_A3_LAX,  &nesins_A4_LDY,  &nesins_A5_LDA,  &nesins_A6_LDX,  &nesins_A7_LAX,
      &nesins_A8_TAY,  &nesins_A9_LDA,  &nesins_AA_TAX,  &nesins_AB_LXA,  &nesins_AC_LDY,  &nesins_AD_LDA,  &nesins_AE_LDX,  &nesins_AF_LAX,
      &nesins_B0_BCS,  &nesins_B1_LDA,  &nesins_B2_STP,  &nesins_B3_LAX,  &nesins_B4_LDY,  &nesins_B5_LDA,  &nesins_B6_LDX,  &nesins_B7_LAX,
      &nesins_B8_CLV,  &nesins_B9_LDA,  &nesins_BA_TSX,  &nesins_BB_LAS,  &nesins_BC_LDY,  &nesins_BD_LDA,  &nesins_BE_LDX,  &nesins_BF_LAX,
      &nesins_C0_CPY,  &nesins_C1_CMP,  &nesins_C2_NOP22,  &nesins_C3_DCP,  &nesins_C4_CPY,  &nesins_C5_CMP,  &nesins_C6_DEC,  &nesins_C7_DCP,
      &nesins_C8_INY,  &nesins_C9_CMP,  &nesins_CA_DEX,  &nesins_CB_SBX,  &nesins_CC_CPY,  &nesins_CD_CMP,  &nesins_CE_DEC,  &nesins_CF_DCP,
      &nesins_D0_BNE,  &nesins_D1_CMP,  &nesins_D2_STP,  &nesins_D3_DCP,  &nesins_D4_NOP24,  &nesins_D5_CMP,  &nesins_D6_DEC,  &nesins_D7_DCP,
      &nesins_D8_CLD,  &nesins_D9_CMP,  &nesins_DA_NOP,  &nesins_DB_DCP,  &nesins_DC_NOP24,  &nesins_DD_CMP,  &nesins_DE_DEC,  &nesins_DF_DCP,
      &nesins_E0_CPX,  &nesins_E1_SBC,  &nesins_E2_NOP22,  &nesins_E3_ISC,  &nesins_E4_CPX,  &nesins_E5_SBC,  &nesins_E6_INC,  &nesins_E7_ISC,
      &nesins_E8_INX,  &nesins_E9_SBC,  &nesins_EA_NOP,  &nesins_EB_SBC,  &nesins_EC_CPX,  &nesins_ED_SBC,  &nesins_EE_INC,  &nesins_EF_ISC,
      &nesins_F0_BEQ,  &nesins_F1_SBC,  &nesins_F2_STP,  &nesins_F3_ISC,  &nesins_F4_NOP24,  &nesins_F5_SBC,  &nesins_F6_INC,  &nesins_F7_ISC,
      &nesins_F8_SED,  &nesins_F9_SBC,  &nesins_FA_NOP,  &nesins_FB_ISC,  &nesins_FC_NOP24,  &nesins_FD_SBC,  &nesins_FE_INC,  &nesins_FF_ISC,
      &nesins_100_S_RESET,  &nesins_101_S_NMI,  &nesins_102_S_IRQ
};

}
