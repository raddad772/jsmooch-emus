#include "helpers/int.h"
#include "z80.h"

// This file auto-generated by z80_core_generator.js in JSMoo

void Z80_ins_00_00_NOP(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_01_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_02_LD_irr_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->WZ = (regs->B << 8) | regs->C;
            pins->Addr = (regs->WZ);
            break; }
        case 2: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_03_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = (((regs->B << 8) | regs->C ) + 1) & 0xFFFF;
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_04_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->B) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_05_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->B) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_06_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_07_RLCA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = (regs->A & 0x80) >> 7;
            regs->A = ((regs->A << 1) | c) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_08_EX_rr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_shadow_af(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_09_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was HL
            regs->Q = 1;
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = regs->L;
            y = regs->C;
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = regs->B;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->H = regs->t[5];
            regs->L = regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_0A_LD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->WZ = (regs->B << 8) | regs->C;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_0B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = (regs->B << 8) | regs->C;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->B = ((regs->TA) & 0xFF00) >> 8;
            regs->C = (regs->TA) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_0C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->C) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_0D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->C) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_0E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_0F_RRCA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = regs->A & 1;
            regs->A = (c << 7) | (regs->A >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_10_DJNZ_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            break; }
        case 2: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->B = (regs->B - 1) & 0xFF;
            if (regs->B == 0) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 5: { // Adding 5 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            break; }
        case 9: {
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_11_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_12_LD_irr_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->WZ = (regs->D << 8) | regs->E;
            pins->Addr = (regs->WZ);
            break; }
        case 2: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_13_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = (((regs->D << 8) | regs->E ) + 1) & 0xFFFF;
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_14_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->D) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_15_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->D) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_16_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_17_RLA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = (regs->A & 0x80) >> 7;
            regs->A = ((regs->A << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_18_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_19_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was HL
            regs->Q = 1;
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = regs->L;
            y = regs->E;
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = regs->D;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->H = regs->t[5];
            regs->L = regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_1A_LD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->WZ = (regs->D << 8) | regs->E;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_1B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = (regs->D << 8) | regs->E;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->D = ((regs->TA) & 0xFF00) >> 8;
            regs->E = (regs->TA) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_1C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->E) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_1D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->E) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_1E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_1F_RRA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = regs->A & 1;
            regs->A = (regs->F.C << 7) | (regs->A >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_20_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 0)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_21_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->H = ((regs->TR) & 0xFF00) >> 8;
            regs->L = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_22_LD_inn_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->L);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 10: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 11: {
            pins->D = (regs->H);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_23_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = (((regs->H << 8) | regs->L ) + 1) & 0xFFFF;
            regs->H = ((regs->TR) & 0xFF00) >> 8;
            regs->L = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_24_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->H) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_25_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->H) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_26_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_27_DAA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 a = regs->A;
            if (regs->F.C || (regs->A > 0x99)) { regs->A = (regs->A + (regs->F.N ? -0x60: 0x60)) & 0xFF; regs->F.C = 1; }
            if (regs->F.H || ((regs->A & 0x0F) > 0x09)) { regs->A = (regs->A + (regs->F.N ? -6 : 6)) & 0xFF; }
            regs->F.PV = Z80_parity(regs->A);
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.H = ((a ^ regs->A) & 0x10) >> 4;
            regs->F.Z = +(regs->A == 0);
            regs->F.S = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_28_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_29_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was HL
            regs->Q = 1;
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = regs->L;
            y = regs->L;
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = regs->H;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->H = regs->t[5];
            regs->L = regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_2A_LD_rr_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TA = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->L = (regs->TR);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->WZ = regs->TA;
            break; }
        case 10: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 11: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 12: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->H = (regs->TR);
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_2B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = (regs->H << 8) | regs->L;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_2C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->L) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_2D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->L) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_2E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_2F_CPL(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A ^= 0xFF;
            regs->F.N = regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_30_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 0)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_31_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->SP = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_32_LD_inn_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_33_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = ((regs->SP ) + 1) & 0xFFFF;
            regs->SP = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_34_INC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: {
            regs->TR = ((regs->TR) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_35_DEC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: {
            regs->TR = ((regs->TR) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_36_LD_irr_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 5: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 6: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_37_SCF(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            if (regs->Q) { regs->F.X = 0; regs->F.Y = 0; }
            regs->F.C = regs->Q = 1;
            regs->F.N = regs->F.H = 0;
            regs->F.X |= ((regs->A & 8) >> 3);
            regs->F.Y |= ((regs->A & 0x20) >> 5);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_38_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_39_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was HL
            regs->Q = 1;
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = regs->L;
            y = (regs->SP & 0xFF);
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = ((regs->SP & 0xFF00) >> 8);
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->H = regs->t[5];
            regs->L = regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_3A_LD_a_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_3B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = regs->SP;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->SP = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_3C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->A) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_3D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->A) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_3E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_3F_CCF(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            if (regs->Q) { regs->F.X = regs->F.Y = 0; } 
            regs->F.H = regs->F.C;
            regs->F.C = +(!regs->F.C);
            regs->F.N = 0;
            regs->F.X |= (regs->A & 8) >> 3;
            regs->F.Y |= (regs->A & 0x20) >> 5;
            regs->Q = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_40_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_41_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_42_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_43_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_44_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_45_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_46_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_47_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_48_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_49_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_4A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_4B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_4C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_4D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_4E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_4F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_50_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_51_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_52_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_53_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_54_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_55_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_56_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_57_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_58_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_59_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_5A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_5B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_5C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_5D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_5E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_5F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_60_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->H = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_61_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->H = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_62_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->H = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_63_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->H = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_64_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->H = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_65_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->H = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_66_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_67_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->H = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_68_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->L = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_69_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->L = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_6A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->L = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_6B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->L = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_6C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->L = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_6D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->L = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_6E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_6F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->L = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_70_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: {
            pins->D = (regs->B);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_71_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: {
            pins->D = (regs->C);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_72_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: {
            pins->D = (regs->D);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_73_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: {
            pins->D = (regs->E);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_74_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: {
            pins->D = (regs->H);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_75_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: {
            pins->D = (regs->L);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_76_HALT(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->HALT = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_77_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_78_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_79_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_7A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_7B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_7C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_7D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_7E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_7F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_80_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->B;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_81_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->C;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_82_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->D;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_83_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->E;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_84_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->H;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_85_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->L;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_86_ADD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_87_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->A;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_88_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->B;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_89_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->C;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_8A_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->D;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_8B_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->E;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_8C_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->H;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_8D_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->L;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_8E_ADC_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_8F_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->A;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_90_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->B);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_91_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->C);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_92_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->D);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_93_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->E);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_94_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->H);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_95_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->L);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_96_SUB_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_97_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_98_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->B);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_99_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->C);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_9A_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->D);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_9B_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->E);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_9C_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->H);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_9D_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->L);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_9E_SBC_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_9F_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->A);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A0_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->B);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A1_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->C);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A2_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->D);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A3_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->E);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A4_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->H);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A5_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->L);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A6_AND_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A7_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->A);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A8_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_A9_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_AA_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_AB_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_AC_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->H);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_AD_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->L);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_AE_XOR_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_AF_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B0_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B1_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B2_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B3_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B4_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->H);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B5_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->L);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B6_OR_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B7_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B8_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->B;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_B9_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->C;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_BA_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->D;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_BB_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->E;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_BC_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->H;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_BD_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->L;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_BE_CP_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->TR;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_BF_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->A;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.Z == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.Z == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C3_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.Z == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->B);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (regs->C);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C6_ADD_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x00;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.Z == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_C9_RET(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_CA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.Z == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_CC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.Z == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_CD_CALL_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 14: { // cleanup_custom
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_CE_ADC_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_CF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x08;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.C == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.C == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D3_OUT_in_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->A << 8);
            break; }
        case 4: { // OUT start
            pins->Addr = regs->WZ;
            pins->D = regs->A;
            regs->data = pins->D;
            break; }
        case 5: { // OUT continues
            break; }
        case 6: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 7: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->WZ & 0xFF00);
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.C == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->D);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (regs->E);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D6_SUB_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x10;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.C == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_D9_EXX(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_shadow(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_DA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.C == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_DB_IN_a_in(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->A << 8);
            break; }
        case 4: { // IN start
            pins->Addr = regs->WZ;
            break; }
        case 5: { // IN actual read
            break; }
        case 6: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 7: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->A = pins->D;
            regs->data = pins->D;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_DC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.C == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_DE_SBC_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_DF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x18;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.PV == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->H = ((regs->TR) & 0xFF00) >> 8;
            regs->L = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.PV == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E3_EX_irr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = regs->SP;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ |= (regs->TR << 8);
            break; }
        case 7: { // wait
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (regs->L);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 12: {
            pins->D = (regs->H);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 14: { // wait
            break; }
        case 15: { // wait
            regs->H = ((regs->WZ) & 0xFF00) >> 8;
            regs->L = (regs->WZ) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 16: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.PV == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->H);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (regs->L);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E6_AND_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x20;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.PV == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_E9_JP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->PC = (regs->H << 8) | regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_EA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.PV == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_EB_EX_rr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_de_hl(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_EC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.PV == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_EE_XOR_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_EF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x28;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.S == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->A = ((regs->TR) & 0xFF00) >> 8;
            Z80_regs_F_setbyte(&regs->F, (regs->TR) & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.S == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F3_DI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IFF1 = regs->IFF2 = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.S == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (Z80_regs_F_getbyte(&regs->F));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F6_OR_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x30;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.S == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_F9_LD_sp_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->SP = (regs->H << 8) | regs->L;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_FA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.S == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_FB_EI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IFF1 = regs->IFF2 = regs->EI = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_FC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.S == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_FE_CP_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->TR;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_FF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x38;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_00_100_IRQ(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IRQ processing idle cycle!
            break; }
        case 2: { // Start IACK read
            regs->R = (regs->R + 1) & 0x7F;
            pins->RD = 0; pins->WR = 0; pins->MRQ = 0; pins->IO = 0;
            break; }
        case 3: { // signal IACK
            pins->RD = 1; pins->IO = 1;
            pins->M1 = 1;
            break; }
        case 4: { // wait 1
            if (pins->WAIT) regs->TCU--;
            break; }
        case 5: { // wait 2
            if (pins->WAIT) regs->TCU--;
            break; }
        case 6: { // Latch value...
            pins->M1 = 0;
            regs->t[0] = pins->D;
            pins->RD = 0; pins->IO = 0;
            regs->t[1] = pins->IRQ_maskable ? regs->IM : 1;
            if (regs->t[1] == 0) {
                printf("\nOH NO PANIC!!!!");
                return;
            }
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 8: {
            pins->D = ((regs->PC >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 10: { // push PC lo begin
            pins->Addr = regs->SP;
            break; }
        case 11: {
            pins->D = regs->PC & 0xFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            if (regs->t[1] == 1) {
                regs->TCU += 6;
            }
            regs->t[2] = (regs->I << 8) | regs->t[0];
            break; }
        case 13: { // Start read
            pins->Addr = (regs->t[2]);
            break; }
        case 14: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 15: { // Read end/latch
            regs->t[3] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->t[2] = (regs->t[2] + 1) & 0xFFFF;
            break; }
        case 16: { // Start read
            pins->Addr = regs->t[2];
            break; }
        case 17: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 18: { // finish read...
            pins->RD = 0; pins->MRQ = 0;
            regs->t[3] |= (pins->D << 8);
            break; }
        case 19: { // cleanup_custom
            pins->WR = 0;
            if (regs->t[1] == 1) { // IM1
                regs->WZ = regs->PC = regs->IRQ_vec;
            }
            else { // IM2
                regs->WZ = regs->PC = regs->t[3];
            }
            regs->IRQ_vec = 0;
            regs->IFF1 = 0;
            if (pins->IRQ_maskable) regs->IFF2 = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            break;
    }}
}

void Z80_ins_00_101_RESET(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->IFF1 = regs->IFF2 = 0; // disable interrupt
            regs->IM = 0;
            regs->I = 0;
            regs->R = 0;
            regs->PC = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_00_RLC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_01_RLC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_02_RLC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_03_RLC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_04_RLC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_05_RLC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_06_RLC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_07_RLC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_08_RRC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_09_RRC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_0A_RRC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_0B_RRC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_0C_RRC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_0D_RRC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_0E_RRC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_0F_RRC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_10_RL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_11_RL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_12_RL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_13_RL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_14_RL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_15_RL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_16_RL_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_17_RL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_18_RR_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_19_RR_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_1A_RR_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_1B_RR_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_1C_RR_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_1D_RR_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_1E_RR_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_1F_RR_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_20_SLA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_21_SLA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_22_SLA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_23_SLA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_24_SLA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_25_SLA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_26_SLA_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_27_SLA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_28_SRA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_29_SRA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_2A_SRA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_2B_SRA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_2C_SRA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_2D_SRA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_2E_SRA_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_2F_SRA_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_30_SLL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_31_SLL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_32_SLL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_33_SLL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_34_SLL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_35_SLL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_36_SLL_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_37_SLL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_38_SRL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->B;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_39_SRL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->C;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_3A_SRL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->D;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_3B_SRL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->E;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_3C_SRL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->H;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_3D_SRL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->L;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_3E_SRL_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_3F_SRL_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_40_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_41_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_42_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_43_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_44_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_45_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_46_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_47_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_48_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_49_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_4A_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_4B_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_4C_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_4D_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_4E_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_4F_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_50_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_51_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_52_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_53_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_54_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_55_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_56_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_57_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_58_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_59_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_5A_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_5B_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_5C_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_5D_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_5E_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_5F_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_60_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_61_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_62_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_63_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_64_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_65_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_66_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_67_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_68_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_69_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_6A_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_6B_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_6C_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_6D_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_6E_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_6F_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_70_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_71_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_72_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_73_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_74_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_75_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_76_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_77_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_78_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->B) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_79_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->C) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->C) & 8) >> 3;
            regs->F.Y = ((regs->C) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_7A_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->D) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->D) & 8) >> 3;
            regs->F.Y = ((regs->D) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_7B_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->E) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->E) & 8) >> 3;
            regs->F.Y = ((regs->E) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_7C_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->H) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->H) & 8) >> 3;
            regs->F.Y = ((regs->H) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_7D_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->L) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->L) & 8) >> 3;
            regs->F.Y = ((regs->L) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_7E_BIT_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            break; }
        case 4: { // wait
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_7F_BIT_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_80_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 0) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_81_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 0) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_82_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 0) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_83_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 0) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_84_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 0) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_85_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 0) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_86_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_87_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 0) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_88_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 1) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_89_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 1) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_8A_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 1) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_8B_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 1) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_8C_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 1) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_8D_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 1) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_8E_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_8F_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 1) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_90_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 2) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_91_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 2) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_92_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 2) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_93_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 2) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_94_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 2) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_95_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 2) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_96_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_97_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 2) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_98_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 3) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_99_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 3) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_9A_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 3) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_9B_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 3) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_9C_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 3) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_9D_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 3) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_9E_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_9F_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 3) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A0_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 4) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A1_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 4) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A2_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 4) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A3_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 4) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A4_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 4) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A5_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 4) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A6_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A7_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 4) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A8_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 5) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_A9_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 5) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_AA_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 5) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_AB_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 5) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_AC_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 5) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_AD_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 5) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_AE_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_AF_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 5) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B0_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 6) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B1_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 6) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B2_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 6) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B3_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 6) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B4_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 6) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B5_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 6) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B6_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B7_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 6) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B8_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->B = regs->B & ((1 << 7) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_B9_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->C = regs->C & ((1 << 7) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_BA_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->D = regs->D & ((1 << 7) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_BB_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->E = regs->E & ((1 << 7) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_BC_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->H = regs->H & ((1 << 7) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_BD_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->L = regs->L & ((1 << 7) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_BE_RES_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_BF_RES_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A = regs->A & ((1 << 7) ^ 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C0_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 0);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C1_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 0);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C2_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 0);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C3_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 0);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C4_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 0);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C5_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 0);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C6_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C7_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C8_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 1);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_C9_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 1);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_CA_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 1);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_CB_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 1);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_CC_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 1);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_CD_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 1);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_CE_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_CF_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 1);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D0_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 2);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D1_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 2);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D2_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 2);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D3_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 2);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D4_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 2);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D5_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 2);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D6_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D7_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 2);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D8_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 3);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_D9_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 3);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_DA_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 3);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_DB_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 3);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_DC_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 3);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_DD_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 3);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_DE_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_DF_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 3);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E0_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 4);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E1_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 4);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E2_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 4);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E3_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 4);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E4_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 4);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E5_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 4);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E6_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E7_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 4);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E8_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 5);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_E9_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 5);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_EA_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 5);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_EB_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 5);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_EC_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 5);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_ED_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 5);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_EE_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_EF_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 5);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F0_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 6);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F1_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 6);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F2_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 6);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F3_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 6);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F4_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 6);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F5_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 6);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F6_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F7_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 6);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F8_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->B | (1 << 7);
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_F9_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->C | (1 << 7);
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_FA_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->D | (1 << 7);
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_FB_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->E | (1 << 7);
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_FC_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->H | (1 << 7);
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_FD_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->L | (1 << 7);
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_FE_SET_o_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 4: { // wait
            break; }
        case 5: { // write begin
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 6: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_CB_FF_SET_o_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = regs->A | (1 << 7);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_00_NOP(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_01_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_02_LD_irr_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->WZ = (regs->B << 8) | regs->C;
            pins->Addr = (regs->WZ);
            break; }
        case 2: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_03_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = (((regs->B << 8) | regs->C ) + 1) & 0xFFFF;
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_04_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->B) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_05_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->B) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_06_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_07_RLCA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = (regs->A & 0x80) >> 7;
            regs->A = ((regs->A << 1) | c) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_08_EX_rr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_shadow_af(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_09_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IX
            regs->Q = 1;
            regs->WZ = (regs->IX + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IX & 0xFF);
            y = regs->C;
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IX & 0xFF00) >> 8);
            y = regs->B;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IX = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_0A_LD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->WZ = (regs->B << 8) | regs->C;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_0B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = (regs->B << 8) | regs->C;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->B = ((regs->TA) & 0xFF00) >> 8;
            regs->C = (regs->TA) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_0C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->C) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_0D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->C) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_0E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_0F_RRCA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = regs->A & 1;
            regs->A = (c << 7) | (regs->A >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_10_DJNZ_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            break; }
        case 2: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->B = (regs->B - 1) & 0xFF;
            if (regs->B == 0) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 5: { // Adding 5 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            break; }
        case 9: {
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_11_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_12_LD_irr_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->WZ = (regs->D << 8) | regs->E;
            pins->Addr = (regs->WZ);
            break; }
        case 2: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_13_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = (((regs->D << 8) | regs->E ) + 1) & 0xFFFF;
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_14_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->D) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_15_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->D) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_16_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_17_RLA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = (regs->A & 0x80) >> 7;
            regs->A = ((regs->A << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_18_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_19_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IX
            regs->Q = 1;
            regs->WZ = (regs->IX + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IX & 0xFF);
            y = regs->E;
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IX & 0xFF00) >> 8);
            y = regs->D;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IX = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_1A_LD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->WZ = (regs->D << 8) | regs->E;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_1B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = (regs->D << 8) | regs->E;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->D = ((regs->TA) & 0xFF00) >> 8;
            regs->E = (regs->TA) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_1C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->E) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_1D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->E) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_1E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_1F_RRA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = regs->A & 1;
            regs->A = (regs->F.C << 7) | (regs->A >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_20_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 0)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_21_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->IX = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_22_LD_inn_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = ((regs->IX & 0xFF));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 10: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 11: {
            pins->D = (((regs->IX & 0xFF00) >> 8));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_23_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = ((regs->IX ) + 1) & 0xFFFF;
            regs->IX = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_24_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = (((regs->IX & 0xFF00) >> 8) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IX = (regs->TR << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_25_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = (((regs->IX & 0xFF00) >> 8) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IX = (regs->TR << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_26_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->IX = ((regs->TR) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_27_DAA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 a = regs->A;
            if (regs->F.C || (regs->A > 0x99)) { regs->A = (regs->A + (regs->F.N ? -0x60: 0x60)) & 0xFF; regs->F.C = 1; }
            if (regs->F.H || ((regs->A & 0x0F) > 0x09)) { regs->A = (regs->A + (regs->F.N ? -6 : 6)) & 0xFF; }
            regs->F.PV = Z80_parity(regs->A);
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.H = ((a ^ regs->A) & 0x10) >> 4;
            regs->F.Z = +(regs->A == 0);
            regs->F.S = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_28_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_29_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IX
            regs->Q = 1;
            regs->WZ = (regs->IX + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IX & 0xFF);
            y = (regs->IX & 0xFF);
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IX & 0xFF00) >> 8);
            y = ((regs->IX & 0xFF00) >> 8);
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IX = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_2A_LD_rr_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TA = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->IX = (regs->IX & 0xFF00) | (regs->TR);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->WZ = regs->TA;
            break; }
        case 10: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 11: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 12: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->IX = (regs->TR << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_2B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = regs->IX;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->IX = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_2C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->IX & 0xFF) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IX = (regs->IX & 0xFF00) | regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_2D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->IX & 0xFF) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IX = (regs->IX & 0xFF00) | regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_2E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->IX = (regs->IX & 0xFF00) | ((regs->TR) & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_2F_CPL(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A ^= 0xFF;
            regs->F.N = regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_30_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 0)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_31_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->SP = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_32_LD_inn_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_33_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = ((regs->SP ) + 1) & 0xFFFF;
            regs->SP = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_34_INC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 12: {
            regs->TR = ((regs->TR) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            break; }
        case 13: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 14: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 15: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 16: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_35_DEC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 12: {
            regs->TR = ((regs->TR) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            break; }
        case 13: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 14: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 15: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 16: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_36_LD_irr_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 2 cycles
            break; }
        case 5: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 6: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 7: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 8: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_37_SCF(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            if (regs->Q) { regs->F.X = 0; regs->F.Y = 0; }
            regs->F.C = regs->Q = 1;
            regs->F.N = regs->F.H = 0;
            regs->F.X |= ((regs->A & 8) >> 3);
            regs->F.Y |= ((regs->A & 0x20) >> 5);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_38_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_39_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IX
            regs->Q = 1;
            regs->WZ = (regs->IX + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IX & 0xFF);
            y = (regs->SP & 0xFF);
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IX & 0xFF00) >> 8);
            y = ((regs->SP & 0xFF00) >> 8);
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IX = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_3A_LD_a_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_3B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = regs->SP;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->SP = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_3C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->A) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_3D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->A) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_3E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_3F_CCF(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            if (regs->Q) { regs->F.X = regs->F.Y = 0; } 
            regs->F.H = regs->F.C;
            regs->F.C = +(!regs->F.C);
            regs->F.N = 0;
            regs->F.X |= (regs->A & 8) >> 3;
            regs->F.Y |= (regs->A & 0x20) >> 5;
            regs->Q = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_40_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_41_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_42_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_43_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_44_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = ((regs->IX & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_45_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_46_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_47_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_48_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_49_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_4A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_4B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_4C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = ((regs->IX & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_4D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_4E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_4F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_50_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_51_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_52_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_53_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_54_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = ((regs->IX & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_55_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_56_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_57_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_58_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_59_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_5A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_5B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_5C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = ((regs->IX & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_5D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_5E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_5F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_60_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = ((regs->B) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_61_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = ((regs->C) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_62_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = ((regs->D) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_63_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = ((regs->E) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_64_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = ((((regs->IX & 0xFF00) >> 8)) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_65_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (((regs->IX & 0xFF)) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_66_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_67_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = ((regs->A) << 8) | (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_68_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (regs->IX & 0xFF00) | ((regs->B) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_69_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (regs->IX & 0xFF00) | ((regs->C) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_6A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (regs->IX & 0xFF00) | ((regs->D) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_6B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (regs->IX & 0xFF00) | ((regs->E) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_6C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (regs->IX & 0xFF00) | ((((regs->IX & 0xFF00) >> 8)) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_6D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (regs->IX & 0xFF00) | (((regs->IX & 0xFF)) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_6E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_6F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IX = (regs->IX & 0xFF00) | ((regs->A) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_70_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->B);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_71_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->C);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_72_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->D);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_73_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->E);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_74_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->H);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_75_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->L);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_76_HALT(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->HALT = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_77_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_78_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_79_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_7A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_7B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_7C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = ((regs->IX & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_7D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = (regs->IX & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_7E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_7F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_80_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->B;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_81_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->C;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_82_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->D;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_83_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->E;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_84_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = ((regs->IX & 0xFF00) >> 8);
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_85_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = (regs->IX & 0xFF);
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_86_ADD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_87_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->A;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_88_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->B;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_89_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->C;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_8A_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->D;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_8B_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->E;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_8C_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = ((regs->IX & 0xFF00) >> 8);
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_8D_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = (regs->IX & 0xFF);
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_8E_ADC_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_8F_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->A;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_90_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->B);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_91_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->C);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_92_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->D);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_93_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->E);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_94_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (((regs->IX & 0xFF00) >> 8));
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_95_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = ((regs->IX & 0xFF));
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_96_SUB_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_97_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_98_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->B);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_99_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->C);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_9A_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->D);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_9B_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->E);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_9C_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (((regs->IX & 0xFF00) >> 8));
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_9D_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = ((regs->IX & 0xFF));
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_9E_SBC_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_9F_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->A);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A0_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->B);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A1_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->C);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A2_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->D);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A3_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->E);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A4_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (((regs->IX & 0xFF00) >> 8));
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A5_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & ((regs->IX & 0xFF));
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A6_AND_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A7_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->A);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A8_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_A9_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_AA_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_AB_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_AC_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (((regs->IX & 0xFF00) >> 8));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_AD_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ ((regs->IX & 0xFF));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_AE_XOR_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_AF_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B0_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B1_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B2_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B3_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B4_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (((regs->IX & 0xFF00) >> 8));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B5_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | ((regs->IX & 0xFF));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B6_OR_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B7_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B8_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->B;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_B9_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->C;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_BA_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->D;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_BB_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->E;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_BC_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)((regs->IX & 0xFF00) >> 8);
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_BD_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)(regs->IX & 0xFF);
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_BE_CP_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IX) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->TR;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_BF_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->A;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.Z == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.Z == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C3_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.Z == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->B);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (regs->C);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C6_ADD_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x00;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.Z == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_C9_RET(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_CA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.Z == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_CC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.Z == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_CD_CALL_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 14: { // cleanup_custom
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_CE_ADC_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_CF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x08;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.C == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.C == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D3_OUT_in_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->A << 8);
            break; }
        case 4: { // OUT start
            pins->Addr = regs->WZ;
            pins->D = regs->A;
            regs->data = pins->D;
            break; }
        case 5: { // OUT continues
            break; }
        case 6: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 7: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->WZ & 0xFF00);
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.C == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->D);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (regs->E);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D6_SUB_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x10;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.C == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_D9_EXX(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_shadow(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_DA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.C == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_DB_IN_a_in(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->A << 8);
            break; }
        case 4: { // IN start
            pins->Addr = regs->WZ;
            break; }
        case 5: { // IN actual read
            break; }
        case 6: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 7: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->A = pins->D;
            regs->data = pins->D;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_DC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.C == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_DE_SBC_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_DF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x18;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.PV == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->IX = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.PV == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E3_EX_irr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = regs->SP;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ |= (regs->TR << 8);
            break; }
        case 7: { // wait
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = ((regs->IX & 0xFF));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 12: {
            pins->D = (((regs->IX & 0xFF00) >> 8));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 14: { // wait
            break; }
        case 15: { // wait
            regs->IX = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 16: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.PV == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->IX & 0xFF00) >> 8));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->IX & 0xFF));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E6_AND_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x20;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.PV == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_E9_JP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->PC = regs->IX;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_EA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.PV == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_EB_EX_rr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_de_hl(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_EC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.PV == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_EE_XOR_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_EF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x28;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.S == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->A = ((regs->TR) & 0xFF00) >> 8;
            Z80_regs_F_setbyte(&regs->F, (regs->TR) & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.S == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F3_DI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IFF1 = regs->IFF2 = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.S == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (Z80_regs_F_getbyte(&regs->F));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F6_OR_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x30;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.S == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_F9_LD_sp_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->SP = regs->IX;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_FA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.S == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_FB_EI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IFF1 = regs->IFF2 = regs->EI = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_FC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.S == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_FE_CP_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->TR;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_FF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x38;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DD_100_IRQ(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IRQ processing idle cycle!
            break; }
        case 2: { // Start IACK read
            regs->R = (regs->R + 1) & 0x7F;
            pins->RD = 0; pins->WR = 0; pins->MRQ = 0; pins->IO = 0;
            break; }
        case 3: { // signal IACK
            pins->RD = 1; pins->IO = 1;
            pins->M1 = 1;
            break; }
        case 4: { // wait 1
            if (pins->WAIT) regs->TCU--;
            break; }
        case 5: { // wait 2
            if (pins->WAIT) regs->TCU--;
            break; }
        case 6: { // Latch value...
            pins->M1 = 0;
            regs->t[0] = pins->D;
            pins->RD = 0; pins->IO = 0;
            regs->t[1] = pins->IRQ_maskable ? regs->IM : 1;
            if (regs->t[1] == 0) {
                printf("\nOH NO PANIC!!!!");
                return;
            }
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 8: {
            pins->D = ((regs->PC >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 10: { // push PC lo begin
            pins->Addr = regs->SP;
            break; }
        case 11: {
            pins->D = regs->PC & 0xFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            if (regs->t[1] == 1) {
                regs->TCU += 6;
            }
            regs->t[2] = (regs->I << 8) | regs->t[0];
            break; }
        case 13: { // Start read
            pins->Addr = (regs->t[2]);
            break; }
        case 14: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 15: { // Read end/latch
            regs->t[3] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->t[2] = (regs->t[2] + 1) & 0xFFFF;
            break; }
        case 16: { // Start read
            pins->Addr = regs->t[2];
            break; }
        case 17: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 18: { // finish read...
            pins->RD = 0; pins->MRQ = 0;
            regs->t[3] |= (pins->D << 8);
            break; }
        case 19: { // cleanup_custom
            pins->WR = 0;
            if (regs->t[1] == 1) { // IM1
                regs->WZ = regs->PC = regs->IRQ_vec;
            }
            else { // IM2
                regs->WZ = regs->PC = regs->t[3];
            }
            regs->IRQ_vec = 0;
            regs->IFF1 = 0;
            if (pins->IRQ_maskable) regs->IFF2 = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            break;
    }}
}

void Z80_ins_DD_101_RESET(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->IFF1 = regs->IFF2 = 0; // disable interrupt
            regs->IM = 0;
            regs->I = 0;
            regs->R = 0;
            regs->PC = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_40_IN_r_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->B = regs->TR;
            regs->TA = (regs->B << 8) | regs->C;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_41_OUT_ic_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = regs->B;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_42_SBC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z, c;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->L);
            y = (regs->C);
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[0] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = (regs->H);
            y = (regs->B);
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[1] = z & 0xFF;
            regs->H = regs->t[1];
            regs->L = regs->t[0];
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_43_LD_inn_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->C);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 10: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 11: {
            pins->D = (regs->B);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_44_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_45_RETN(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_46_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_47_LD_r_r1(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->I = (regs->A);
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_48_IN_r_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->C = regs->TR;
            regs->TA = (regs->B << 8) | regs->C;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_49_OUT_ic_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = regs->C;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_4A_ADC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            x = regs->L;
            y = regs->C;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->L = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = regs->B;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->H = z & 0xFF;
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_4B_LD_rr_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TA = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->C = (regs->TR);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->WZ = regs->TA;
            break; }
        case 10: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 11: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 12: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->B = (regs->TR);
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_4C_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_4D_RETI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_4E_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_4F_LD_r_r1(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->R = (regs->A);
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_50_IN_r_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->D = regs->TR;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_51_OUT_ic_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = regs->D;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_52_SBC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z, c;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->L);
            y = (regs->E);
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[0] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = (regs->H);
            y = (regs->D);
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[1] = z & 0xFF;
            regs->H = regs->t[1];
            regs->L = regs->t[0];
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_53_LD_inn_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->E);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 10: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 11: {
            pins->D = (regs->D);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_54_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_55_RETN(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_56_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_57_LD_r_r2(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            u32 x = regs->I;
            regs->A = regs->I;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.PV = regs->IFF2;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->P = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_58_IN_r_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->E = regs->TR;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_59_OUT_ic_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = regs->E;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_5A_ADC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            x = regs->L;
            y = regs->E;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->L = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = regs->D;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->H = z & 0xFF;
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_5B_LD_rr_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TA = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->E = (regs->TR);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->WZ = regs->TA;
            break; }
        case 10: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 11: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 12: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->D = (regs->TR);
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_5C_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_5D_RETI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_5E_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 2;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_5F_LD_r_r2(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            u32 x = regs->R;
            regs->A = regs->R;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.PV = regs->IFF2;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->P = 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_60_IN_r_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->H = regs->TR;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_61_OUT_ic_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = regs->H;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_62_SBC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z, c;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->L);
            y = (regs->L);
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[0] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = (regs->H);
            y = (regs->H);
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[1] = z & 0xFF;
            regs->H = regs->t[1];
            regs->L = regs->t[0];
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_63_LD_inn_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->L);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 10: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 11: {
            pins->D = (regs->H);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_64_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_65_RETN(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_66_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_67_RRD(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->WZ = (regs->H << 8) | regs->L;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: {
            break; }
        case 5: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 6: {
            pins->D = (((regs->TR >> 4) | (regs->A << 4)) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 8: { // Adding 3 cycles
            break; }
        case 9: {
            break; }
        case 10: {
            regs->A = (regs->A & 0xF0) | (regs->TR & 0x0F);
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(regs->A);
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((regs->A) == 0);
            regs->F.S = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 11: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_68_IN_r_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->L = regs->TR;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_69_OUT_ic_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = regs->L;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_6A_ADC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            x = regs->L;
            y = regs->L;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->L = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = regs->H;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->H = z & 0xFF;
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_6B_LD_rr_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TA = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->L = (regs->TR);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->WZ = regs->TA;
            break; }
        case 10: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 11: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 12: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->H = (regs->TR);
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_6C_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_6D_RETI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_6E_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_6F_RLD(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->WZ = (regs->H << 8) | regs->L;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: {
            break; }
        case 5: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 6: {
            pins->D = (((regs->TR << 4) & 0xF0) | (regs->A & 0x0F));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 8: { // Adding 3 cycles
            break; }
        case 9: {
            break; }
        case 10: {
            regs->A = (regs->A & 0xF0) | (regs->TR >> 4);
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(regs->A);
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.Z = +((regs->A) == 0);
            regs->F.S = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 11: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_70_IN_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_71_OUT_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = 0x00;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_72_SBC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z, c;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->L);
            y = ((regs->SP & 0xFF));
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[0] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = (regs->H);
            y = (((regs->SP & 0xFF00) >> 8));
            c = +(regs->F.C);
            z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[1] = z & 0xFF;
            regs->H = regs->t[1];
            regs->L = regs->t[0];
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_73_LD_inn_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = ((regs->SP & 0xFF));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 10: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 11: {
            pins->D = (((regs->SP & 0xFF00) >> 8));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_74_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_75_RETN(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_76_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_77_NOP(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_78_IN_r_ic(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IN start
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            break; }
        case 2: { // IN actual read
            break; }
        case 3: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 4: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->A = regs->TR;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_79_OUT_ic_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // OUT start
            regs->Q = 0;
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = regs->TA;
            pins->D = regs->A;
            regs->data = pins->D;
            break; }
        case 2: { // OUT continues
            break; }
        case 3: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 4: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_7A_ADC_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            regs->Q = 1;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            regs->WZ = (((regs->H << 8) | regs->L) + 1) & 0xFFFF;
            x = regs->L;
            y = (regs->SP & 0xFF);
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->L = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = regs->H;
            y = ((regs->SP & 0xFF00) >> 8);
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->H = z & 0xFF;
            regs->F.Z = +((regs->H == 0) && (regs->L == 0));
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_7B_LD_rr_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TA = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP & 0xFF00) | (regs->TR);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->WZ = regs->TA;
            break; }
        case 10: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 11: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 12: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->TR << 8) | (regs->SP & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_7C_NEG(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (0);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_7D_RETI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            regs->IFF1 = regs->IFF2;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_7E_IM_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IM = 2;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_7F_NOP(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_A0_LDI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->TA = (regs->D << 8) | regs->E;
            break; }
        case 4: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 5: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 6: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->D = ((regs->TA) & 0xFF00) >> 8;
            regs->E = (regs->TA) & 0xFF;
            break; }
        case 7: { // Adding 2 cycles
            break; }
        case 8: {
            regs->F.N = regs->F.H = 0;
            regs->TA = (regs->A + regs->TR) & 0xFF;
            regs->F.X = (regs->TA & 8) >> 3;
            regs->F.Y = (regs->TA & 2) >> 1;
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->B = ((regs->TA) & 0xFF00) >> 8;
            regs->C = (regs->TA) & 0xFF;
            regs->F.PV = +(regs->TA != 0);
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_A1_CPI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            u32 n = (regs->A - regs->TR) & 0xFF;
            regs->F.N = 1;
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->F.PV = regs->TA != 0;
            regs->F.H = ((regs->A ^ regs->TR ^ n) & 0x10) >> 4;
            regs->B = (regs->TA & 0xFF00) >> 8;
            regs->C = regs->TA & 0xFF;
            regs->TR = (n - regs->F.H) & 0xFF;
            regs->F.X = (regs->TR & 8) >> 3;
            regs->F.Y = (regs->TR & 2) >> 1;
            regs->F.Z = +(n == 0);
            regs->F.S = ((n) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_A2_INI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            break; }
        case 2: { // IN start
            pins->Addr = regs->TA;
            break; }
        case 3: { // IN actual read
            break; }
        case 4: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 5: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 6: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 7: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 8: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            regs->F.C = ((regs->C + 1 + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TA = ((regs->C + 1) & 0xFF) + regs->TR & 7 ^ regs->B;
            regs->F.PV = Z80_parity(regs->TA);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_A3_OUTI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 2: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->B << 8) | regs->C;
            break; }
        case 5: { // OUT start
            pins->Addr = regs->TA;
            pins->D = regs->TR;
            regs->data = pins->D;
            break; }
        case 6: { // OUT continues
            break; }
        case 7: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 8: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            regs->F.C = ((regs->L + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->L + regs->TR & 7 ^ regs->B) & 0xFF;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_A8_LDD(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            regs->TA = (regs->D << 8) | regs->E;
            break; }
        case 4: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 5: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 6: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->D = (regs->TA & 0xFF00) >> 8;
            regs->E = regs->TA & 0xFF;
            break; }
        case 7: { // Adding 2 cycles
            break; }
        case 8: {
            regs->F.N = regs->F.H = 0;
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->B = ((regs->TA) & 0xFF00) >> 8;
            regs->C = (regs->TA) & 0xFF;
            regs->F.PV = +(regs->TA != 0);
            regs->TA = (regs->A + regs->TR) & 0xFF;
            regs->F.X = (regs->TA & 8) >> 3;
            regs->F.Y = (regs->TA & 2) >> 1;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_A9_CPD(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->WZ = (regs->WZ - 1) & 0xFFFF;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->B = (regs->TA & 0xFF00) >> 8;
            regs->C = regs->TA & 0xFF;
            u32 n = regs->A - regs->TR;
            regs->F.N = 1;
            regs->F.PV = +(regs->TA != 0);
            regs->F.H = ((regs->A ^ regs->TR ^ n) & 0x10) >> 4;
            regs->F.X = ((n - regs->F.H) & 8) >> 3;
            regs->F.Y = ((n - regs->F.H) & 2) >> 1;
            regs->F.Z = +(n == 0);
            regs->F.S = ((n) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_AA_IND(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->WZ = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->TA = (regs->B << 8) | regs->C;
            break; }
        case 2: { // IN start
            pins->Addr = regs->TA;
            break; }
        case 3: { // IN actual read
            break; }
        case 4: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 5: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 6: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 7: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 8: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->F.C = ((((regs->C - 1) & 0xFF) + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TA = ((regs->C - 1) & 0xFF) + regs->TR & 7 ^ regs->B;
            regs->F.PV = Z80_parity(regs->TA);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_AB_OUTD(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 2: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->B << 8) | regs->C;
            break; }
        case 5: { // OUT start
            pins->Addr = regs->TA;
            pins->D = regs->TR;
            regs->data = pins->D;
            break; }
        case 6: { // OUT continues
            break; }
        case 7: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 8: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA - 1) & 0xFFFF;
            regs->F.C = ((regs->L + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->L + regs->TR & 7 ^ regs->B) & 0xFF;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_B0_LDIR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->TA = (regs->D << 8) | regs->E;
            break; }
        case 4: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 5: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 6: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->D = ((regs->TA) & 0xFF00) >> 8;
            regs->E = (regs->TA) & 0xFF;
            break; }
        case 7: { // Adding 2 cycles
            break; }
        case 8: {
            regs->F.N = regs->F.H = 0;
            regs->TA = (regs->A + regs->TR) & 0xFF;
            regs->F.X = (regs->TA & 8) >> 3;
            regs->F.Y = (regs->TA & 2) >> 1;
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->B = ((regs->TA) & 0xFF00) >> 8;
            regs->C = (regs->TA) & 0xFF;
            regs->F.PV = +(regs->TA != 0);
            if ((regs->B == 0) && (regs->C == 0)) { regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->WZ = (regs->PC + 1) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_B1_CPIR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            u32 n = (regs->A - regs->TR) & 0xFF;
            regs->F.N = 1;
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->F.PV = regs->TA != 0;
            regs->F.H = ((regs->A ^ regs->TR ^ n) & 0x10) >> 4;
            regs->B = (regs->TA & 0xFF00) >> 8;
            regs->C = regs->TA & 0xFF;
            regs->TR = (n - regs->F.H) & 0xFF;
            regs->F.X = (regs->TR & 8) >> 3;
            regs->F.Y = (regs->TR & 2) >> 1;
            regs->F.Z = +(n == 0);
            regs->F.S = ((n) & 0x80) >> 7;
            if (((regs->B == 0) && (regs->C == 0)) || (regs->F.Z)) {regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->WZ = (regs->PC + 1) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_B2_INIR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->TA = (regs->B << 8) | regs->C;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            break; }
        case 2: { // IN start
            pins->Addr = regs->TA;
            break; }
        case 3: { // IN actual read
            break; }
        case 4: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 5: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 6: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 7: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 8: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            regs->F.C = ((regs->C + 1 + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TA = ((regs->C + 1) & 0xFF) + regs->TR & 7 ^ regs->B;
            regs->F.PV = Z80_parity(regs->TA);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            if (regs->B == 0) { regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            if (regs->F.C) {
                if (regs->data & 0x80) {
                    regs->F.PV ^= Z80_parity((regs->B - 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0);
                }
                else {
                    regs->F.PV ^= Z80_parity((regs->B + 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0x0F);
                }
            }
            else {
                regs->F.PV ^= Z80_parity(regs->B & 7) ^ 1;
            }
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_B3_OTIR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 2: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->B << 8) | regs->C;
            break; }
        case 5: { // OUT start
            pins->Addr = regs->TA;
            pins->D = regs->TR;
            regs->data = pins->D;
            break; }
        case 6: { // OUT continues
            break; }
        case 7: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 8: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA + 1) & 0xFFFF;
            regs->F.C = ((regs->L + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->L + regs->TR & 7 ^ regs->B) & 0xFF;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            if (regs->B == 0) { regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            if (regs->F.C) {
                if (regs->data & 0x80) {
                    regs->F.PV ^= Z80_parity((regs->B - 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0);
                }
                else {
                    regs->F.PV ^= Z80_parity((regs->B + 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0x0F);
                }
            }
            else {
                regs->F.PV ^= Z80_parity(regs->B & 7) ^ 1;
            }
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_B8_LDDR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            regs->TA = (regs->D << 8) | regs->E;
            break; }
        case 4: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 5: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 6: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->D = (regs->TA & 0xFF00) >> 8;
            regs->E = regs->TA & 0xFF;
            break; }
        case 7: { // Adding 2 cycles
            break; }
        case 8: {
            regs->F.N = regs->F.H = 0;
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->B = ((regs->TA) & 0xFF00) >> 8;
            regs->C = (regs->TA) & 0xFF;
            regs->F.PV = +(regs->TA != 0);
            regs->TA = (regs->A + regs->TR) & 0xFF;
            regs->F.X = (regs->TA & 8) >> 3;
            regs->F.Y = (regs->TA & 2) >> 1;
            if ((regs->B == 0) && (regs->C == 0)) { regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->WZ = (regs->PC + 1) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_B9_CPDR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            regs->WZ = (regs->WZ - 1) & 0xFFFF;
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->TA = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->B = (regs->TA & 0xFF00) >> 8;
            regs->C = regs->TA & 0xFF;
            u32 n = regs->A - regs->TR;
            regs->F.N = 1;
            regs->F.PV = +(regs->TA != 0);
            regs->F.H = ((regs->A ^ regs->TR ^ n) & 0x10) >> 4;
            regs->F.X = ((n - regs->F.H) & 8) >> 3;
            regs->F.Y = ((n - regs->F.H) & 2) >> 1;
            regs->F.Z = +(n == 0);
            regs->F.S = ((n) & 0x80) >> 7;
            if (((regs->B == 0) && (regs->C == 0)) || (regs->F.Z)) {regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->WZ = (regs->PC + 1) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_BA_INDR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->WZ = (((regs->B << 8) | regs->C) - 1) & 0xFFFF;
            regs->TA = (regs->B << 8) | regs->C;
            break; }
        case 2: { // IN start
            pins->Addr = regs->TA;
            break; }
        case 3: { // IN actual read
            break; }
        case 4: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 5: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->TR = pins->D;
            regs->data = pins->D;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 6: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 7: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 8: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->F.C = ((((regs->C - 1) & 0xFF) + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TA = ((regs->C - 1) & 0xFF) + regs->TR & 7 ^ regs->B;
            regs->F.PV = Z80_parity(regs->TA);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            if (regs->B == 0) { regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            if (regs->F.C) {
                if (regs->data & 0x80) {
                    regs->F.PV ^= Z80_parity((regs->B - 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0);
                }
                else {
                    regs->F.PV ^= Z80_parity((regs->B + 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0x0F);
                }
            }
            else {
                regs->F.PV ^= Z80_parity(regs->B & 7) ^ 1;
            }
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_ED_BB_OTDR(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 1;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 2: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = ((regs->TA) & 0xFF00) >> 8;
            regs->L = (regs->TA) & 0xFF;
            regs->B = (regs->B - 1) & 0xFF;
            regs->TA = (regs->B << 8) | regs->C;
            break; }
        case 5: { // OUT start
            pins->Addr = regs->TA;
            pins->D = regs->TR;
            regs->data = pins->D;
            break; }
        case 6: { // OUT continues
            break; }
        case 7: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 8: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = (regs->TA - 1) & 0xFFFF;
            regs->F.C = ((regs->L + regs->TR) & 0x100) >> 8;
            regs->F.N = (regs->TR & 0x80) >> 7;
            regs->TR = (regs->L + regs->TR & 7 ^ regs->B) & 0xFF;
            regs->F.PV = Z80_parity(regs->TR);
            regs->F.X = ((regs->B) & 8) >> 3;
            regs->F.Y = ((regs->B) & 0x20) >> 5;
            regs->F.H = regs->F.C;
            regs->F.Z = +((regs->B) == 0);
            regs->F.S = ((regs->B) & 0x80) >> 7;
            if (regs->B == 0) { regs->TCU += 5; break; }
            break; }
        case 9: {
            regs->PC = (regs->PC - 2) & 0xFFFF;
            regs->F.X = (regs->PC >> 11) & 1;
            regs->F.Y = (regs->PC >> 13) & 1;
            if (regs->F.C) {
                if (regs->data & 0x80) {
                    regs->F.PV ^= Z80_parity((regs->B - 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0);
                }
                else {
                    regs->F.PV ^= Z80_parity((regs->B + 1) & 7) ^ 1;
                    regs->F.H = +((regs->B & 0x0F) == 0x0F);
                }
            }
            else {
                regs->F.PV ^= Z80_parity(regs->B & 7) ^ 1;
            }
            break; }
        case 10: { // Adding 4 cycles
            break; }
        case 11: {
            break; }
        case 12: {
            break; }
        case 13: {
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_00_NOP(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_01_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_02_LD_irr_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->WZ = (regs->B << 8) | regs->C;
            pins->Addr = (regs->WZ);
            break; }
        case 2: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_03_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = (((regs->B << 8) | regs->C ) + 1) & 0xFFFF;
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_04_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->B) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_05_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->B) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_06_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_07_RLCA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = (regs->A & 0x80) >> 7;
            regs->A = ((regs->A << 1) | c) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_08_EX_rr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_shadow_af(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_09_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IY
            regs->Q = 1;
            regs->WZ = (regs->IY + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IY & 0xFF);
            y = regs->C;
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IY & 0xFF00) >> 8);
            y = regs->B;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IY = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_0A_LD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->WZ = (regs->B << 8) | regs->C;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_0B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = (regs->B << 8) | regs->C;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->B = ((regs->TA) & 0xFF00) >> 8;
            regs->C = (regs->TA) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_0C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->C) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_0D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->C) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_0E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_0F_RRCA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = regs->A & 1;
            regs->A = (c << 7) | (regs->A >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_10_DJNZ_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            break; }
        case 2: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->B = (regs->B - 1) & 0xFF;
            if (regs->B == 0) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 5: { // Adding 5 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            break; }
        case 9: {
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_11_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_12_LD_irr_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // write begin
            regs->Q = 0;
            regs->WZ = (regs->D << 8) | regs->E;
            pins->Addr = (regs->WZ);
            break; }
        case 2: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_13_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = (((regs->D << 8) | regs->E ) + 1) & 0xFFFF;
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_14_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->D) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_15_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->D) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_16_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_17_RLA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = (regs->A & 0x80) >> 7;
            regs->A = ((regs->A << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_18_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_19_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IY
            regs->Q = 1;
            regs->WZ = (regs->IY + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IY & 0xFF);
            y = regs->E;
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IY & 0xFF00) >> 8);
            y = regs->D;
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IY = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_1A_LD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->WZ = (regs->D << 8) | regs->E;
            pins->Addr = (regs->WZ);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_1B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = (regs->D << 8) | regs->E;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->D = ((regs->TA) & 0xFF00) >> 8;
            regs->E = (regs->TA) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_1C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->E) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_1D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->E) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_1E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_1F_RRA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 c = regs->A & 1;
            regs->A = (regs->F.C << 7) | (regs->A >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_20_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 0)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_21_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->IY = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_22_LD_inn_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = ((regs->IY & 0xFF));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            break; }
        case 10: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 11: {
            pins->D = (((regs->IY & 0xFF00) >> 8));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_23_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = ((regs->IY ) + 1) & 0xFFFF;
            regs->IY = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_24_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = (((regs->IY & 0xFF00) >> 8) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IY = (regs->TR << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_25_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = (((regs->IY & 0xFF00) >> 8) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IY = (regs->TR << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_26_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->IY = ((regs->TR) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_27_DAA(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 a = regs->A;
            if (regs->F.C || (regs->A > 0x99)) { regs->A = (regs->A + (regs->F.N ? -0x60: 0x60)) & 0xFF; regs->F.C = 1; }
            if (regs->F.H || ((regs->A & 0x0F) > 0x09)) { regs->A = (regs->A + (regs->F.N ? -6 : 6)) & 0xFF; }
            regs->F.PV = Z80_parity(regs->A);
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            regs->F.H = ((a ^ regs->A) & 0x10) >> 4;
            regs->F.Z = +(regs->A == 0);
            regs->F.S = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_28_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_29_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IY
            regs->Q = 1;
            regs->WZ = (regs->IY + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IY & 0xFF);
            y = (regs->IY & 0xFF);
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IY & 0xFF00) >> 8);
            y = ((regs->IY & 0xFF00) >> 8);
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IY = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_2A_LD_rr_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TA = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->IY = (regs->IY & 0xFF00) | (regs->TR);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->WZ = regs->TA;
            break; }
        case 10: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 11: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 12: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->IY = (regs->TR << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 13: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_2B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = regs->IY;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->IY = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_2C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->IY & 0xFF) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IY = (regs->IY & 0xFF00) | regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_2D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->IY & 0xFF) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->IY = (regs->IY & 0xFF00) | regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_2E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->IY = (regs->IY & 0xFF00) | ((regs->TR) & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_2F_CPL(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->A ^= 0xFF;
            regs->F.N = regs->F.H = 1;
            regs->F.X = ((regs->A) & 8) >> 3;
            regs->F.Y = ((regs->A) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_30_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 0)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_31_LD_rr_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR |= (regs->t[4] << 8);
            regs->SP = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_32_LD_inn_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->A << 8);
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_33_INC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TR = ((regs->SP ) + 1) & 0xFFFF;
            regs->SP = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_34_INC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 12: {
            regs->TR = ((regs->TR) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            break; }
        case 13: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 14: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 15: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 16: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_35_DEC_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 12: {
            regs->TR = ((regs->TR) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            break; }
        case 13: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 14: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 15: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 16: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_36_LD_irr_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 2 cycles
            break; }
        case 5: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 6: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 7: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 8: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_37_SCF(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            if (regs->Q) { regs->F.X = 0; regs->F.Y = 0; }
            regs->F.C = regs->Q = 1;
            regs->F.N = regs->F.H = 0;
            regs->F.X |= ((regs->A & 8) >> 3);
            regs->F.Y |= ((regs->A & 0x20) >> 5);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_38_JR_c_e(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 1)) { regs->TCU += 5; break; }
            regs->WZ = ((u32)(((i32)regs->PC) + ((i32)(i8)regs->TR))) & 0xFFFF;
            regs->PC = regs->WZ;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            // Following is auto-generated code for instruction finish
            break; }
        case 9: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_39_ADD_hl_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    u32 x, y, z;
    switch(regs->TCU) {
        case 1: { // Adding 4 cycles
            // SUB was IY
            regs->Q = 1;
            regs->WZ = (regs->IY + 1) & 0xFFFF;
            regs->t[0] = regs->F.PV; regs->t[1] = regs->F.Z; regs->t[2] = regs->F.S;
            break; }
        case 2: {
            break; }
        case 3: {
            break; }
        case 4: {
            x = (regs->IY & 0xFF);
            y = (regs->SP & 0xFF);
            z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[4] = z & 0xFF;
            break; }
        case 5: { // Adding 3 cycles
            break; }
        case 6: {
            break; }
        case 7: {
            x = ((regs->IY & 0xFF00) >> 8);
            y = ((regs->SP & 0xFF00) >> 8);
            z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->t[5] = z & 0xFF;
            regs->F.PV = regs->t[0]; regs->F.Z = regs->t[1]; regs->F.S = regs->t[2];
            regs->IY = (regs->t[5] << 8) | regs->t[4];
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_3A_LD_a_inn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 8: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 9: { // Read end/latch
            regs->A = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_3B_DEC_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->TA = regs->SP;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->SP = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_3C_INC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->A) + 1) & 0xFF;
            regs->F.N = 0;
            regs->F.PV = +(regs->TR == 0x80);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0);
            regs->F.Z = +(regs->TR == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_3D_DEC_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            regs->TR = ((regs->A) - 1) & 0xFF;
            regs->F.N = 1;
            regs->F.PV = +(regs->TR == 0x7F);
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.H = +((regs->TR & 0x0F) == 0x0F);
            regs->F.Z = +((regs->TR) == 0);
            regs->F.S = ((regs->TR) & 0x80) >> 7;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_3E_LD_r_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_3F_CCF(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            if (regs->Q) { regs->F.X = regs->F.Y = 0; } 
            regs->F.H = regs->F.C;
            regs->F.C = +(!regs->F.C);
            regs->F.N = 0;
            regs->F.X |= (regs->A & 8) >> 3;
            regs->F.Y |= (regs->A & 0x20) >> 5;
            regs->Q = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_40_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_41_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_42_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_43_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_44_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = ((regs->IY & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_45_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_46_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_47_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->B = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_48_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_49_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_4A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_4B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_4C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = ((regs->IY & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_4D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_4E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_4F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->C = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_50_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_51_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_52_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_53_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_54_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = ((regs->IY & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_55_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_56_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_57_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_58_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_59_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_5A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_5B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_5C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = ((regs->IY & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_5D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_5E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_5F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->E = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_60_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = ((regs->B) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_61_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = ((regs->C) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_62_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = ((regs->D) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_63_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = ((regs->E) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_64_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = ((((regs->IY & 0xFF00) >> 8)) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_65_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (((regs->IY & 0xFF)) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_66_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_67_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = ((regs->A) << 8) | (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_68_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (regs->IY & 0xFF00) | ((regs->B) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_69_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (regs->IY & 0xFF00) | ((regs->C) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_6A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (regs->IY & 0xFF00) | ((regs->D) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_6B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (regs->IY & 0xFF00) | ((regs->E) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_6C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (regs->IY & 0xFF00) | ((((regs->IY & 0xFF00) >> 8)) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_6D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (regs->IY & 0xFF00) | (((regs->IY & 0xFF)) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_6E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_6F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IY = (regs->IY & 0xFF00) | ((regs->A) & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_70_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->B);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_71_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->C);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_72_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->D);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_73_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->E);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_74_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->H);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_75_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->L);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_76_HALT(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->HALT = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_77_LD_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 10: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 11: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_78_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_79_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_7A_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_7B_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_7C_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = ((regs->IY & 0xFF00) >> 8);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_7D_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = (regs->IY & 0xFF);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_7E_LD_r_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_7F_LD_r_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_80_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->B;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_81_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->C;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_82_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->D;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_83_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->E;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_84_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = ((regs->IY & 0xFF00) >> 8);
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_85_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = (regs->IY & 0xFF);
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_86_ADD_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_87_ADD_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->A;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_88_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->B;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_89_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->C;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_8A_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->D;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_8B_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->E;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_8C_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = ((regs->IY & 0xFF00) >> 8);
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_8D_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = (regs->IY & 0xFF);
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_8E_ADC_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_8F_ADC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = regs->A;
            u32 y = regs->A;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_90_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->B);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_91_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->C);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_92_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->D);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_93_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->E);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_94_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (((regs->IY & 0xFF00) >> 8));
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_95_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = ((regs->IY & 0xFF));
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_96_SUB_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_97_SUB_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->A);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_98_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->B);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_99_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->C);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_9A_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->D);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_9B_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->E);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_9C_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (((regs->IY & 0xFF00) >> 8));
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_9D_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = ((regs->IY & 0xFF));
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_9E_SBC_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_9F_SBC_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 x = (regs->A);
            u32 y = (regs->A);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A0_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->B);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A1_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->C);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A2_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->D);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A3_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->E);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A4_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (((regs->IY & 0xFF00) >> 8));
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A5_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & ((regs->IY & 0xFF));
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A6_AND_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A7_AND_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) & (regs->A);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A8_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_A9_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_AA_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_AB_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_AC_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (((regs->IY & 0xFF00) >> 8));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_AD_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ ((regs->IY & 0xFF));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_AE_XOR_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_AF_XOR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) ^ (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B0_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B1_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B2_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B3_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B4_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (((regs->IY & 0xFF00) >> 8));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B5_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | ((regs->IY & 0xFF));
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B6_OR_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B7_OR_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            u32 z = (regs->A) | (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B8_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->B;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_B9_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->C;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_BA_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->D;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_BB_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->E;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_BC_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)((regs->IY & 0xFF00) >> 8);
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_BD_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)(regs->IY & 0xFF);
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_BE_CP_a_irr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Adding 5 cycles
            break; }
        case 5: {
            break; }
        case 6: {
            break; }
        case 7: {
            break; }
        case 8: {
            regs->WZ = (((i32)regs->IY) + ((i32)(i8)regs->TR)) & 0xFFFF;
            regs->TA = regs->WZ;
            break; }
        case 9: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 10: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 11: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->TR;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 12: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_BF_CP_a_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 1;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->A;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.Z == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->B = ((regs->TR) & 0xFF00) >> 8;
            regs->C = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.Z == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C3_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.Z == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->B);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (regs->C);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C6_ADD_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + 0;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x00;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.Z == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_C9_RET(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_CA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.Z == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_CC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.Z == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_CD_CALL_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 14: { // cleanup_custom
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_CE_ADC_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = regs->A;
            u32 y = regs->TR;
            u32 z = x + y + regs->F.C;
            regs->F.C = +(z > 0xFF);
            regs->F.N = 0;
            regs->F.PV = ((((x ^ y) ^ 0xFF) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_CF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x08;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.C == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->D = ((regs->TR) & 0xFF00) >> 8;
            regs->E = (regs->TR) & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.C == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D3_OUT_in_a(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->A << 8);
            break; }
        case 4: { // OUT start
            pins->Addr = regs->WZ;
            pins->D = regs->A;
            regs->data = pins->D;
            break; }
        case 5: { // OUT continues
            break; }
        case 6: { // WAIT STATE
            pins->WR = 1; pins->IO = 1;
            break; }
        case 7: { // OUT end
            pins->WR = 0; pins->IO = 0;
            regs->WZ = ((regs->WZ + 1) & 0xFF) | (regs->WZ & 0xFF00);
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.C == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->D);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (regs->E);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D6_SUB_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(0);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x10;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.C == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_D9_EXX(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_shadow(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_DA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.C == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_DB_IN_a_in(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->A << 8);
            break; }
        case 4: { // IN start
            pins->Addr = regs->WZ;
            break; }
        case 5: { // IN actual read
            break; }
        case 6: { // IN wait state
            pins->RD = 1; pins->IO = 1;
            break; }
        case 7: { // IN end/latch
            pins->RD = 0; pins->IO = 0;
            regs->A = pins->D;
            regs->data = pins->D;
            regs->WZ = (regs->WZ + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_DC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.C == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_DE_SBC_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 x = (regs->A);
            u32 y = (regs->TR);
            u32 c = +(regs->F.C);
            u32 z = (x - y - c) & 0x1FF;
            regs->F.C = (z & 0x100) >> 8;
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z & 0xFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_DF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x18;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.PV == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->IY = regs->TR;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.PV == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E3_EX_irr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            regs->TA = regs->SP;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->TA);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->WZ |= (regs->TR << 8);
            break; }
        case 7: { // wait
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = ((regs->IY & 0xFF));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->TA);
            break; }
        case 12: {
            pins->D = (((regs->IY & 0xFF00) >> 8));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 14: { // wait
            break; }
        case 15: { // wait
            regs->IY = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 16: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.PV == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->IY & 0xFF00) >> 8));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->IY & 0xFF));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E6_AND_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.X = ((z) & 8) >> 3;
            regs->F.H = 1;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x20;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.PV == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_E9_JP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->PC = regs->IY;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_EA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.PV == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_EB_EX_rr_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            Z80_regs_exchange_de_hl(regs);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_EC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.PV == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_EE_XOR_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_EF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x28;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F0_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.S == 0)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F1_POP_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->SP);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->A = ((regs->TR) & 0xFF00) >> 8;
            Z80_regs_F_setbyte(&regs->F, (regs->TR) & 0xFF);
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F2_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.S == 0) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F3_DI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IFF1 = regs->IFF2 = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F4_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.S == 0);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F5_PUSH_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (regs->A);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = (Z80_regs_F_getbyte(&regs->F));
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F6_OR_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            u32 z = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.X = ((z) & 8) >> 3;
            regs->F.Y = ((z) & 0x20) >> 5;
            regs->F.PV = Z80_parity(z);
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            regs->A = z;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F7_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x30;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F8_RET_c(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // 0
            regs->Q = 0;
            if (!(regs->F.S == 1)) { regs->TCU += 6; break; }
            break; }
        case 2: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 3: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 4: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 5: { // Start read
            pins->Addr = (regs->SP);
            break; }
        case 6: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 7: { // Read end/latch
            regs->t[0] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->SP = (regs->SP + 1) & 0xFFFF;
            regs->TR |= regs->t[0] << 8;
            regs->WZ = (regs->TR);
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_F9_LD_sp_rr(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Adding 2 cycles
            regs->Q = 0;
            break; }
        case 2: {
            regs->SP = regs->IY;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_FA_JP_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            if (regs->F.S == 1) regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_FB_EI(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->Q = 0;
            regs->IFF1 = regs->IFF2 = regs->EI = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_FC_CALL_c_nn(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 0;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->WZ = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 4: { // Start read
            pins->Addr = (regs->PC);
            break; }
        case 5: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 6: { // Read end/latch
            regs->t[4] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->WZ |= (regs->t[4] << 8);
            regs->TA = regs->WZ;
            regs->TR = +(regs->F.S == 1);
            if (!regs->TR) { regs->TA = regs->PC; regs->TCU+=7; break; }
            break; }
        case 7: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 8: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 9: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 10: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 11: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 12: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 13: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 14: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_FE_CP_a_n(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // Start read
            regs->Q = 1;
            pins->Addr = (regs->PC);
            break; }
        case 2: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            i32 x = (i32)regs->A;
            i32 y = (i32)regs->TR;
            i32 z = x - y;
            regs->F.C = +(z < 0);
            regs->F.N = 1;
            regs->F.PV = (((x ^ y) & (x ^ z)) & 0x80) >> 7;
            regs->F.X = ((y) & 8) >> 3;
            regs->F.Y = ((y) & 0x20) >> 5;
            regs->F.H = ((x ^ y ^ z) & 0x10) >> 4;
            regs->F.Z = +((z & 0xFF) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_FF_RST_o(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->Q = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 2: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 3: {
            pins->D = (((regs->PC) >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 5: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 6: {
            pins->D = ((regs->PC) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 7: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->WZ = 0x38;
            regs->PC = regs->WZ;
            // Following is auto-generated code for instruction finish
            break; }
        case 8: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FD_100_IRQ(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // IRQ processing idle cycle!
            break; }
        case 2: { // Start IACK read
            regs->R = (regs->R + 1) & 0x7F;
            pins->RD = 0; pins->WR = 0; pins->MRQ = 0; pins->IO = 0;
            break; }
        case 3: { // signal IACK
            pins->RD = 1; pins->IO = 1;
            pins->M1 = 1;
            break; }
        case 4: { // wait 1
            if (pins->WAIT) regs->TCU--;
            break; }
        case 5: { // wait 2
            if (pins->WAIT) regs->TCU--;
            break; }
        case 6: { // Latch value...
            pins->M1 = 0;
            regs->t[0] = pins->D;
            pins->RD = 0; pins->IO = 0;
            regs->t[1] = pins->IRQ_maskable ? regs->IM : 1;
            if (regs->t[1] == 0) {
                printf("\nOH NO PANIC!!!!");
                return;
            }
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->SP);
            break; }
        case 8: {
            pins->D = ((regs->PC >> 8) & 0xFF);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 10: { // push PC lo begin
            pins->Addr = regs->SP;
            break; }
        case 11: {
            pins->D = regs->PC & 0xFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 12: { // write end
            pins->WR = 0; pins->MRQ = 0;
            if (regs->t[1] == 1) {
                regs->TCU += 6;
            }
            regs->t[2] = (regs->I << 8) | regs->t[0];
            break; }
        case 13: { // Start read
            pins->Addr = (regs->t[2]);
            break; }
        case 14: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 15: { // Read end/latch
            regs->t[3] = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->t[2] = (regs->t[2] + 1) & 0xFFFF;
            break; }
        case 16: { // Start read
            pins->Addr = regs->t[2];
            break; }
        case 17: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 18: { // finish read...
            pins->RD = 0; pins->MRQ = 0;
            regs->t[3] |= (pins->D << 8);
            break; }
        case 19: { // cleanup_custom
            pins->WR = 0;
            if (regs->t[1] == 1) { // IM1
                regs->WZ = regs->PC = regs->IRQ_vec;
            }
            else { // IM2
                regs->WZ = regs->PC = regs->t[3];
            }
            regs->IRQ_vec = 0;
            regs->IFF1 = 0;
            if (pins->IRQ_maskable) regs->IFF2 = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            break;
    }}
}

void Z80_ins_FD_101_RESET(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->IFF1 = regs->IFF2 = 0; // disable interrupt
            regs->IM = 0;
            regs->I = 0;
            regs->R = 0;
            regs->PC = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_00_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_01_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_02_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_03_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_04_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_05_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_06_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_07_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_08_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_09_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_0A_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_0B_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_0C_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_0D_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_0E_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_0F_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_10_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_11_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_12_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_13_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_14_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_15_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_16_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_17_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_18_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_19_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_1A_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_1B_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_1C_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_1D_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_1E_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_1F_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_20_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_21_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_22_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_23_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_24_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_25_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_26_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_27_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_28_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_29_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_2A_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_2B_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_2C_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_2D_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_2E_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_2F_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_30_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_31_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_32_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_33_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_34_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_35_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_36_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_37_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_38_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_39_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_3A_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_3B_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_3C_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_3D_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_3E_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_3F_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_40_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_41_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_42_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_43_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_44_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_45_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_46_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_47_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_48_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_49_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_4A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_4B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_4C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_4D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_4E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_4F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_50_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_51_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_52_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_53_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_54_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_55_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_56_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_57_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_58_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_59_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_5A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_5B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_5C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_5D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_5E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_5F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_60_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_61_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_62_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_63_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_64_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_65_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_66_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_67_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_68_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_69_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_6A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_6B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_6C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_6D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_6E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_6F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_70_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_71_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_72_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_73_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_74_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_75_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_76_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_77_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_78_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_79_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_7A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_7B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_7C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_7D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_7E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_7F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_80_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_81_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_82_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_83_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_84_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_85_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_86_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_87_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_88_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_89_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_8A_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_8B_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_8C_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_8D_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_8E_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_8F_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_90_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_91_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_92_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_93_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_94_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_95_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_96_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_97_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_98_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_99_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_9A_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_9B_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_9C_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_9D_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_9E_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_9F_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A0_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A1_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A2_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A3_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A4_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A5_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A6_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A7_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A8_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_A9_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_AA_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_AB_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_AC_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_AD_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_AE_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_AF_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B0_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B1_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B2_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B3_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B4_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B5_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B6_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B7_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B8_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_B9_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_BA_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_BB_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_BC_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_BD_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_BE_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_BF_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_C9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_CA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_CB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_CC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_CD_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_CE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_CF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_D9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_DA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_DB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_DC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_DD_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_DE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_DF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_E9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_EA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_EB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_EC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_ED_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_EE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_EF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_F9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_FA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_FB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_FC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_FD_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_FE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_DDCB_FF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_00_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_01_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_02_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_03_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_04_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_05_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_06_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_07_RLC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x << 1) | (x >> 7)) & 0xFF;
            regs->F.C = x & 1;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_08_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_09_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_0A_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_0B_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_0C_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_0D_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_0E_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_0F_RRC_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            x = ((x >> 1) | (x << 7)) & 0xFF;
            regs->F.C = (x & 0x80) >> 7;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_10_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_11_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_12_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_13_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_14_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_15_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_16_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_17_RL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | regs->F.C) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_18_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_19_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_1A_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_1B_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_1C_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_1D_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_1E_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_1F_RR_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) | (regs->F.C << 7);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_20_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_21_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_22_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_23_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_24_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_25_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_26_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_27_SLA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = (x << 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_28_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_29_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_2A_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_2B_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_2C_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_2D_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_2E_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_2F_SRA_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x & 0x80) | (x >> 1);
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_30_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_31_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_32_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_33_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_34_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_35_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_36_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_37_SLL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = (x & 0x80) >> 7;
            x = ((x << 1) | 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_38_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->B = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_39_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->C = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_3A_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->D = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_3B_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->E = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_3C_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->H = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_3D_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->L = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_3E_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            // JUNKVAR set here to regs->TR
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_3F_SRL_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 x = regs->TR;
            u32 c = x & 1;
            x = (x >> 1) & 0xFF;
            regs->F.C = c;
            regs->F.N = regs->F.H = 0;
            regs->F.PV = Z80_parity(x);
            regs->F.X = ((x) & 8) >> 3;
            regs->F.Y = ((x) & 0x20) >> 5;
            regs->F.Z = +((x) == 0);
            regs->F.S = ((x) & 0x80) >> 7;
            regs->TR = x;
            regs->A = regs->TR;
            break; }
        case 6: { // wait
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_40_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_41_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_42_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_43_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_44_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_45_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_46_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_47_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 0);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_48_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_49_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_4A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_4B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_4C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_4D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_4E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_4F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 1);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_50_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_51_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_52_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_53_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_54_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_55_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_56_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_57_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 2);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_58_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_59_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_5A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_5B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_5C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_5D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_5E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_5F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 3);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_60_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_61_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_62_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_63_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_64_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_65_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_66_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_67_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 4);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_68_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_69_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_6A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_6B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_6C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_6D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_6E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_6F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 5);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_70_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_71_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_72_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_73_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_74_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_75_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_76_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_77_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 6);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_78_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_79_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_7A_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_7B_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_7C_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_7D_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_7E_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_7F_BIT_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            u32 z = (regs->TR) & (1 << 7);
            regs->F.N = 0;
            regs->F.PV = Z80_parity(z);
            regs->F.H = 1;
            regs->F.X = ((regs->TR) & 8) >> 3;
            regs->F.Y = ((regs->TR) & 0x20) >> 5;
            regs->F.Z = +((z) == 0);
            regs->F.S = ((z) & 0x80) >> 7;
            break; }
        case 6: { // wait
            regs->F.X = (((regs->WZ >> 8)) & 8) >> 3;
            regs->F.Y = (((regs->WZ >> 8)) & 0x20) >> 5;
            // Following is auto-generated code for instruction finish
            break; }
        case 7: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_80_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_81_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_82_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_83_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_84_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_85_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_86_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_87_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 0) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_88_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_89_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_8A_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_8B_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_8C_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_8D_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_8E_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_8F_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 1) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_90_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_91_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_92_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_93_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_94_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_95_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_96_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_97_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 2) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_98_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_99_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_9A_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_9B_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_9C_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_9D_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_9E_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_9F_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 3) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A0_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A1_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A2_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A3_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A4_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A5_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A6_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A7_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 4) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A8_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_A9_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_AA_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_AB_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_AC_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_AD_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_AE_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_AF_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 5) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B0_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B1_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B2_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B3_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B4_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B5_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B6_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B7_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 6) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B8_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_B9_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_BA_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_BB_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_BC_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_BD_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_BE_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_BF_RES_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 6: { // wait
            regs->TR = regs->TR & ((1 << 7) ^ 0xFF);
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 0);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_C9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_CA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_CB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_CC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_CD_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_CE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_CF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 1);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 2);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_D9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_DA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_DB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_DC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_DD_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_DE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_DF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 3);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 4);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_E9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_EA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_EB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_EC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_ED_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_EE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_EF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 5);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F0_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F1_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F2_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F3_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F4_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F5_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F6_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F7_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 6);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F8_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->B = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_F9_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->C = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_FA_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->D = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_FB_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->E = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_FC_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->H = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_FD_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->L = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_FE_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            // JUNKVAR set here to regs->TR
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void Z80_ins_FDCB_FF_SET_o_irr_r(struct Z80_regs* regs, struct Z80_pins* pins)
{
    switch(regs->TCU) {
        case 1: { // wait
            regs->Q = 1;
            break; }
        case 2: { // wait
            break; }
        case 3: { // Start read
            pins->Addr = (regs->WZ);
            break; }
        case 4: { // signal
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 5: { // Read end/latch
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            regs->TR = regs->TR | (1 << 7);
            break; }
        case 6: { // wait
            regs->A = regs->TR;
            break; }
        case 7: { // write begin
            pins->Addr = (regs->WZ);
            break; }
        case 8: {
            pins->D = (regs->TR);
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 9: { // write end
            pins->WR = 0; pins->MRQ = 0;
            // Following is auto-generated code for instruction finish
            break; }
        case 10: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->EI = 0;
            regs->P = 0;
            regs->prefix = 0x00;
            regs->rprefix = Z80P_HL;
            regs->IR = Z80_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

Z80_ins_func Z80_decoded_opcodes[1806] = {
  &Z80_ins_00_00_NOP,   &Z80_ins_00_01_LD_rr_nn,   &Z80_ins_00_02_LD_irr_a,   &Z80_ins_00_03_INC_rr,   &Z80_ins_00_04_INC_r,
  &Z80_ins_00_05_DEC_r,   &Z80_ins_00_06_LD_r_n,   &Z80_ins_00_07_RLCA,   &Z80_ins_00_08_EX_rr_rr,   &Z80_ins_00_09_ADD_hl_rr,
  &Z80_ins_00_0A_LD_a_irr,   &Z80_ins_00_0B_DEC_rr,   &Z80_ins_00_0C_INC_r,   &Z80_ins_00_0D_DEC_r,   &Z80_ins_00_0E_LD_r_n,
  &Z80_ins_00_0F_RRCA,   &Z80_ins_00_10_DJNZ_e,   &Z80_ins_00_11_LD_rr_nn,   &Z80_ins_00_12_LD_irr_a,   &Z80_ins_00_13_INC_rr,
  &Z80_ins_00_14_INC_r,   &Z80_ins_00_15_DEC_r,   &Z80_ins_00_16_LD_r_n,   &Z80_ins_00_17_RLA,   &Z80_ins_00_18_JR_c_e,
  &Z80_ins_00_19_ADD_hl_rr,   &Z80_ins_00_1A_LD_a_irr,   &Z80_ins_00_1B_DEC_rr,   &Z80_ins_00_1C_INC_r,   &Z80_ins_00_1D_DEC_r,
  &Z80_ins_00_1E_LD_r_n,   &Z80_ins_00_1F_RRA,   &Z80_ins_00_20_JR_c_e,   &Z80_ins_00_21_LD_rr_nn,   &Z80_ins_00_22_LD_inn_rr,
  &Z80_ins_00_23_INC_rr,   &Z80_ins_00_24_INC_r,   &Z80_ins_00_25_DEC_r,   &Z80_ins_00_26_LD_r_n,   &Z80_ins_00_27_DAA,
  &Z80_ins_00_28_JR_c_e,   &Z80_ins_00_29_ADD_hl_rr,   &Z80_ins_00_2A_LD_rr_inn,   &Z80_ins_00_2B_DEC_rr,   &Z80_ins_00_2C_INC_r,
  &Z80_ins_00_2D_DEC_r,   &Z80_ins_00_2E_LD_r_n,   &Z80_ins_00_2F_CPL,   &Z80_ins_00_30_JR_c_e,   &Z80_ins_00_31_LD_rr_nn,
  &Z80_ins_00_32_LD_inn_a,   &Z80_ins_00_33_INC_rr,   &Z80_ins_00_34_INC_irr,   &Z80_ins_00_35_DEC_irr,   &Z80_ins_00_36_LD_irr_n,
  &Z80_ins_00_37_SCF,   &Z80_ins_00_38_JR_c_e,   &Z80_ins_00_39_ADD_hl_rr,   &Z80_ins_00_3A_LD_a_inn,   &Z80_ins_00_3B_DEC_rr,
  &Z80_ins_00_3C_INC_r,   &Z80_ins_00_3D_DEC_r,   &Z80_ins_00_3E_LD_r_n,   &Z80_ins_00_3F_CCF,   &Z80_ins_00_40_LD_r_r,
  &Z80_ins_00_41_LD_r_r,   &Z80_ins_00_42_LD_r_r,   &Z80_ins_00_43_LD_r_r,   &Z80_ins_00_44_LD_r_r,   &Z80_ins_00_45_LD_r_r,
  &Z80_ins_00_46_LD_r_irr,   &Z80_ins_00_47_LD_r_r,   &Z80_ins_00_48_LD_r_r,   &Z80_ins_00_49_LD_r_r,   &Z80_ins_00_4A_LD_r_r,
  &Z80_ins_00_4B_LD_r_r,   &Z80_ins_00_4C_LD_r_r,   &Z80_ins_00_4D_LD_r_r,   &Z80_ins_00_4E_LD_r_irr,   &Z80_ins_00_4F_LD_r_r,
  &Z80_ins_00_50_LD_r_r,   &Z80_ins_00_51_LD_r_r,   &Z80_ins_00_52_LD_r_r,   &Z80_ins_00_53_LD_r_r,   &Z80_ins_00_54_LD_r_r,
  &Z80_ins_00_55_LD_r_r,   &Z80_ins_00_56_LD_r_irr,   &Z80_ins_00_57_LD_r_r,   &Z80_ins_00_58_LD_r_r,   &Z80_ins_00_59_LD_r_r,
  &Z80_ins_00_5A_LD_r_r,   &Z80_ins_00_5B_LD_r_r,   &Z80_ins_00_5C_LD_r_r,   &Z80_ins_00_5D_LD_r_r,   &Z80_ins_00_5E_LD_r_irr,
  &Z80_ins_00_5F_LD_r_r,   &Z80_ins_00_60_LD_r_r,   &Z80_ins_00_61_LD_r_r,   &Z80_ins_00_62_LD_r_r,   &Z80_ins_00_63_LD_r_r,
  &Z80_ins_00_64_LD_r_r,   &Z80_ins_00_65_LD_r_r,   &Z80_ins_00_66_LD_r_irr,   &Z80_ins_00_67_LD_r_r,   &Z80_ins_00_68_LD_r_r,
  &Z80_ins_00_69_LD_r_r,   &Z80_ins_00_6A_LD_r_r,   &Z80_ins_00_6B_LD_r_r,   &Z80_ins_00_6C_LD_r_r,   &Z80_ins_00_6D_LD_r_r,
  &Z80_ins_00_6E_LD_r_irr,   &Z80_ins_00_6F_LD_r_r,   &Z80_ins_00_70_LD_irr_r,   &Z80_ins_00_71_LD_irr_r,   &Z80_ins_00_72_LD_irr_r,
  &Z80_ins_00_73_LD_irr_r,   &Z80_ins_00_74_LD_irr_r,   &Z80_ins_00_75_LD_irr_r,   &Z80_ins_00_76_HALT,   &Z80_ins_00_77_LD_irr_r,
  &Z80_ins_00_78_LD_r_r,   &Z80_ins_00_79_LD_r_r,   &Z80_ins_00_7A_LD_r_r,   &Z80_ins_00_7B_LD_r_r,   &Z80_ins_00_7C_LD_r_r,
  &Z80_ins_00_7D_LD_r_r,   &Z80_ins_00_7E_LD_r_irr,   &Z80_ins_00_7F_LD_r_r,   &Z80_ins_00_80_ADD_a_r,   &Z80_ins_00_81_ADD_a_r,
  &Z80_ins_00_82_ADD_a_r,   &Z80_ins_00_83_ADD_a_r,   &Z80_ins_00_84_ADD_a_r,   &Z80_ins_00_85_ADD_a_r,   &Z80_ins_00_86_ADD_a_irr,
  &Z80_ins_00_87_ADD_a_r,   &Z80_ins_00_88_ADC_a_r,   &Z80_ins_00_89_ADC_a_r,   &Z80_ins_00_8A_ADC_a_r,   &Z80_ins_00_8B_ADC_a_r,
  &Z80_ins_00_8C_ADC_a_r,   &Z80_ins_00_8D_ADC_a_r,   &Z80_ins_00_8E_ADC_a_irr,   &Z80_ins_00_8F_ADC_a_r,   &Z80_ins_00_90_SUB_a_r,
  &Z80_ins_00_91_SUB_a_r,   &Z80_ins_00_92_SUB_a_r,   &Z80_ins_00_93_SUB_a_r,   &Z80_ins_00_94_SUB_a_r,   &Z80_ins_00_95_SUB_a_r,
  &Z80_ins_00_96_SUB_a_irr,   &Z80_ins_00_97_SUB_a_r,   &Z80_ins_00_98_SBC_a_r,   &Z80_ins_00_99_SBC_a_r,   &Z80_ins_00_9A_SBC_a_r,
  &Z80_ins_00_9B_SBC_a_r,   &Z80_ins_00_9C_SBC_a_r,   &Z80_ins_00_9D_SBC_a_r,   &Z80_ins_00_9E_SBC_a_irr,   &Z80_ins_00_9F_SBC_a_r,
  &Z80_ins_00_A0_AND_a_r,   &Z80_ins_00_A1_AND_a_r,   &Z80_ins_00_A2_AND_a_r,   &Z80_ins_00_A3_AND_a_r,   &Z80_ins_00_A4_AND_a_r,
  &Z80_ins_00_A5_AND_a_r,   &Z80_ins_00_A6_AND_a_irr,   &Z80_ins_00_A7_AND_a_r,   &Z80_ins_00_A8_XOR_a_r,   &Z80_ins_00_A9_XOR_a_r,
  &Z80_ins_00_AA_XOR_a_r,   &Z80_ins_00_AB_XOR_a_r,   &Z80_ins_00_AC_XOR_a_r,   &Z80_ins_00_AD_XOR_a_r,   &Z80_ins_00_AE_XOR_a_irr,
  &Z80_ins_00_AF_XOR_a_r,   &Z80_ins_00_B0_OR_a_r,   &Z80_ins_00_B1_OR_a_r,   &Z80_ins_00_B2_OR_a_r,   &Z80_ins_00_B3_OR_a_r,
  &Z80_ins_00_B4_OR_a_r,   &Z80_ins_00_B5_OR_a_r,   &Z80_ins_00_B6_OR_a_irr,   &Z80_ins_00_B7_OR_a_r,   &Z80_ins_00_B8_CP_a_r,
  &Z80_ins_00_B9_CP_a_r,   &Z80_ins_00_BA_CP_a_r,   &Z80_ins_00_BB_CP_a_r,   &Z80_ins_00_BC_CP_a_r,   &Z80_ins_00_BD_CP_a_r,
  &Z80_ins_00_BE_CP_a_irr,   &Z80_ins_00_BF_CP_a_r,   &Z80_ins_00_C0_RET_c,   &Z80_ins_00_C1_POP_rr,   &Z80_ins_00_C2_JP_c_nn,
  &Z80_ins_00_C3_JP_c_nn,   &Z80_ins_00_C4_CALL_c_nn,   &Z80_ins_00_C5_PUSH_rr,   &Z80_ins_00_C6_ADD_a_n,   &Z80_ins_00_C7_RST_o,
  &Z80_ins_00_C8_RET_c,   &Z80_ins_00_C9_RET,   &Z80_ins_00_CA_JP_c_nn,   &Z80_ins_00_00_NOP,   &Z80_ins_00_CC_CALL_c_nn,
  &Z80_ins_00_CD_CALL_nn,   &Z80_ins_00_CE_ADC_a_n,   &Z80_ins_00_CF_RST_o,   &Z80_ins_00_D0_RET_c,   &Z80_ins_00_D1_POP_rr,
  &Z80_ins_00_D2_JP_c_nn,   &Z80_ins_00_D3_OUT_in_a,   &Z80_ins_00_D4_CALL_c_nn,   &Z80_ins_00_D5_PUSH_rr,   &Z80_ins_00_D6_SUB_a_n,
  &Z80_ins_00_D7_RST_o,   &Z80_ins_00_D8_RET_c,   &Z80_ins_00_D9_EXX,   &Z80_ins_00_DA_JP_c_nn,   &Z80_ins_00_DB_IN_a_in,
  &Z80_ins_00_DC_CALL_c_nn,   &Z80_ins_00_00_NOP,   &Z80_ins_00_DE_SBC_a_n,   &Z80_ins_00_DF_RST_o,   &Z80_ins_00_E0_RET_c,
  &Z80_ins_00_E1_POP_rr,   &Z80_ins_00_E2_JP_c_nn,   &Z80_ins_00_E3_EX_irr_rr,   &Z80_ins_00_E4_CALL_c_nn,   &Z80_ins_00_E5_PUSH_rr,
  &Z80_ins_00_E6_AND_a_n,   &Z80_ins_00_E7_RST_o,   &Z80_ins_00_E8_RET_c,   &Z80_ins_00_E9_JP_rr,   &Z80_ins_00_EA_JP_c_nn,
  &Z80_ins_00_EB_EX_rr_rr,   &Z80_ins_00_EC_CALL_c_nn,   &Z80_ins_00_00_NOP,   &Z80_ins_00_EE_XOR_a_n,   &Z80_ins_00_EF_RST_o,
  &Z80_ins_00_F0_RET_c,   &Z80_ins_00_F1_POP_rr,   &Z80_ins_00_F2_JP_c_nn,   &Z80_ins_00_F3_DI,   &Z80_ins_00_F4_CALL_c_nn,
  &Z80_ins_00_F5_PUSH_rr,   &Z80_ins_00_F6_OR_a_n,   &Z80_ins_00_F7_RST_o,   &Z80_ins_00_F8_RET_c,   &Z80_ins_00_F9_LD_sp_rr,
  &Z80_ins_00_FA_JP_c_nn,   &Z80_ins_00_FB_EI,   &Z80_ins_00_FC_CALL_c_nn,   &Z80_ins_00_00_NOP,   &Z80_ins_00_FE_CP_a_n,
  &Z80_ins_00_FF_RST_o,   &Z80_ins_00_100_IRQ,   &Z80_ins_00_101_RESET,   &Z80_ins_CB_00_RLC_r,   &Z80_ins_CB_01_RLC_r,
  &Z80_ins_CB_02_RLC_r,   &Z80_ins_CB_03_RLC_r,   &Z80_ins_CB_04_RLC_r,   &Z80_ins_CB_05_RLC_r,   &Z80_ins_CB_06_RLC_irr,
  &Z80_ins_CB_07_RLC_r,   &Z80_ins_CB_08_RRC_r,   &Z80_ins_CB_09_RRC_r,   &Z80_ins_CB_0A_RRC_r,   &Z80_ins_CB_0B_RRC_r,
  &Z80_ins_CB_0C_RRC_r,   &Z80_ins_CB_0D_RRC_r,   &Z80_ins_CB_0E_RRC_irr,   &Z80_ins_CB_0F_RRC_r,   &Z80_ins_CB_10_RL_r,
  &Z80_ins_CB_11_RL_r,   &Z80_ins_CB_12_RL_r,   &Z80_ins_CB_13_RL_r,   &Z80_ins_CB_14_RL_r,   &Z80_ins_CB_15_RL_r,
  &Z80_ins_CB_16_RL_irr,   &Z80_ins_CB_17_RL_r,   &Z80_ins_CB_18_RR_r,   &Z80_ins_CB_19_RR_r,   &Z80_ins_CB_1A_RR_r,
  &Z80_ins_CB_1B_RR_r,   &Z80_ins_CB_1C_RR_r,   &Z80_ins_CB_1D_RR_r,   &Z80_ins_CB_1E_RR_irr,   &Z80_ins_CB_1F_RR_r,
  &Z80_ins_CB_20_SLA_r,   &Z80_ins_CB_21_SLA_r,   &Z80_ins_CB_22_SLA_r,   &Z80_ins_CB_23_SLA_r,   &Z80_ins_CB_24_SLA_r,
  &Z80_ins_CB_25_SLA_r,   &Z80_ins_CB_26_SLA_irr,   &Z80_ins_CB_27_SLA_r,   &Z80_ins_CB_28_SRA_r,   &Z80_ins_CB_29_SRA_r,
  &Z80_ins_CB_2A_SRA_r,   &Z80_ins_CB_2B_SRA_r,   &Z80_ins_CB_2C_SRA_r,   &Z80_ins_CB_2D_SRA_r,   &Z80_ins_CB_2E_SRA_irr,
  &Z80_ins_CB_2F_SRA_r,   &Z80_ins_CB_30_SLL_r,   &Z80_ins_CB_31_SLL_r,   &Z80_ins_CB_32_SLL_r,   &Z80_ins_CB_33_SLL_r,
  &Z80_ins_CB_34_SLL_r,   &Z80_ins_CB_35_SLL_r,   &Z80_ins_CB_36_SLL_irr,   &Z80_ins_CB_37_SLL_r,   &Z80_ins_CB_38_SRL_r,
  &Z80_ins_CB_39_SRL_r,   &Z80_ins_CB_3A_SRL_r,   &Z80_ins_CB_3B_SRL_r,   &Z80_ins_CB_3C_SRL_r,   &Z80_ins_CB_3D_SRL_r,
  &Z80_ins_CB_3E_SRL_irr,   &Z80_ins_CB_3F_SRL_r,   &Z80_ins_CB_40_BIT_o_r,   &Z80_ins_CB_41_BIT_o_r,   &Z80_ins_CB_42_BIT_o_r,
  &Z80_ins_CB_43_BIT_o_r,   &Z80_ins_CB_44_BIT_o_r,   &Z80_ins_CB_45_BIT_o_r,   &Z80_ins_CB_46_BIT_o_irr,   &Z80_ins_CB_47_BIT_o_r,
  &Z80_ins_CB_48_BIT_o_r,   &Z80_ins_CB_49_BIT_o_r,   &Z80_ins_CB_4A_BIT_o_r,   &Z80_ins_CB_4B_BIT_o_r,   &Z80_ins_CB_4C_BIT_o_r,
  &Z80_ins_CB_4D_BIT_o_r,   &Z80_ins_CB_4E_BIT_o_irr,   &Z80_ins_CB_4F_BIT_o_r,   &Z80_ins_CB_50_BIT_o_r,   &Z80_ins_CB_51_BIT_o_r,
  &Z80_ins_CB_52_BIT_o_r,   &Z80_ins_CB_53_BIT_o_r,   &Z80_ins_CB_54_BIT_o_r,   &Z80_ins_CB_55_BIT_o_r,   &Z80_ins_CB_56_BIT_o_irr,
  &Z80_ins_CB_57_BIT_o_r,   &Z80_ins_CB_58_BIT_o_r,   &Z80_ins_CB_59_BIT_o_r,   &Z80_ins_CB_5A_BIT_o_r,   &Z80_ins_CB_5B_BIT_o_r,
  &Z80_ins_CB_5C_BIT_o_r,   &Z80_ins_CB_5D_BIT_o_r,   &Z80_ins_CB_5E_BIT_o_irr,   &Z80_ins_CB_5F_BIT_o_r,   &Z80_ins_CB_60_BIT_o_r,
  &Z80_ins_CB_61_BIT_o_r,   &Z80_ins_CB_62_BIT_o_r,   &Z80_ins_CB_63_BIT_o_r,   &Z80_ins_CB_64_BIT_o_r,   &Z80_ins_CB_65_BIT_o_r,
  &Z80_ins_CB_66_BIT_o_irr,   &Z80_ins_CB_67_BIT_o_r,   &Z80_ins_CB_68_BIT_o_r,   &Z80_ins_CB_69_BIT_o_r,   &Z80_ins_CB_6A_BIT_o_r,
  &Z80_ins_CB_6B_BIT_o_r,   &Z80_ins_CB_6C_BIT_o_r,   &Z80_ins_CB_6D_BIT_o_r,   &Z80_ins_CB_6E_BIT_o_irr,   &Z80_ins_CB_6F_BIT_o_r,
  &Z80_ins_CB_70_BIT_o_r,   &Z80_ins_CB_71_BIT_o_r,   &Z80_ins_CB_72_BIT_o_r,   &Z80_ins_CB_73_BIT_o_r,   &Z80_ins_CB_74_BIT_o_r,
  &Z80_ins_CB_75_BIT_o_r,   &Z80_ins_CB_76_BIT_o_irr,   &Z80_ins_CB_77_BIT_o_r,   &Z80_ins_CB_78_BIT_o_r,   &Z80_ins_CB_79_BIT_o_r,
  &Z80_ins_CB_7A_BIT_o_r,   &Z80_ins_CB_7B_BIT_o_r,   &Z80_ins_CB_7C_BIT_o_r,   &Z80_ins_CB_7D_BIT_o_r,   &Z80_ins_CB_7E_BIT_o_irr,
  &Z80_ins_CB_7F_BIT_o_r,   &Z80_ins_CB_80_RES_o_r,   &Z80_ins_CB_81_RES_o_r,   &Z80_ins_CB_82_RES_o_r,   &Z80_ins_CB_83_RES_o_r,
  &Z80_ins_CB_84_RES_o_r,   &Z80_ins_CB_85_RES_o_r,   &Z80_ins_CB_86_RES_o_irr,   &Z80_ins_CB_87_RES_o_r,   &Z80_ins_CB_88_RES_o_r,
  &Z80_ins_CB_89_RES_o_r,   &Z80_ins_CB_8A_RES_o_r,   &Z80_ins_CB_8B_RES_o_r,   &Z80_ins_CB_8C_RES_o_r,   &Z80_ins_CB_8D_RES_o_r,
  &Z80_ins_CB_8E_RES_o_irr,   &Z80_ins_CB_8F_RES_o_r,   &Z80_ins_CB_90_RES_o_r,   &Z80_ins_CB_91_RES_o_r,   &Z80_ins_CB_92_RES_o_r,
  &Z80_ins_CB_93_RES_o_r,   &Z80_ins_CB_94_RES_o_r,   &Z80_ins_CB_95_RES_o_r,   &Z80_ins_CB_96_RES_o_irr,   &Z80_ins_CB_97_RES_o_r,
  &Z80_ins_CB_98_RES_o_r,   &Z80_ins_CB_99_RES_o_r,   &Z80_ins_CB_9A_RES_o_r,   &Z80_ins_CB_9B_RES_o_r,   &Z80_ins_CB_9C_RES_o_r,
  &Z80_ins_CB_9D_RES_o_r,   &Z80_ins_CB_9E_RES_o_irr,   &Z80_ins_CB_9F_RES_o_r,   &Z80_ins_CB_A0_RES_o_r,   &Z80_ins_CB_A1_RES_o_r,
  &Z80_ins_CB_A2_RES_o_r,   &Z80_ins_CB_A3_RES_o_r,   &Z80_ins_CB_A4_RES_o_r,   &Z80_ins_CB_A5_RES_o_r,   &Z80_ins_CB_A6_RES_o_irr,
  &Z80_ins_CB_A7_RES_o_r,   &Z80_ins_CB_A8_RES_o_r,   &Z80_ins_CB_A9_RES_o_r,   &Z80_ins_CB_AA_RES_o_r,   &Z80_ins_CB_AB_RES_o_r,
  &Z80_ins_CB_AC_RES_o_r,   &Z80_ins_CB_AD_RES_o_r,   &Z80_ins_CB_AE_RES_o_irr,   &Z80_ins_CB_AF_RES_o_r,   &Z80_ins_CB_B0_RES_o_r,
  &Z80_ins_CB_B1_RES_o_r,   &Z80_ins_CB_B2_RES_o_r,   &Z80_ins_CB_B3_RES_o_r,   &Z80_ins_CB_B4_RES_o_r,   &Z80_ins_CB_B5_RES_o_r,
  &Z80_ins_CB_B6_RES_o_irr,   &Z80_ins_CB_B7_RES_o_r,   &Z80_ins_CB_B8_RES_o_r,   &Z80_ins_CB_B9_RES_o_r,   &Z80_ins_CB_BA_RES_o_r,
  &Z80_ins_CB_BB_RES_o_r,   &Z80_ins_CB_BC_RES_o_r,   &Z80_ins_CB_BD_RES_o_r,   &Z80_ins_CB_BE_RES_o_irr,   &Z80_ins_CB_BF_RES_o_r,
  &Z80_ins_CB_C0_SET_o_r,   &Z80_ins_CB_C1_SET_o_r,   &Z80_ins_CB_C2_SET_o_r,   &Z80_ins_CB_C3_SET_o_r,   &Z80_ins_CB_C4_SET_o_r,
  &Z80_ins_CB_C5_SET_o_r,   &Z80_ins_CB_C6_SET_o_irr,   &Z80_ins_CB_C7_SET_o_r,   &Z80_ins_CB_C8_SET_o_r,   &Z80_ins_CB_C9_SET_o_r,
  &Z80_ins_CB_CA_SET_o_r,   &Z80_ins_CB_CB_SET_o_r,   &Z80_ins_CB_CC_SET_o_r,   &Z80_ins_CB_CD_SET_o_r,   &Z80_ins_CB_CE_SET_o_irr,
  &Z80_ins_CB_CF_SET_o_r,   &Z80_ins_CB_D0_SET_o_r,   &Z80_ins_CB_D1_SET_o_r,   &Z80_ins_CB_D2_SET_o_r,   &Z80_ins_CB_D3_SET_o_r,
  &Z80_ins_CB_D4_SET_o_r,   &Z80_ins_CB_D5_SET_o_r,   &Z80_ins_CB_D6_SET_o_irr,   &Z80_ins_CB_D7_SET_o_r,   &Z80_ins_CB_D8_SET_o_r,
  &Z80_ins_CB_D9_SET_o_r,   &Z80_ins_CB_DA_SET_o_r,   &Z80_ins_CB_DB_SET_o_r,   &Z80_ins_CB_DC_SET_o_r,   &Z80_ins_CB_DD_SET_o_r,
  &Z80_ins_CB_DE_SET_o_irr,   &Z80_ins_CB_DF_SET_o_r,   &Z80_ins_CB_E0_SET_o_r,   &Z80_ins_CB_E1_SET_o_r,   &Z80_ins_CB_E2_SET_o_r,
  &Z80_ins_CB_E3_SET_o_r,   &Z80_ins_CB_E4_SET_o_r,   &Z80_ins_CB_E5_SET_o_r,   &Z80_ins_CB_E6_SET_o_irr,   &Z80_ins_CB_E7_SET_o_r,
  &Z80_ins_CB_E8_SET_o_r,   &Z80_ins_CB_E9_SET_o_r,   &Z80_ins_CB_EA_SET_o_r,   &Z80_ins_CB_EB_SET_o_r,   &Z80_ins_CB_EC_SET_o_r,
  &Z80_ins_CB_ED_SET_o_r,   &Z80_ins_CB_EE_SET_o_irr,   &Z80_ins_CB_EF_SET_o_r,   &Z80_ins_CB_F0_SET_o_r,   &Z80_ins_CB_F1_SET_o_r,
  &Z80_ins_CB_F2_SET_o_r,   &Z80_ins_CB_F3_SET_o_r,   &Z80_ins_CB_F4_SET_o_r,   &Z80_ins_CB_F5_SET_o_r,   &Z80_ins_CB_F6_SET_o_irr,
  &Z80_ins_CB_F7_SET_o_r,   &Z80_ins_CB_F8_SET_o_r,   &Z80_ins_CB_F9_SET_o_r,   &Z80_ins_CB_FA_SET_o_r,   &Z80_ins_CB_FB_SET_o_r,
  &Z80_ins_CB_FC_SET_o_r,   &Z80_ins_CB_FD_SET_o_r,   &Z80_ins_CB_FE_SET_o_irr,   &Z80_ins_CB_FF_SET_o_r,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_DD_00_NOP,   &Z80_ins_DD_01_LD_rr_nn,   &Z80_ins_DD_02_LD_irr_a,   &Z80_ins_DD_03_INC_rr,
  &Z80_ins_DD_04_INC_r,   &Z80_ins_DD_05_DEC_r,   &Z80_ins_DD_06_LD_r_n,   &Z80_ins_DD_07_RLCA,   &Z80_ins_DD_08_EX_rr_rr,
  &Z80_ins_DD_09_ADD_hl_rr,   &Z80_ins_DD_0A_LD_a_irr,   &Z80_ins_DD_0B_DEC_rr,   &Z80_ins_DD_0C_INC_r,   &Z80_ins_DD_0D_DEC_r,
  &Z80_ins_DD_0E_LD_r_n,   &Z80_ins_DD_0F_RRCA,   &Z80_ins_DD_10_DJNZ_e,   &Z80_ins_DD_11_LD_rr_nn,   &Z80_ins_DD_12_LD_irr_a,
  &Z80_ins_DD_13_INC_rr,   &Z80_ins_DD_14_INC_r,   &Z80_ins_DD_15_DEC_r,   &Z80_ins_DD_16_LD_r_n,   &Z80_ins_DD_17_RLA,
  &Z80_ins_DD_18_JR_c_e,   &Z80_ins_DD_19_ADD_hl_rr,   &Z80_ins_DD_1A_LD_a_irr,   &Z80_ins_DD_1B_DEC_rr,   &Z80_ins_DD_1C_INC_r,
  &Z80_ins_DD_1D_DEC_r,   &Z80_ins_DD_1E_LD_r_n,   &Z80_ins_DD_1F_RRA,   &Z80_ins_DD_20_JR_c_e,   &Z80_ins_DD_21_LD_rr_nn,
  &Z80_ins_DD_22_LD_inn_rr,   &Z80_ins_DD_23_INC_rr,   &Z80_ins_DD_24_INC_r,   &Z80_ins_DD_25_DEC_r,   &Z80_ins_DD_26_LD_r_n,
  &Z80_ins_DD_27_DAA,   &Z80_ins_DD_28_JR_c_e,   &Z80_ins_DD_29_ADD_hl_rr,   &Z80_ins_DD_2A_LD_rr_inn,   &Z80_ins_DD_2B_DEC_rr,
  &Z80_ins_DD_2C_INC_r,   &Z80_ins_DD_2D_DEC_r,   &Z80_ins_DD_2E_LD_r_n,   &Z80_ins_DD_2F_CPL,   &Z80_ins_DD_30_JR_c_e,
  &Z80_ins_DD_31_LD_rr_nn,   &Z80_ins_DD_32_LD_inn_a,   &Z80_ins_DD_33_INC_rr,   &Z80_ins_DD_34_INC_irr,   &Z80_ins_DD_35_DEC_irr,
  &Z80_ins_DD_36_LD_irr_n,   &Z80_ins_DD_37_SCF,   &Z80_ins_DD_38_JR_c_e,   &Z80_ins_DD_39_ADD_hl_rr,   &Z80_ins_DD_3A_LD_a_inn,
  &Z80_ins_DD_3B_DEC_rr,   &Z80_ins_DD_3C_INC_r,   &Z80_ins_DD_3D_DEC_r,   &Z80_ins_DD_3E_LD_r_n,   &Z80_ins_DD_3F_CCF,
  &Z80_ins_DD_40_LD_r_r,   &Z80_ins_DD_41_LD_r_r,   &Z80_ins_DD_42_LD_r_r,   &Z80_ins_DD_43_LD_r_r,   &Z80_ins_DD_44_LD_r_r,
  &Z80_ins_DD_45_LD_r_r,   &Z80_ins_DD_46_LD_r_irr,   &Z80_ins_DD_47_LD_r_r,   &Z80_ins_DD_48_LD_r_r,   &Z80_ins_DD_49_LD_r_r,
  &Z80_ins_DD_4A_LD_r_r,   &Z80_ins_DD_4B_LD_r_r,   &Z80_ins_DD_4C_LD_r_r,   &Z80_ins_DD_4D_LD_r_r,   &Z80_ins_DD_4E_LD_r_irr,
  &Z80_ins_DD_4F_LD_r_r,   &Z80_ins_DD_50_LD_r_r,   &Z80_ins_DD_51_LD_r_r,   &Z80_ins_DD_52_LD_r_r,   &Z80_ins_DD_53_LD_r_r,
  &Z80_ins_DD_54_LD_r_r,   &Z80_ins_DD_55_LD_r_r,   &Z80_ins_DD_56_LD_r_irr,   &Z80_ins_DD_57_LD_r_r,   &Z80_ins_DD_58_LD_r_r,
  &Z80_ins_DD_59_LD_r_r,   &Z80_ins_DD_5A_LD_r_r,   &Z80_ins_DD_5B_LD_r_r,   &Z80_ins_DD_5C_LD_r_r,   &Z80_ins_DD_5D_LD_r_r,
  &Z80_ins_DD_5E_LD_r_irr,   &Z80_ins_DD_5F_LD_r_r,   &Z80_ins_DD_60_LD_r_r,   &Z80_ins_DD_61_LD_r_r,   &Z80_ins_DD_62_LD_r_r,
  &Z80_ins_DD_63_LD_r_r,   &Z80_ins_DD_64_LD_r_r,   &Z80_ins_DD_65_LD_r_r,   &Z80_ins_DD_66_LD_r_irr,   &Z80_ins_DD_67_LD_r_r,
  &Z80_ins_DD_68_LD_r_r,   &Z80_ins_DD_69_LD_r_r,   &Z80_ins_DD_6A_LD_r_r,   &Z80_ins_DD_6B_LD_r_r,   &Z80_ins_DD_6C_LD_r_r,
  &Z80_ins_DD_6D_LD_r_r,   &Z80_ins_DD_6E_LD_r_irr,   &Z80_ins_DD_6F_LD_r_r,   &Z80_ins_DD_70_LD_irr_r,   &Z80_ins_DD_71_LD_irr_r,
  &Z80_ins_DD_72_LD_irr_r,   &Z80_ins_DD_73_LD_irr_r,   &Z80_ins_DD_74_LD_irr_r,   &Z80_ins_DD_75_LD_irr_r,   &Z80_ins_DD_76_HALT,
  &Z80_ins_DD_77_LD_irr_r,   &Z80_ins_DD_78_LD_r_r,   &Z80_ins_DD_79_LD_r_r,   &Z80_ins_DD_7A_LD_r_r,   &Z80_ins_DD_7B_LD_r_r,
  &Z80_ins_DD_7C_LD_r_r,   &Z80_ins_DD_7D_LD_r_r,   &Z80_ins_DD_7E_LD_r_irr,   &Z80_ins_DD_7F_LD_r_r,   &Z80_ins_DD_80_ADD_a_r,
  &Z80_ins_DD_81_ADD_a_r,   &Z80_ins_DD_82_ADD_a_r,   &Z80_ins_DD_83_ADD_a_r,   &Z80_ins_DD_84_ADD_a_r,   &Z80_ins_DD_85_ADD_a_r,
  &Z80_ins_DD_86_ADD_a_irr,   &Z80_ins_DD_87_ADD_a_r,   &Z80_ins_DD_88_ADC_a_r,   &Z80_ins_DD_89_ADC_a_r,   &Z80_ins_DD_8A_ADC_a_r,
  &Z80_ins_DD_8B_ADC_a_r,   &Z80_ins_DD_8C_ADC_a_r,   &Z80_ins_DD_8D_ADC_a_r,   &Z80_ins_DD_8E_ADC_a_irr,   &Z80_ins_DD_8F_ADC_a_r,
  &Z80_ins_DD_90_SUB_a_r,   &Z80_ins_DD_91_SUB_a_r,   &Z80_ins_DD_92_SUB_a_r,   &Z80_ins_DD_93_SUB_a_r,   &Z80_ins_DD_94_SUB_a_r,
  &Z80_ins_DD_95_SUB_a_r,   &Z80_ins_DD_96_SUB_a_irr,   &Z80_ins_DD_97_SUB_a_r,   &Z80_ins_DD_98_SBC_a_r,   &Z80_ins_DD_99_SBC_a_r,
  &Z80_ins_DD_9A_SBC_a_r,   &Z80_ins_DD_9B_SBC_a_r,   &Z80_ins_DD_9C_SBC_a_r,   &Z80_ins_DD_9D_SBC_a_r,   &Z80_ins_DD_9E_SBC_a_irr,
  &Z80_ins_DD_9F_SBC_a_r,   &Z80_ins_DD_A0_AND_a_r,   &Z80_ins_DD_A1_AND_a_r,   &Z80_ins_DD_A2_AND_a_r,   &Z80_ins_DD_A3_AND_a_r,
  &Z80_ins_DD_A4_AND_a_r,   &Z80_ins_DD_A5_AND_a_r,   &Z80_ins_DD_A6_AND_a_irr,   &Z80_ins_DD_A7_AND_a_r,   &Z80_ins_DD_A8_XOR_a_r,
  &Z80_ins_DD_A9_XOR_a_r,   &Z80_ins_DD_AA_XOR_a_r,   &Z80_ins_DD_AB_XOR_a_r,   &Z80_ins_DD_AC_XOR_a_r,   &Z80_ins_DD_AD_XOR_a_r,
  &Z80_ins_DD_AE_XOR_a_irr,   &Z80_ins_DD_AF_XOR_a_r,   &Z80_ins_DD_B0_OR_a_r,   &Z80_ins_DD_B1_OR_a_r,   &Z80_ins_DD_B2_OR_a_r,
  &Z80_ins_DD_B3_OR_a_r,   &Z80_ins_DD_B4_OR_a_r,   &Z80_ins_DD_B5_OR_a_r,   &Z80_ins_DD_B6_OR_a_irr,   &Z80_ins_DD_B7_OR_a_r,
  &Z80_ins_DD_B8_CP_a_r,   &Z80_ins_DD_B9_CP_a_r,   &Z80_ins_DD_BA_CP_a_r,   &Z80_ins_DD_BB_CP_a_r,   &Z80_ins_DD_BC_CP_a_r,
  &Z80_ins_DD_BD_CP_a_r,   &Z80_ins_DD_BE_CP_a_irr,   &Z80_ins_DD_BF_CP_a_r,   &Z80_ins_DD_C0_RET_c,   &Z80_ins_DD_C1_POP_rr,
  &Z80_ins_DD_C2_JP_c_nn,   &Z80_ins_DD_C3_JP_c_nn,   &Z80_ins_DD_C4_CALL_c_nn,   &Z80_ins_DD_C5_PUSH_rr,   &Z80_ins_DD_C6_ADD_a_n,
  &Z80_ins_DD_C7_RST_o,   &Z80_ins_DD_C8_RET_c,   &Z80_ins_DD_C9_RET,   &Z80_ins_DD_CA_JP_c_nn,   &Z80_ins_00_00_NOP,
  &Z80_ins_DD_CC_CALL_c_nn,   &Z80_ins_DD_CD_CALL_nn,   &Z80_ins_DD_CE_ADC_a_n,   &Z80_ins_DD_CF_RST_o,   &Z80_ins_DD_D0_RET_c,
  &Z80_ins_DD_D1_POP_rr,   &Z80_ins_DD_D2_JP_c_nn,   &Z80_ins_DD_D3_OUT_in_a,   &Z80_ins_DD_D4_CALL_c_nn,   &Z80_ins_DD_D5_PUSH_rr,
  &Z80_ins_DD_D6_SUB_a_n,   &Z80_ins_DD_D7_RST_o,   &Z80_ins_DD_D8_RET_c,   &Z80_ins_DD_D9_EXX,   &Z80_ins_DD_DA_JP_c_nn,
  &Z80_ins_DD_DB_IN_a_in,   &Z80_ins_DD_DC_CALL_c_nn,   &Z80_ins_00_00_NOP,   &Z80_ins_DD_DE_SBC_a_n,   &Z80_ins_DD_DF_RST_o,
  &Z80_ins_DD_E0_RET_c,   &Z80_ins_DD_E1_POP_rr,   &Z80_ins_DD_E2_JP_c_nn,   &Z80_ins_DD_E3_EX_irr_rr,   &Z80_ins_DD_E4_CALL_c_nn,
  &Z80_ins_DD_E5_PUSH_rr,   &Z80_ins_DD_E6_AND_a_n,   &Z80_ins_DD_E7_RST_o,   &Z80_ins_DD_E8_RET_c,   &Z80_ins_DD_E9_JP_rr,
  &Z80_ins_DD_EA_JP_c_nn,   &Z80_ins_DD_EB_EX_rr_rr,   &Z80_ins_DD_EC_CALL_c_nn,   &Z80_ins_00_00_NOP,   &Z80_ins_DD_EE_XOR_a_n,
  &Z80_ins_DD_EF_RST_o,   &Z80_ins_DD_F0_RET_c,   &Z80_ins_DD_F1_POP_rr,   &Z80_ins_DD_F2_JP_c_nn,   &Z80_ins_DD_F3_DI,
  &Z80_ins_DD_F4_CALL_c_nn,   &Z80_ins_DD_F5_PUSH_rr,   &Z80_ins_DD_F6_OR_a_n,   &Z80_ins_DD_F7_RST_o,   &Z80_ins_DD_F8_RET_c,
  &Z80_ins_DD_F9_LD_sp_rr,   &Z80_ins_DD_FA_JP_c_nn,   &Z80_ins_DD_FB_EI,   &Z80_ins_DD_FC_CALL_c_nn,   &Z80_ins_00_00_NOP,
  &Z80_ins_DD_FE_CP_a_n,   &Z80_ins_DD_FF_RST_o,   &Z80_ins_DD_100_IRQ,   &Z80_ins_DD_101_RESET,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_ED_40_IN_r_ic,   &Z80_ins_ED_41_OUT_ic_r,
  &Z80_ins_ED_42_SBC_hl_rr,   &Z80_ins_ED_43_LD_inn_rr,   &Z80_ins_ED_44_NEG,   &Z80_ins_ED_45_RETN,   &Z80_ins_ED_46_IM_o,
  &Z80_ins_ED_47_LD_r_r1,   &Z80_ins_ED_48_IN_r_ic,   &Z80_ins_ED_49_OUT_ic_r,   &Z80_ins_ED_4A_ADC_hl_rr,   &Z80_ins_ED_4B_LD_rr_inn,
  &Z80_ins_ED_4C_NEG,   &Z80_ins_ED_4D_RETI,   &Z80_ins_ED_4E_IM_o,   &Z80_ins_ED_4F_LD_r_r1,   &Z80_ins_ED_50_IN_r_ic,
  &Z80_ins_ED_51_OUT_ic_r,   &Z80_ins_ED_52_SBC_hl_rr,   &Z80_ins_ED_53_LD_inn_rr,   &Z80_ins_ED_54_NEG,   &Z80_ins_ED_55_RETN,
  &Z80_ins_ED_56_IM_o,   &Z80_ins_ED_57_LD_r_r2,   &Z80_ins_ED_58_IN_r_ic,   &Z80_ins_ED_59_OUT_ic_r,   &Z80_ins_ED_5A_ADC_hl_rr,
  &Z80_ins_ED_5B_LD_rr_inn,   &Z80_ins_ED_5C_NEG,   &Z80_ins_ED_5D_RETI,   &Z80_ins_ED_5E_IM_o,   &Z80_ins_ED_5F_LD_r_r2,
  &Z80_ins_ED_60_IN_r_ic,   &Z80_ins_ED_61_OUT_ic_r,   &Z80_ins_ED_62_SBC_hl_rr,   &Z80_ins_ED_63_LD_inn_rr,   &Z80_ins_ED_64_NEG,
  &Z80_ins_ED_65_RETN,   &Z80_ins_ED_66_IM_o,   &Z80_ins_ED_67_RRD,   &Z80_ins_ED_68_IN_r_ic,   &Z80_ins_ED_69_OUT_ic_r,
  &Z80_ins_ED_6A_ADC_hl_rr,   &Z80_ins_ED_6B_LD_rr_inn,   &Z80_ins_ED_6C_NEG,   &Z80_ins_ED_6D_RETI,   &Z80_ins_ED_6E_IM_o,
  &Z80_ins_ED_6F_RLD,   &Z80_ins_ED_70_IN_ic,   &Z80_ins_ED_71_OUT_ic,   &Z80_ins_ED_72_SBC_hl_rr,   &Z80_ins_ED_73_LD_inn_rr,
  &Z80_ins_ED_74_NEG,   &Z80_ins_ED_75_RETN,   &Z80_ins_ED_76_IM_o,   &Z80_ins_ED_77_NOP,   &Z80_ins_ED_78_IN_r_ic,
  &Z80_ins_ED_79_OUT_ic_r,   &Z80_ins_ED_7A_ADC_hl_rr,   &Z80_ins_ED_7B_LD_rr_inn,   &Z80_ins_ED_7C_NEG,   &Z80_ins_ED_7D_RETI,
  &Z80_ins_ED_7E_IM_o,   &Z80_ins_ED_7F_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_ED_A0_LDI,
  &Z80_ins_ED_A1_CPI,   &Z80_ins_ED_A2_INI,   &Z80_ins_ED_A3_OUTI,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_ED_A8_LDD,   &Z80_ins_ED_A9_CPD,   &Z80_ins_ED_AA_IND,
  &Z80_ins_ED_AB_OUTD,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_ED_B0_LDIR,   &Z80_ins_ED_B1_CPIR,   &Z80_ins_ED_B2_INIR,   &Z80_ins_ED_B3_OTIR,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_ED_B8_LDDR,   &Z80_ins_ED_B9_CPDR,
  &Z80_ins_ED_BA_INDR,   &Z80_ins_ED_BB_OTDR,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_FD_00_NOP,   &Z80_ins_FD_01_LD_rr_nn,   &Z80_ins_FD_02_LD_irr_a,
  &Z80_ins_FD_03_INC_rr,   &Z80_ins_FD_04_INC_r,   &Z80_ins_FD_05_DEC_r,   &Z80_ins_FD_06_LD_r_n,   &Z80_ins_FD_07_RLCA,
  &Z80_ins_FD_08_EX_rr_rr,   &Z80_ins_FD_09_ADD_hl_rr,   &Z80_ins_FD_0A_LD_a_irr,   &Z80_ins_FD_0B_DEC_rr,   &Z80_ins_FD_0C_INC_r,
  &Z80_ins_FD_0D_DEC_r,   &Z80_ins_FD_0E_LD_r_n,   &Z80_ins_FD_0F_RRCA,   &Z80_ins_FD_10_DJNZ_e,   &Z80_ins_FD_11_LD_rr_nn,
  &Z80_ins_FD_12_LD_irr_a,   &Z80_ins_FD_13_INC_rr,   &Z80_ins_FD_14_INC_r,   &Z80_ins_FD_15_DEC_r,   &Z80_ins_FD_16_LD_r_n,
  &Z80_ins_FD_17_RLA,   &Z80_ins_FD_18_JR_c_e,   &Z80_ins_FD_19_ADD_hl_rr,   &Z80_ins_FD_1A_LD_a_irr,   &Z80_ins_FD_1B_DEC_rr,
  &Z80_ins_FD_1C_INC_r,   &Z80_ins_FD_1D_DEC_r,   &Z80_ins_FD_1E_LD_r_n,   &Z80_ins_FD_1F_RRA,   &Z80_ins_FD_20_JR_c_e,
  &Z80_ins_FD_21_LD_rr_nn,   &Z80_ins_FD_22_LD_inn_rr,   &Z80_ins_FD_23_INC_rr,   &Z80_ins_FD_24_INC_r,   &Z80_ins_FD_25_DEC_r,
  &Z80_ins_FD_26_LD_r_n,   &Z80_ins_FD_27_DAA,   &Z80_ins_FD_28_JR_c_e,   &Z80_ins_FD_29_ADD_hl_rr,   &Z80_ins_FD_2A_LD_rr_inn,
  &Z80_ins_FD_2B_DEC_rr,   &Z80_ins_FD_2C_INC_r,   &Z80_ins_FD_2D_DEC_r,   &Z80_ins_FD_2E_LD_r_n,   &Z80_ins_FD_2F_CPL,
  &Z80_ins_FD_30_JR_c_e,   &Z80_ins_FD_31_LD_rr_nn,   &Z80_ins_FD_32_LD_inn_a,   &Z80_ins_FD_33_INC_rr,   &Z80_ins_FD_34_INC_irr,
  &Z80_ins_FD_35_DEC_irr,   &Z80_ins_FD_36_LD_irr_n,   &Z80_ins_FD_37_SCF,   &Z80_ins_FD_38_JR_c_e,   &Z80_ins_FD_39_ADD_hl_rr,
  &Z80_ins_FD_3A_LD_a_inn,   &Z80_ins_FD_3B_DEC_rr,   &Z80_ins_FD_3C_INC_r,   &Z80_ins_FD_3D_DEC_r,   &Z80_ins_FD_3E_LD_r_n,
  &Z80_ins_FD_3F_CCF,   &Z80_ins_FD_40_LD_r_r,   &Z80_ins_FD_41_LD_r_r,   &Z80_ins_FD_42_LD_r_r,   &Z80_ins_FD_43_LD_r_r,
  &Z80_ins_FD_44_LD_r_r,   &Z80_ins_FD_45_LD_r_r,   &Z80_ins_FD_46_LD_r_irr,   &Z80_ins_FD_47_LD_r_r,   &Z80_ins_FD_48_LD_r_r,
  &Z80_ins_FD_49_LD_r_r,   &Z80_ins_FD_4A_LD_r_r,   &Z80_ins_FD_4B_LD_r_r,   &Z80_ins_FD_4C_LD_r_r,   &Z80_ins_FD_4D_LD_r_r,
  &Z80_ins_FD_4E_LD_r_irr,   &Z80_ins_FD_4F_LD_r_r,   &Z80_ins_FD_50_LD_r_r,   &Z80_ins_FD_51_LD_r_r,   &Z80_ins_FD_52_LD_r_r,
  &Z80_ins_FD_53_LD_r_r,   &Z80_ins_FD_54_LD_r_r,   &Z80_ins_FD_55_LD_r_r,   &Z80_ins_FD_56_LD_r_irr,   &Z80_ins_FD_57_LD_r_r,
  &Z80_ins_FD_58_LD_r_r,   &Z80_ins_FD_59_LD_r_r,   &Z80_ins_FD_5A_LD_r_r,   &Z80_ins_FD_5B_LD_r_r,   &Z80_ins_FD_5C_LD_r_r,
  &Z80_ins_FD_5D_LD_r_r,   &Z80_ins_FD_5E_LD_r_irr,   &Z80_ins_FD_5F_LD_r_r,   &Z80_ins_FD_60_LD_r_r,   &Z80_ins_FD_61_LD_r_r,
  &Z80_ins_FD_62_LD_r_r,   &Z80_ins_FD_63_LD_r_r,   &Z80_ins_FD_64_LD_r_r,   &Z80_ins_FD_65_LD_r_r,   &Z80_ins_FD_66_LD_r_irr,
  &Z80_ins_FD_67_LD_r_r,   &Z80_ins_FD_68_LD_r_r,   &Z80_ins_FD_69_LD_r_r,   &Z80_ins_FD_6A_LD_r_r,   &Z80_ins_FD_6B_LD_r_r,
  &Z80_ins_FD_6C_LD_r_r,   &Z80_ins_FD_6D_LD_r_r,   &Z80_ins_FD_6E_LD_r_irr,   &Z80_ins_FD_6F_LD_r_r,   &Z80_ins_FD_70_LD_irr_r,
  &Z80_ins_FD_71_LD_irr_r,   &Z80_ins_FD_72_LD_irr_r,   &Z80_ins_FD_73_LD_irr_r,   &Z80_ins_FD_74_LD_irr_r,   &Z80_ins_FD_75_LD_irr_r,
  &Z80_ins_FD_76_HALT,   &Z80_ins_FD_77_LD_irr_r,   &Z80_ins_FD_78_LD_r_r,   &Z80_ins_FD_79_LD_r_r,   &Z80_ins_FD_7A_LD_r_r,
  &Z80_ins_FD_7B_LD_r_r,   &Z80_ins_FD_7C_LD_r_r,   &Z80_ins_FD_7D_LD_r_r,   &Z80_ins_FD_7E_LD_r_irr,   &Z80_ins_FD_7F_LD_r_r,
  &Z80_ins_FD_80_ADD_a_r,   &Z80_ins_FD_81_ADD_a_r,   &Z80_ins_FD_82_ADD_a_r,   &Z80_ins_FD_83_ADD_a_r,   &Z80_ins_FD_84_ADD_a_r,
  &Z80_ins_FD_85_ADD_a_r,   &Z80_ins_FD_86_ADD_a_irr,   &Z80_ins_FD_87_ADD_a_r,   &Z80_ins_FD_88_ADC_a_r,   &Z80_ins_FD_89_ADC_a_r,
  &Z80_ins_FD_8A_ADC_a_r,   &Z80_ins_FD_8B_ADC_a_r,   &Z80_ins_FD_8C_ADC_a_r,   &Z80_ins_FD_8D_ADC_a_r,   &Z80_ins_FD_8E_ADC_a_irr,
  &Z80_ins_FD_8F_ADC_a_r,   &Z80_ins_FD_90_SUB_a_r,   &Z80_ins_FD_91_SUB_a_r,   &Z80_ins_FD_92_SUB_a_r,   &Z80_ins_FD_93_SUB_a_r,
  &Z80_ins_FD_94_SUB_a_r,   &Z80_ins_FD_95_SUB_a_r,   &Z80_ins_FD_96_SUB_a_irr,   &Z80_ins_FD_97_SUB_a_r,   &Z80_ins_FD_98_SBC_a_r,
  &Z80_ins_FD_99_SBC_a_r,   &Z80_ins_FD_9A_SBC_a_r,   &Z80_ins_FD_9B_SBC_a_r,   &Z80_ins_FD_9C_SBC_a_r,   &Z80_ins_FD_9D_SBC_a_r,
  &Z80_ins_FD_9E_SBC_a_irr,   &Z80_ins_FD_9F_SBC_a_r,   &Z80_ins_FD_A0_AND_a_r,   &Z80_ins_FD_A1_AND_a_r,   &Z80_ins_FD_A2_AND_a_r,
  &Z80_ins_FD_A3_AND_a_r,   &Z80_ins_FD_A4_AND_a_r,   &Z80_ins_FD_A5_AND_a_r,   &Z80_ins_FD_A6_AND_a_irr,   &Z80_ins_FD_A7_AND_a_r,
  &Z80_ins_FD_A8_XOR_a_r,   &Z80_ins_FD_A9_XOR_a_r,   &Z80_ins_FD_AA_XOR_a_r,   &Z80_ins_FD_AB_XOR_a_r,   &Z80_ins_FD_AC_XOR_a_r,
  &Z80_ins_FD_AD_XOR_a_r,   &Z80_ins_FD_AE_XOR_a_irr,   &Z80_ins_FD_AF_XOR_a_r,   &Z80_ins_FD_B0_OR_a_r,   &Z80_ins_FD_B1_OR_a_r,
  &Z80_ins_FD_B2_OR_a_r,   &Z80_ins_FD_B3_OR_a_r,   &Z80_ins_FD_B4_OR_a_r,   &Z80_ins_FD_B5_OR_a_r,   &Z80_ins_FD_B6_OR_a_irr,
  &Z80_ins_FD_B7_OR_a_r,   &Z80_ins_FD_B8_CP_a_r,   &Z80_ins_FD_B9_CP_a_r,   &Z80_ins_FD_BA_CP_a_r,   &Z80_ins_FD_BB_CP_a_r,
  &Z80_ins_FD_BC_CP_a_r,   &Z80_ins_FD_BD_CP_a_r,   &Z80_ins_FD_BE_CP_a_irr,   &Z80_ins_FD_BF_CP_a_r,   &Z80_ins_FD_C0_RET_c,
  &Z80_ins_FD_C1_POP_rr,   &Z80_ins_FD_C2_JP_c_nn,   &Z80_ins_FD_C3_JP_c_nn,   &Z80_ins_FD_C4_CALL_c_nn,   &Z80_ins_FD_C5_PUSH_rr,
  &Z80_ins_FD_C6_ADD_a_n,   &Z80_ins_FD_C7_RST_o,   &Z80_ins_FD_C8_RET_c,   &Z80_ins_FD_C9_RET,   &Z80_ins_FD_CA_JP_c_nn,
  &Z80_ins_00_00_NOP,   &Z80_ins_FD_CC_CALL_c_nn,   &Z80_ins_FD_CD_CALL_nn,   &Z80_ins_FD_CE_ADC_a_n,   &Z80_ins_FD_CF_RST_o,
  &Z80_ins_FD_D0_RET_c,   &Z80_ins_FD_D1_POP_rr,   &Z80_ins_FD_D2_JP_c_nn,   &Z80_ins_FD_D3_OUT_in_a,   &Z80_ins_FD_D4_CALL_c_nn,
  &Z80_ins_FD_D5_PUSH_rr,   &Z80_ins_FD_D6_SUB_a_n,   &Z80_ins_FD_D7_RST_o,   &Z80_ins_FD_D8_RET_c,   &Z80_ins_FD_D9_EXX,
  &Z80_ins_FD_DA_JP_c_nn,   &Z80_ins_FD_DB_IN_a_in,   &Z80_ins_FD_DC_CALL_c_nn,   &Z80_ins_00_00_NOP,   &Z80_ins_FD_DE_SBC_a_n,
  &Z80_ins_FD_DF_RST_o,   &Z80_ins_FD_E0_RET_c,   &Z80_ins_FD_E1_POP_rr,   &Z80_ins_FD_E2_JP_c_nn,   &Z80_ins_FD_E3_EX_irr_rr,
  &Z80_ins_FD_E4_CALL_c_nn,   &Z80_ins_FD_E5_PUSH_rr,   &Z80_ins_FD_E6_AND_a_n,   &Z80_ins_FD_E7_RST_o,   &Z80_ins_FD_E8_RET_c,
  &Z80_ins_FD_E9_JP_rr,   &Z80_ins_FD_EA_JP_c_nn,   &Z80_ins_FD_EB_EX_rr_rr,   &Z80_ins_FD_EC_CALL_c_nn,   &Z80_ins_00_00_NOP,
  &Z80_ins_FD_EE_XOR_a_n,   &Z80_ins_FD_EF_RST_o,   &Z80_ins_FD_F0_RET_c,   &Z80_ins_FD_F1_POP_rr,   &Z80_ins_FD_F2_JP_c_nn,
  &Z80_ins_FD_F3_DI,   &Z80_ins_FD_F4_CALL_c_nn,   &Z80_ins_FD_F5_PUSH_rr,   &Z80_ins_FD_F6_OR_a_n,   &Z80_ins_FD_F7_RST_o,
  &Z80_ins_FD_F8_RET_c,   &Z80_ins_FD_F9_LD_sp_rr,   &Z80_ins_FD_FA_JP_c_nn,   &Z80_ins_FD_FB_EI,   &Z80_ins_FD_FC_CALL_c_nn,
  &Z80_ins_00_00_NOP,   &Z80_ins_FD_FE_CP_a_n,   &Z80_ins_FD_FF_RST_o,   &Z80_ins_FD_100_IRQ,   &Z80_ins_FD_101_RESET,
  &Z80_ins_DDCB_00_RLC_irr_r,   &Z80_ins_DDCB_01_RLC_irr_r,   &Z80_ins_DDCB_02_RLC_irr_r,   &Z80_ins_DDCB_03_RLC_irr_r,   &Z80_ins_DDCB_04_RLC_irr_r,
  &Z80_ins_DDCB_05_RLC_irr_r,   &Z80_ins_DDCB_06_RLC_irr_r,   &Z80_ins_DDCB_07_RLC_irr_r,   &Z80_ins_DDCB_08_RRC_irr_r,   &Z80_ins_DDCB_09_RRC_irr_r,
  &Z80_ins_DDCB_0A_RRC_irr_r,   &Z80_ins_DDCB_0B_RRC_irr_r,   &Z80_ins_DDCB_0C_RRC_irr_r,   &Z80_ins_DDCB_0D_RRC_irr_r,   &Z80_ins_DDCB_0E_RRC_irr_r,
  &Z80_ins_DDCB_0F_RRC_irr_r,   &Z80_ins_DDCB_10_RL_irr_r,   &Z80_ins_DDCB_11_RL_irr_r,   &Z80_ins_DDCB_12_RL_irr_r,   &Z80_ins_DDCB_13_RL_irr_r,
  &Z80_ins_DDCB_14_RL_irr_r,   &Z80_ins_DDCB_15_RL_irr_r,   &Z80_ins_DDCB_16_RL_irr_r,   &Z80_ins_DDCB_17_RL_irr_r,   &Z80_ins_DDCB_18_RR_irr_r,
  &Z80_ins_DDCB_19_RR_irr_r,   &Z80_ins_DDCB_1A_RR_irr_r,   &Z80_ins_DDCB_1B_RR_irr_r,   &Z80_ins_DDCB_1C_RR_irr_r,   &Z80_ins_DDCB_1D_RR_irr_r,
  &Z80_ins_DDCB_1E_RR_irr_r,   &Z80_ins_DDCB_1F_RR_irr_r,   &Z80_ins_DDCB_20_SLA_irr_r,   &Z80_ins_DDCB_21_SLA_irr_r,   &Z80_ins_DDCB_22_SLA_irr_r,
  &Z80_ins_DDCB_23_SLA_irr_r,   &Z80_ins_DDCB_24_SLA_irr_r,   &Z80_ins_DDCB_25_SLA_irr_r,   &Z80_ins_DDCB_26_SLA_irr_r,   &Z80_ins_DDCB_27_SLA_irr_r,
  &Z80_ins_DDCB_28_SRA_irr_r,   &Z80_ins_DDCB_29_SRA_irr_r,   &Z80_ins_DDCB_2A_SRA_irr_r,   &Z80_ins_DDCB_2B_SRA_irr_r,   &Z80_ins_DDCB_2C_SRA_irr_r,
  &Z80_ins_DDCB_2D_SRA_irr_r,   &Z80_ins_DDCB_2E_SRA_irr_r,   &Z80_ins_DDCB_2F_SRA_irr_r,   &Z80_ins_DDCB_30_SLL_irr_r,   &Z80_ins_DDCB_31_SLL_irr_r,
  &Z80_ins_DDCB_32_SLL_irr_r,   &Z80_ins_DDCB_33_SLL_irr_r,   &Z80_ins_DDCB_34_SLL_irr_r,   &Z80_ins_DDCB_35_SLL_irr_r,   &Z80_ins_DDCB_36_SLL_irr_r,
  &Z80_ins_DDCB_37_SLL_irr_r,   &Z80_ins_DDCB_38_SRL_irr_r,   &Z80_ins_DDCB_39_SRL_irr_r,   &Z80_ins_DDCB_3A_SRL_irr_r,   &Z80_ins_DDCB_3B_SRL_irr_r,
  &Z80_ins_DDCB_3C_SRL_irr_r,   &Z80_ins_DDCB_3D_SRL_irr_r,   &Z80_ins_DDCB_3E_SRL_irr_r,   &Z80_ins_DDCB_3F_SRL_irr_r,   &Z80_ins_DDCB_40_BIT_o_irr_r,
  &Z80_ins_DDCB_41_BIT_o_irr_r,   &Z80_ins_DDCB_42_BIT_o_irr_r,   &Z80_ins_DDCB_43_BIT_o_irr_r,   &Z80_ins_DDCB_44_BIT_o_irr_r,   &Z80_ins_DDCB_45_BIT_o_irr_r,
  &Z80_ins_DDCB_46_BIT_o_irr_r,   &Z80_ins_DDCB_47_BIT_o_irr_r,   &Z80_ins_DDCB_48_BIT_o_irr_r,   &Z80_ins_DDCB_49_BIT_o_irr_r,   &Z80_ins_DDCB_4A_BIT_o_irr_r,
  &Z80_ins_DDCB_4B_BIT_o_irr_r,   &Z80_ins_DDCB_4C_BIT_o_irr_r,   &Z80_ins_DDCB_4D_BIT_o_irr_r,   &Z80_ins_DDCB_4E_BIT_o_irr_r,   &Z80_ins_DDCB_4F_BIT_o_irr_r,
  &Z80_ins_DDCB_50_BIT_o_irr_r,   &Z80_ins_DDCB_51_BIT_o_irr_r,   &Z80_ins_DDCB_52_BIT_o_irr_r,   &Z80_ins_DDCB_53_BIT_o_irr_r,   &Z80_ins_DDCB_54_BIT_o_irr_r,
  &Z80_ins_DDCB_55_BIT_o_irr_r,   &Z80_ins_DDCB_56_BIT_o_irr_r,   &Z80_ins_DDCB_57_BIT_o_irr_r,   &Z80_ins_DDCB_58_BIT_o_irr_r,   &Z80_ins_DDCB_59_BIT_o_irr_r,
  &Z80_ins_DDCB_5A_BIT_o_irr_r,   &Z80_ins_DDCB_5B_BIT_o_irr_r,   &Z80_ins_DDCB_5C_BIT_o_irr_r,   &Z80_ins_DDCB_5D_BIT_o_irr_r,   &Z80_ins_DDCB_5E_BIT_o_irr_r,
  &Z80_ins_DDCB_5F_BIT_o_irr_r,   &Z80_ins_DDCB_60_BIT_o_irr_r,   &Z80_ins_DDCB_61_BIT_o_irr_r,   &Z80_ins_DDCB_62_BIT_o_irr_r,   &Z80_ins_DDCB_63_BIT_o_irr_r,
  &Z80_ins_DDCB_64_BIT_o_irr_r,   &Z80_ins_DDCB_65_BIT_o_irr_r,   &Z80_ins_DDCB_66_BIT_o_irr_r,   &Z80_ins_DDCB_67_BIT_o_irr_r,   &Z80_ins_DDCB_68_BIT_o_irr_r,
  &Z80_ins_DDCB_69_BIT_o_irr_r,   &Z80_ins_DDCB_6A_BIT_o_irr_r,   &Z80_ins_DDCB_6B_BIT_o_irr_r,   &Z80_ins_DDCB_6C_BIT_o_irr_r,   &Z80_ins_DDCB_6D_BIT_o_irr_r,
  &Z80_ins_DDCB_6E_BIT_o_irr_r,   &Z80_ins_DDCB_6F_BIT_o_irr_r,   &Z80_ins_DDCB_70_BIT_o_irr_r,   &Z80_ins_DDCB_71_BIT_o_irr_r,   &Z80_ins_DDCB_72_BIT_o_irr_r,
  &Z80_ins_DDCB_73_BIT_o_irr_r,   &Z80_ins_DDCB_74_BIT_o_irr_r,   &Z80_ins_DDCB_75_BIT_o_irr_r,   &Z80_ins_DDCB_76_BIT_o_irr_r,   &Z80_ins_DDCB_77_BIT_o_irr_r,
  &Z80_ins_DDCB_78_BIT_o_irr_r,   &Z80_ins_DDCB_79_BIT_o_irr_r,   &Z80_ins_DDCB_7A_BIT_o_irr_r,   &Z80_ins_DDCB_7B_BIT_o_irr_r,   &Z80_ins_DDCB_7C_BIT_o_irr_r,
  &Z80_ins_DDCB_7D_BIT_o_irr_r,   &Z80_ins_DDCB_7E_BIT_o_irr_r,   &Z80_ins_DDCB_7F_BIT_o_irr_r,   &Z80_ins_DDCB_80_RES_o_irr_r,   &Z80_ins_DDCB_81_RES_o_irr_r,
  &Z80_ins_DDCB_82_RES_o_irr_r,   &Z80_ins_DDCB_83_RES_o_irr_r,   &Z80_ins_DDCB_84_RES_o_irr_r,   &Z80_ins_DDCB_85_RES_o_irr_r,   &Z80_ins_DDCB_86_RES_o_irr_r,
  &Z80_ins_DDCB_87_RES_o_irr_r,   &Z80_ins_DDCB_88_RES_o_irr_r,   &Z80_ins_DDCB_89_RES_o_irr_r,   &Z80_ins_DDCB_8A_RES_o_irr_r,   &Z80_ins_DDCB_8B_RES_o_irr_r,
  &Z80_ins_DDCB_8C_RES_o_irr_r,   &Z80_ins_DDCB_8D_RES_o_irr_r,   &Z80_ins_DDCB_8E_RES_o_irr_r,   &Z80_ins_DDCB_8F_RES_o_irr_r,   &Z80_ins_DDCB_90_RES_o_irr_r,
  &Z80_ins_DDCB_91_RES_o_irr_r,   &Z80_ins_DDCB_92_RES_o_irr_r,   &Z80_ins_DDCB_93_RES_o_irr_r,   &Z80_ins_DDCB_94_RES_o_irr_r,   &Z80_ins_DDCB_95_RES_o_irr_r,
  &Z80_ins_DDCB_96_RES_o_irr_r,   &Z80_ins_DDCB_97_RES_o_irr_r,   &Z80_ins_DDCB_98_RES_o_irr_r,   &Z80_ins_DDCB_99_RES_o_irr_r,   &Z80_ins_DDCB_9A_RES_o_irr_r,
  &Z80_ins_DDCB_9B_RES_o_irr_r,   &Z80_ins_DDCB_9C_RES_o_irr_r,   &Z80_ins_DDCB_9D_RES_o_irr_r,   &Z80_ins_DDCB_9E_RES_o_irr_r,   &Z80_ins_DDCB_9F_RES_o_irr_r,
  &Z80_ins_DDCB_A0_RES_o_irr_r,   &Z80_ins_DDCB_A1_RES_o_irr_r,   &Z80_ins_DDCB_A2_RES_o_irr_r,   &Z80_ins_DDCB_A3_RES_o_irr_r,   &Z80_ins_DDCB_A4_RES_o_irr_r,
  &Z80_ins_DDCB_A5_RES_o_irr_r,   &Z80_ins_DDCB_A6_RES_o_irr_r,   &Z80_ins_DDCB_A7_RES_o_irr_r,   &Z80_ins_DDCB_A8_RES_o_irr_r,   &Z80_ins_DDCB_A9_RES_o_irr_r,
  &Z80_ins_DDCB_AA_RES_o_irr_r,   &Z80_ins_DDCB_AB_RES_o_irr_r,   &Z80_ins_DDCB_AC_RES_o_irr_r,   &Z80_ins_DDCB_AD_RES_o_irr_r,   &Z80_ins_DDCB_AE_RES_o_irr_r,
  &Z80_ins_DDCB_AF_RES_o_irr_r,   &Z80_ins_DDCB_B0_RES_o_irr_r,   &Z80_ins_DDCB_B1_RES_o_irr_r,   &Z80_ins_DDCB_B2_RES_o_irr_r,   &Z80_ins_DDCB_B3_RES_o_irr_r,
  &Z80_ins_DDCB_B4_RES_o_irr_r,   &Z80_ins_DDCB_B5_RES_o_irr_r,   &Z80_ins_DDCB_B6_RES_o_irr_r,   &Z80_ins_DDCB_B7_RES_o_irr_r,   &Z80_ins_DDCB_B8_RES_o_irr_r,
  &Z80_ins_DDCB_B9_RES_o_irr_r,   &Z80_ins_DDCB_BA_RES_o_irr_r,   &Z80_ins_DDCB_BB_RES_o_irr_r,   &Z80_ins_DDCB_BC_RES_o_irr_r,   &Z80_ins_DDCB_BD_RES_o_irr_r,
  &Z80_ins_DDCB_BE_RES_o_irr_r,   &Z80_ins_DDCB_BF_RES_o_irr_r,   &Z80_ins_DDCB_C0_SET_o_irr_r,   &Z80_ins_DDCB_C1_SET_o_irr_r,   &Z80_ins_DDCB_C2_SET_o_irr_r,
  &Z80_ins_DDCB_C3_SET_o_irr_r,   &Z80_ins_DDCB_C4_SET_o_irr_r,   &Z80_ins_DDCB_C5_SET_o_irr_r,   &Z80_ins_DDCB_C6_SET_o_irr_r,   &Z80_ins_DDCB_C7_SET_o_irr_r,
  &Z80_ins_DDCB_C8_SET_o_irr_r,   &Z80_ins_DDCB_C9_SET_o_irr_r,   &Z80_ins_DDCB_CA_SET_o_irr_r,   &Z80_ins_DDCB_CB_SET_o_irr_r,   &Z80_ins_DDCB_CC_SET_o_irr_r,
  &Z80_ins_DDCB_CD_SET_o_irr_r,   &Z80_ins_DDCB_CE_SET_o_irr_r,   &Z80_ins_DDCB_CF_SET_o_irr_r,   &Z80_ins_DDCB_D0_SET_o_irr_r,   &Z80_ins_DDCB_D1_SET_o_irr_r,
  &Z80_ins_DDCB_D2_SET_o_irr_r,   &Z80_ins_DDCB_D3_SET_o_irr_r,   &Z80_ins_DDCB_D4_SET_o_irr_r,   &Z80_ins_DDCB_D5_SET_o_irr_r,   &Z80_ins_DDCB_D6_SET_o_irr_r,
  &Z80_ins_DDCB_D7_SET_o_irr_r,   &Z80_ins_DDCB_D8_SET_o_irr_r,   &Z80_ins_DDCB_D9_SET_o_irr_r,   &Z80_ins_DDCB_DA_SET_o_irr_r,   &Z80_ins_DDCB_DB_SET_o_irr_r,
  &Z80_ins_DDCB_DC_SET_o_irr_r,   &Z80_ins_DDCB_DD_SET_o_irr_r,   &Z80_ins_DDCB_DE_SET_o_irr_r,   &Z80_ins_DDCB_DF_SET_o_irr_r,   &Z80_ins_DDCB_E0_SET_o_irr_r,
  &Z80_ins_DDCB_E1_SET_o_irr_r,   &Z80_ins_DDCB_E2_SET_o_irr_r,   &Z80_ins_DDCB_E3_SET_o_irr_r,   &Z80_ins_DDCB_E4_SET_o_irr_r,   &Z80_ins_DDCB_E5_SET_o_irr_r,
  &Z80_ins_DDCB_E6_SET_o_irr_r,   &Z80_ins_DDCB_E7_SET_o_irr_r,   &Z80_ins_DDCB_E8_SET_o_irr_r,   &Z80_ins_DDCB_E9_SET_o_irr_r,   &Z80_ins_DDCB_EA_SET_o_irr_r,
  &Z80_ins_DDCB_EB_SET_o_irr_r,   &Z80_ins_DDCB_EC_SET_o_irr_r,   &Z80_ins_DDCB_ED_SET_o_irr_r,   &Z80_ins_DDCB_EE_SET_o_irr_r,   &Z80_ins_DDCB_EF_SET_o_irr_r,
  &Z80_ins_DDCB_F0_SET_o_irr_r,   &Z80_ins_DDCB_F1_SET_o_irr_r,   &Z80_ins_DDCB_F2_SET_o_irr_r,   &Z80_ins_DDCB_F3_SET_o_irr_r,   &Z80_ins_DDCB_F4_SET_o_irr_r,
  &Z80_ins_DDCB_F5_SET_o_irr_r,   &Z80_ins_DDCB_F6_SET_o_irr_r,   &Z80_ins_DDCB_F7_SET_o_irr_r,   &Z80_ins_DDCB_F8_SET_o_irr_r,   &Z80_ins_DDCB_F9_SET_o_irr_r,
  &Z80_ins_DDCB_FA_SET_o_irr_r,   &Z80_ins_DDCB_FB_SET_o_irr_r,   &Z80_ins_DDCB_FC_SET_o_irr_r,   &Z80_ins_DDCB_FD_SET_o_irr_r,   &Z80_ins_DDCB_FE_SET_o_irr_r,
  &Z80_ins_DDCB_FF_SET_o_irr_r,   &Z80_ins_00_00_NOP,   &Z80_ins_00_00_NOP,   &Z80_ins_FDCB_00_RLC_irr_r,   &Z80_ins_FDCB_01_RLC_irr_r,
  &Z80_ins_FDCB_02_RLC_irr_r,   &Z80_ins_FDCB_03_RLC_irr_r,   &Z80_ins_FDCB_04_RLC_irr_r,   &Z80_ins_FDCB_05_RLC_irr_r,   &Z80_ins_FDCB_06_RLC_irr_r,
  &Z80_ins_FDCB_07_RLC_irr_r,   &Z80_ins_FDCB_08_RRC_irr_r,   &Z80_ins_FDCB_09_RRC_irr_r,   &Z80_ins_FDCB_0A_RRC_irr_r,   &Z80_ins_FDCB_0B_RRC_irr_r,
  &Z80_ins_FDCB_0C_RRC_irr_r,   &Z80_ins_FDCB_0D_RRC_irr_r,   &Z80_ins_FDCB_0E_RRC_irr_r,   &Z80_ins_FDCB_0F_RRC_irr_r,   &Z80_ins_FDCB_10_RL_irr_r,
  &Z80_ins_FDCB_11_RL_irr_r,   &Z80_ins_FDCB_12_RL_irr_r,   &Z80_ins_FDCB_13_RL_irr_r,   &Z80_ins_FDCB_14_RL_irr_r,   &Z80_ins_FDCB_15_RL_irr_r,
  &Z80_ins_FDCB_16_RL_irr_r,   &Z80_ins_FDCB_17_RL_irr_r,   &Z80_ins_FDCB_18_RR_irr_r,   &Z80_ins_FDCB_19_RR_irr_r,   &Z80_ins_FDCB_1A_RR_irr_r,
  &Z80_ins_FDCB_1B_RR_irr_r,   &Z80_ins_FDCB_1C_RR_irr_r,   &Z80_ins_FDCB_1D_RR_irr_r,   &Z80_ins_FDCB_1E_RR_irr_r,   &Z80_ins_FDCB_1F_RR_irr_r,
  &Z80_ins_FDCB_20_SLA_irr_r,   &Z80_ins_FDCB_21_SLA_irr_r,   &Z80_ins_FDCB_22_SLA_irr_r,   &Z80_ins_FDCB_23_SLA_irr_r,   &Z80_ins_FDCB_24_SLA_irr_r,
  &Z80_ins_FDCB_25_SLA_irr_r,   &Z80_ins_FDCB_26_SLA_irr_r,   &Z80_ins_FDCB_27_SLA_irr_r,   &Z80_ins_FDCB_28_SRA_irr_r,   &Z80_ins_FDCB_29_SRA_irr_r,
  &Z80_ins_FDCB_2A_SRA_irr_r,   &Z80_ins_FDCB_2B_SRA_irr_r,   &Z80_ins_FDCB_2C_SRA_irr_r,   &Z80_ins_FDCB_2D_SRA_irr_r,   &Z80_ins_FDCB_2E_SRA_irr_r,
  &Z80_ins_FDCB_2F_SRA_irr_r,   &Z80_ins_FDCB_30_SLL_irr_r,   &Z80_ins_FDCB_31_SLL_irr_r,   &Z80_ins_FDCB_32_SLL_irr_r,   &Z80_ins_FDCB_33_SLL_irr_r,
  &Z80_ins_FDCB_34_SLL_irr_r,   &Z80_ins_FDCB_35_SLL_irr_r,   &Z80_ins_FDCB_36_SLL_irr_r,   &Z80_ins_FDCB_37_SLL_irr_r,   &Z80_ins_FDCB_38_SRL_irr_r,
  &Z80_ins_FDCB_39_SRL_irr_r,   &Z80_ins_FDCB_3A_SRL_irr_r,   &Z80_ins_FDCB_3B_SRL_irr_r,   &Z80_ins_FDCB_3C_SRL_irr_r,   &Z80_ins_FDCB_3D_SRL_irr_r,
  &Z80_ins_FDCB_3E_SRL_irr_r,   &Z80_ins_FDCB_3F_SRL_irr_r,   &Z80_ins_FDCB_40_BIT_o_irr_r,   &Z80_ins_FDCB_41_BIT_o_irr_r,   &Z80_ins_FDCB_42_BIT_o_irr_r,
  &Z80_ins_FDCB_43_BIT_o_irr_r,   &Z80_ins_FDCB_44_BIT_o_irr_r,   &Z80_ins_FDCB_45_BIT_o_irr_r,   &Z80_ins_FDCB_46_BIT_o_irr_r,   &Z80_ins_FDCB_47_BIT_o_irr_r,
  &Z80_ins_FDCB_48_BIT_o_irr_r,   &Z80_ins_FDCB_49_BIT_o_irr_r,   &Z80_ins_FDCB_4A_BIT_o_irr_r,   &Z80_ins_FDCB_4B_BIT_o_irr_r,   &Z80_ins_FDCB_4C_BIT_o_irr_r,
  &Z80_ins_FDCB_4D_BIT_o_irr_r,   &Z80_ins_FDCB_4E_BIT_o_irr_r,   &Z80_ins_FDCB_4F_BIT_o_irr_r,   &Z80_ins_FDCB_50_BIT_o_irr_r,   &Z80_ins_FDCB_51_BIT_o_irr_r,
  &Z80_ins_FDCB_52_BIT_o_irr_r,   &Z80_ins_FDCB_53_BIT_o_irr_r,   &Z80_ins_FDCB_54_BIT_o_irr_r,   &Z80_ins_FDCB_55_BIT_o_irr_r,   &Z80_ins_FDCB_56_BIT_o_irr_r,
  &Z80_ins_FDCB_57_BIT_o_irr_r,   &Z80_ins_FDCB_58_BIT_o_irr_r,   &Z80_ins_FDCB_59_BIT_o_irr_r,   &Z80_ins_FDCB_5A_BIT_o_irr_r,   &Z80_ins_FDCB_5B_BIT_o_irr_r,
  &Z80_ins_FDCB_5C_BIT_o_irr_r,   &Z80_ins_FDCB_5D_BIT_o_irr_r,   &Z80_ins_FDCB_5E_BIT_o_irr_r,   &Z80_ins_FDCB_5F_BIT_o_irr_r,   &Z80_ins_FDCB_60_BIT_o_irr_r,
  &Z80_ins_FDCB_61_BIT_o_irr_r,   &Z80_ins_FDCB_62_BIT_o_irr_r,   &Z80_ins_FDCB_63_BIT_o_irr_r,   &Z80_ins_FDCB_64_BIT_o_irr_r,   &Z80_ins_FDCB_65_BIT_o_irr_r,
  &Z80_ins_FDCB_66_BIT_o_irr_r,   &Z80_ins_FDCB_67_BIT_o_irr_r,   &Z80_ins_FDCB_68_BIT_o_irr_r,   &Z80_ins_FDCB_69_BIT_o_irr_r,   &Z80_ins_FDCB_6A_BIT_o_irr_r,
  &Z80_ins_FDCB_6B_BIT_o_irr_r,   &Z80_ins_FDCB_6C_BIT_o_irr_r,   &Z80_ins_FDCB_6D_BIT_o_irr_r,   &Z80_ins_FDCB_6E_BIT_o_irr_r,   &Z80_ins_FDCB_6F_BIT_o_irr_r,
  &Z80_ins_FDCB_70_BIT_o_irr_r,   &Z80_ins_FDCB_71_BIT_o_irr_r,   &Z80_ins_FDCB_72_BIT_o_irr_r,   &Z80_ins_FDCB_73_BIT_o_irr_r,   &Z80_ins_FDCB_74_BIT_o_irr_r,
  &Z80_ins_FDCB_75_BIT_o_irr_r,   &Z80_ins_FDCB_76_BIT_o_irr_r,   &Z80_ins_FDCB_77_BIT_o_irr_r,   &Z80_ins_FDCB_78_BIT_o_irr_r,   &Z80_ins_FDCB_79_BIT_o_irr_r,
  &Z80_ins_FDCB_7A_BIT_o_irr_r,   &Z80_ins_FDCB_7B_BIT_o_irr_r,   &Z80_ins_FDCB_7C_BIT_o_irr_r,   &Z80_ins_FDCB_7D_BIT_o_irr_r,   &Z80_ins_FDCB_7E_BIT_o_irr_r,
  &Z80_ins_FDCB_7F_BIT_o_irr_r,   &Z80_ins_FDCB_80_RES_o_irr_r,   &Z80_ins_FDCB_81_RES_o_irr_r,   &Z80_ins_FDCB_82_RES_o_irr_r,   &Z80_ins_FDCB_83_RES_o_irr_r,
  &Z80_ins_FDCB_84_RES_o_irr_r,   &Z80_ins_FDCB_85_RES_o_irr_r,   &Z80_ins_FDCB_86_RES_o_irr_r,   &Z80_ins_FDCB_87_RES_o_irr_r,   &Z80_ins_FDCB_88_RES_o_irr_r,
  &Z80_ins_FDCB_89_RES_o_irr_r,   &Z80_ins_FDCB_8A_RES_o_irr_r,   &Z80_ins_FDCB_8B_RES_o_irr_r,   &Z80_ins_FDCB_8C_RES_o_irr_r,   &Z80_ins_FDCB_8D_RES_o_irr_r,
  &Z80_ins_FDCB_8E_RES_o_irr_r,   &Z80_ins_FDCB_8F_RES_o_irr_r,   &Z80_ins_FDCB_90_RES_o_irr_r,   &Z80_ins_FDCB_91_RES_o_irr_r,   &Z80_ins_FDCB_92_RES_o_irr_r,
  &Z80_ins_FDCB_93_RES_o_irr_r,   &Z80_ins_FDCB_94_RES_o_irr_r,   &Z80_ins_FDCB_95_RES_o_irr_r,   &Z80_ins_FDCB_96_RES_o_irr_r,   &Z80_ins_FDCB_97_RES_o_irr_r,
  &Z80_ins_FDCB_98_RES_o_irr_r,   &Z80_ins_FDCB_99_RES_o_irr_r,   &Z80_ins_FDCB_9A_RES_o_irr_r,   &Z80_ins_FDCB_9B_RES_o_irr_r,   &Z80_ins_FDCB_9C_RES_o_irr_r,
  &Z80_ins_FDCB_9D_RES_o_irr_r,   &Z80_ins_FDCB_9E_RES_o_irr_r,   &Z80_ins_FDCB_9F_RES_o_irr_r,   &Z80_ins_FDCB_A0_RES_o_irr_r,   &Z80_ins_FDCB_A1_RES_o_irr_r,
  &Z80_ins_FDCB_A2_RES_o_irr_r,   &Z80_ins_FDCB_A3_RES_o_irr_r,   &Z80_ins_FDCB_A4_RES_o_irr_r,   &Z80_ins_FDCB_A5_RES_o_irr_r,   &Z80_ins_FDCB_A6_RES_o_irr_r,
  &Z80_ins_FDCB_A7_RES_o_irr_r,   &Z80_ins_FDCB_A8_RES_o_irr_r,   &Z80_ins_FDCB_A9_RES_o_irr_r,   &Z80_ins_FDCB_AA_RES_o_irr_r,   &Z80_ins_FDCB_AB_RES_o_irr_r,
  &Z80_ins_FDCB_AC_RES_o_irr_r,   &Z80_ins_FDCB_AD_RES_o_irr_r,   &Z80_ins_FDCB_AE_RES_o_irr_r,   &Z80_ins_FDCB_AF_RES_o_irr_r,   &Z80_ins_FDCB_B0_RES_o_irr_r,
  &Z80_ins_FDCB_B1_RES_o_irr_r,   &Z80_ins_FDCB_B2_RES_o_irr_r,   &Z80_ins_FDCB_B3_RES_o_irr_r,   &Z80_ins_FDCB_B4_RES_o_irr_r,   &Z80_ins_FDCB_B5_RES_o_irr_r,
  &Z80_ins_FDCB_B6_RES_o_irr_r,   &Z80_ins_FDCB_B7_RES_o_irr_r,   &Z80_ins_FDCB_B8_RES_o_irr_r,   &Z80_ins_FDCB_B9_RES_o_irr_r,   &Z80_ins_FDCB_BA_RES_o_irr_r,
  &Z80_ins_FDCB_BB_RES_o_irr_r,   &Z80_ins_FDCB_BC_RES_o_irr_r,   &Z80_ins_FDCB_BD_RES_o_irr_r,   &Z80_ins_FDCB_BE_RES_o_irr_r,   &Z80_ins_FDCB_BF_RES_o_irr_r,
  &Z80_ins_FDCB_C0_SET_o_irr_r,   &Z80_ins_FDCB_C1_SET_o_irr_r,   &Z80_ins_FDCB_C2_SET_o_irr_r,   &Z80_ins_FDCB_C3_SET_o_irr_r,   &Z80_ins_FDCB_C4_SET_o_irr_r,
  &Z80_ins_FDCB_C5_SET_o_irr_r,   &Z80_ins_FDCB_C6_SET_o_irr_r,   &Z80_ins_FDCB_C7_SET_o_irr_r,   &Z80_ins_FDCB_C8_SET_o_irr_r,   &Z80_ins_FDCB_C9_SET_o_irr_r,
  &Z80_ins_FDCB_CA_SET_o_irr_r,   &Z80_ins_FDCB_CB_SET_o_irr_r,   &Z80_ins_FDCB_CC_SET_o_irr_r,   &Z80_ins_FDCB_CD_SET_o_irr_r,   &Z80_ins_FDCB_CE_SET_o_irr_r,
  &Z80_ins_FDCB_CF_SET_o_irr_r,   &Z80_ins_FDCB_D0_SET_o_irr_r,   &Z80_ins_FDCB_D1_SET_o_irr_r,   &Z80_ins_FDCB_D2_SET_o_irr_r,   &Z80_ins_FDCB_D3_SET_o_irr_r,
  &Z80_ins_FDCB_D4_SET_o_irr_r,   &Z80_ins_FDCB_D5_SET_o_irr_r,   &Z80_ins_FDCB_D6_SET_o_irr_r,   &Z80_ins_FDCB_D7_SET_o_irr_r,   &Z80_ins_FDCB_D8_SET_o_irr_r,
  &Z80_ins_FDCB_D9_SET_o_irr_r,   &Z80_ins_FDCB_DA_SET_o_irr_r,   &Z80_ins_FDCB_DB_SET_o_irr_r,   &Z80_ins_FDCB_DC_SET_o_irr_r,   &Z80_ins_FDCB_DD_SET_o_irr_r,
  &Z80_ins_FDCB_DE_SET_o_irr_r,   &Z80_ins_FDCB_DF_SET_o_irr_r,   &Z80_ins_FDCB_E0_SET_o_irr_r,   &Z80_ins_FDCB_E1_SET_o_irr_r,   &Z80_ins_FDCB_E2_SET_o_irr_r,
  &Z80_ins_FDCB_E3_SET_o_irr_r,   &Z80_ins_FDCB_E4_SET_o_irr_r,   &Z80_ins_FDCB_E5_SET_o_irr_r,   &Z80_ins_FDCB_E6_SET_o_irr_r,   &Z80_ins_FDCB_E7_SET_o_irr_r,
  &Z80_ins_FDCB_E8_SET_o_irr_r,   &Z80_ins_FDCB_E9_SET_o_irr_r,   &Z80_ins_FDCB_EA_SET_o_irr_r,   &Z80_ins_FDCB_EB_SET_o_irr_r,   &Z80_ins_FDCB_EC_SET_o_irr_r,
  &Z80_ins_FDCB_ED_SET_o_irr_r,   &Z80_ins_FDCB_EE_SET_o_irr_r,   &Z80_ins_FDCB_EF_SET_o_irr_r,   &Z80_ins_FDCB_F0_SET_o_irr_r,   &Z80_ins_FDCB_F1_SET_o_irr_r,
  &Z80_ins_FDCB_F2_SET_o_irr_r,   &Z80_ins_FDCB_F3_SET_o_irr_r,   &Z80_ins_FDCB_F4_SET_o_irr_r,   &Z80_ins_FDCB_F5_SET_o_irr_r,   &Z80_ins_FDCB_F6_SET_o_irr_r,
  &Z80_ins_FDCB_F7_SET_o_irr_r,   &Z80_ins_FDCB_F8_SET_o_irr_r,   &Z80_ins_FDCB_F9_SET_o_irr_r,   &Z80_ins_FDCB_FA_SET_o_irr_r,   &Z80_ins_FDCB_FB_SET_o_irr_r,
  &Z80_ins_FDCB_FC_SET_o_irr_r,   &Z80_ins_FDCB_FD_SET_o_irr_r,   &Z80_ins_FDCB_FE_SET_o_irr_r,   &Z80_ins_FDCB_FF_SET_o_irr_r,   &Z80_ins_00_00_NOP,
  &Z80_ins_00_00_NOP, 
};
