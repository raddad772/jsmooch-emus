#include "helpers/int.h"
#include "sm83.h"
#include "sm83_opcodes.h"

// This file auto-generated by sm83_core_generator.js in JSMoo

void SM83_ins_00_NOP(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            //NOPE!
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_01_LD16_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TR = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs->RR = pins->D;
            regs->TR |= (regs->RR << 8);
            regs->B = (regs->TR & 0xFF00) >> 8;
            regs->C = regs->TR & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_02_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_03_INC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = (regs->B << 8) | regs->C;
            a = (a + 1) & 0xFFFF;
            regs->B = (a & 0xFF00) >> 8;
            regs->C = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_04_INC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = ((regs->B) + 1) & 0xFF;
            regs->F.H = +(((regs->B) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_05_DEC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = ((regs->B) - 1) & 0xFF;
            regs->F.H = +(((regs->B) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_06_LD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->B = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_07_RLCA(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = ((regs->A << 1) | (regs->A >> 7)) & 0xFF;
            regs->F.C = regs->A & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            regs->F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_08_LD16_addr_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { // Do write
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            pins->Addr = (regs->TA);
            pins->D = regs->SP & 0xFF;
            pins->RD = 0; pins->WR = 1;
            break; }
        case 4: { // Do write
            pins->Addr = ((regs->TA + 1) & 0xFFFF);
            pins->D = (regs->SP & 0xFF00) >> 8;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_09_ADD16_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // idle
            u32 target = (regs->H << 8) | regs->L;
            u32 source = (regs->B << 8) | regs->C;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs->H = (x & 0xFF00) >> 8;
            regs->L = x & 0xFF;
            regs->F.C = +(x > 0xFFFF);
            regs->F.H = +(y > 0x0FFF);
            regs->F.N = 0;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_0A_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->B << 8) | regs->C;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_0B_DEC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = (regs->B << 8) | regs->C;
            a = (a - 1) & 0xFFFF;
            regs->B = (a & 0xFF00) >> 8;
            regs->C = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_0C_INC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = ((regs->C) + 1) & 0xFF;
            regs->F.H = +(((regs->C) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_0D_DEC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = ((regs->C) - 1) & 0xFF;
            regs->F.H = +(((regs->C) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_0E_LD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->C = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_0F_RRCA(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = (((regs->A) << 7) | ((regs->A) >> 1)) & 0xFF;
            regs->F.C = ((regs->A) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            regs->F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_10_STOP(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->STP = 1;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: {
            if (regs->STP) regs->TCU--;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_11_LD16_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TR = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs->RR = pins->D;
            regs->TR |= (regs->RR << 8);
            regs->D = (regs->TR & 0xFF00) >> 8;
            regs->E = regs->TR & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_12_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->D << 8) | regs->E;
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_13_INC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = (regs->D << 8) | regs->E;
            a = (a + 1) & 0xFFFF;
            regs->D = (a & 0xFF00) >> 8;
            regs->E = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_14_INC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = ((regs->D) + 1) & 0xFF;
            regs->F.H = +(((regs->D) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_15_DEC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = ((regs->D) - 1) & 0xFF;
            regs->F.H = +(((regs->D) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_16_LD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->D = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_17_RLA(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->A) & 0x80) >> 7;
            regs->A = (((regs->A) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            regs->F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_18_JR_cond_rel(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(1)) { regs->TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs->TA = pins->D;
            regs->PC = ((i32)(i8)regs->TA + regs->PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_19_ADD16_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // idle
            u32 target = (regs->H << 8) | regs->L;
            u32 source = (regs->D << 8) | regs->E;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs->H = (x & 0xFF00) >> 8;
            regs->L = x & 0xFF;
            regs->F.C = +(x > 0xFFFF);
            regs->F.H = +(y > 0x0FFF);
            regs->F.N = 0;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_1A_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->D << 8) | regs->E;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_1B_DEC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = (regs->D << 8) | regs->E;
            a = (a - 1) & 0xFFFF;
            regs->D = (a & 0xFF00) >> 8;
            regs->E = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_1C_INC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = ((regs->E) + 1) & 0xFF;
            regs->F.H = +(((regs->E) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_1D_DEC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = ((regs->E) - 1) & 0xFF;
            regs->F.H = +(((regs->E) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_1E_LD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->E = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_1F_RRA(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->A) & 1;
            regs->A = ((regs->A) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            regs->F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_20_JR_cond_rel(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 0)) { regs->TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs->TA = pins->D;
            regs->PC = ((i32)(i8)regs->TA + regs->PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_21_LD16_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TR = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs->RR = pins->D;
            regs->TR |= (regs->RR << 8);
            regs->H = (regs->TR & 0xFF00) >> 8;
            regs->L = regs->TR & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_22_LD_ind_inc_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_23_INC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = (regs->H << 8) | regs->L;
            a = (a + 1) & 0xFFFF;
            regs->H = (a & 0xFF00) >> 8;
            regs->L = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_24_INC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = ((regs->H) + 1) & 0xFF;
            regs->F.H = +(((regs->H) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_25_DEC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = ((regs->H) - 1) & 0xFF;
            regs->F.H = +(((regs->H) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_26_LD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->H = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_27_DAA(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 a = regs->A;
            if (!regs->F.N) {
                if (regs->F.H || ((regs->A & 0x0F) > 0x09)) a += 0x06;
                if (regs->F.C || (regs->A > 0x99)) {
                    a += 0x60;
                    regs->F.C = 1;
                }
            } else {
                a -= (0x06 * regs->F.H);
                a -= (0x60 * regs->F.C);
            }
            regs->A = a & 0xFF;
            regs->F.H = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_28_JR_cond_rel(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 1)) { regs->TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs->TA = pins->D;
            regs->PC = ((i32)(i8)regs->TA + regs->PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_29_ADD16_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // idle
            u32 target = (regs->H << 8) | regs->L;
            u32 source = (regs->H << 8) | regs->L;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs->H = (x & 0xFF00) >> 8;
            regs->L = x & 0xFF;
            regs->F.C = +(x > 0xFFFF);
            regs->F.H = +(y > 0x0FFF);
            regs->F.N = 0;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_2A_LD_di_ind_inc(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            regs->TA = (regs->TA + 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_2B_DEC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = (regs->H << 8) | regs->L;
            a = (a - 1) & 0xFFFF;
            regs->H = (a & 0xFF00) >> 8;
            regs->L = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_2C_INC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = ((regs->L) + 1) & 0xFF;
            regs->F.H = +(((regs->L) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_2D_DEC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = ((regs->L) - 1) & 0xFF;
            regs->F.H = +(((regs->L) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_2E_LD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->L = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_2F_CPL(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A ^= 0xFF;
            regs->F.H = regs->F.N = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_30_JR_cond_rel(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 0)) { regs->TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs->TA = pins->D;
            regs->PC = ((i32)(i8)regs->TA + regs->PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_31_LD16_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TR = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs->RR = pins->D;
            regs->TR |= (regs->RR << 8);
            regs->SP = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_32_LD_ind_dec_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_33_INC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = regs->SP;
            a = (a + 1) & 0xFFFF;
            regs->SP = a;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_34_INC_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR = ((regs->TR) + 1) & 0xFF;
            regs->F.H = +(((regs->TR) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_35_DEC_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR = ((regs->TR) - 1) & 0xFF;
            regs->F.H = +(((regs->TR) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_36_LD_ind_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->H << 8) | regs->L;
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_37_SCF(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = 1;
            regs->F.H = regs->F.N = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_38_JR_cond_rel(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 1)) { regs->TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs->TA = pins->D;
            regs->PC = ((i32)(i8)regs->TA + regs->PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_39_ADD16_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // idle
            u32 target = (regs->H << 8) | regs->L;
            u32 source = regs->SP;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs->H = (x & 0xFF00) >> 8;
            regs->L = x & 0xFF;
            regs->F.C = +(x > 0xFFFF);
            regs->F.H = +(y > 0x0FFF);
            regs->F.N = 0;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_3A_LD_di_ind_dec(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            regs->TA = (regs->TA - 1) & 0xFFFF;
            regs->H = (regs->TA & 0xFF00) >> 8;
            regs->L = regs->TA & 0xFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_3B_DEC16_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            u32 a = regs->SP;
            a = (a - 1) & 0xFFFF;
            regs->SP = a;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_3C_INC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = ((regs->A) + 1) & 0xFF;
            regs->F.H = +(((regs->A) & 0x0F) == 0);
            regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_3D_DEC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = ((regs->A) - 1) & 0xFF;
            regs->F.H = +(((regs->A) & 0x0F) == 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_3E_LD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->A = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_3F_CCF(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C ^= 1;
            regs->F.H = regs->F.N = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_40_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_41_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_42_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_43_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_44_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_45_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_46_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->B = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_47_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_48_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_49_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_4A_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_4B_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_4C_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_4D_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_4E_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->C = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_4F_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_50_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_51_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_52_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_53_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_54_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_55_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_56_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_57_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_58_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_59_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_5A_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_5B_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_5C_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_5D_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_5E_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->E = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_5F_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_60_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_61_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_62_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_63_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_64_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_65_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_66_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->H = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_67_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_68_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_69_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_6A_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_6B_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_6C_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_6D_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_6E_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->L = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_6F_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_70_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->B;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_71_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->C;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_72_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->D;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_73_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->E;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_74_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->H;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_75_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->L;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_76_HALT(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            if ((!regs->IME) && (regs->interrupt_latch != 0)) regs->halt_bug = 1;
            regs->HLT = 1;
            if (regs->HLT) { regs->poll_IRQ = TRUE; regs->TCU--; }
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            //YOYOYO
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_77_LD_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_78_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->B;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_79_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->C;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_7A_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_7B_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->E;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_7C_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->H;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_7D_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_7E_LD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_7F_LD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_80_ADD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->B);
            u32 y = ((regs->A) & 0x0F) + ((regs->B) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_81_ADD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->C);
            u32 y = ((regs->A) & 0x0F) + ((regs->C) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_82_ADD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->D);
            u32 y = ((regs->A) & 0x0F) + ((regs->D) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_83_ADD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->E);
            u32 y = ((regs->A) & 0x0F) + ((regs->E) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_84_ADD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->H);
            u32 y = ((regs->A) & 0x0F) + ((regs->H) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_85_ADD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->L);
            u32 y = ((regs->A) & 0x0F) + ((regs->L) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_86_ADD_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = (regs->A) + (regs->TR);
            u32 y = ((regs->A) & 0x0F) + ((regs->TR) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_87_ADD_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->A);
            u32 y = ((regs->A) & 0x0F) + ((regs->A) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_88_ADC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->B) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->B) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_89_ADC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->C) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->C) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_8A_ADC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->D) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->D) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_8B_ADC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->E) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->E) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_8C_ADC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->H) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->H) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_8D_ADC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->L) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->L) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_8E_ADC_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = (regs->A) + (regs->TR) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->TR) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_8F_ADC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs->A) + (regs->A) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->A) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_90_SUB_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->B)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->B) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_91_SUB_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->C)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->C) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_92_SUB_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->D)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->D) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_93_SUB_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->E)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->E) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_94_SUB_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->H)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->H) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_95_SUB_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->L)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->L) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_96_SUB_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = ((regs->A) - (regs->TR)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->TR) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_97_SUB_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->A)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->A) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_98_SBC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->B) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->B) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_99_SBC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->C) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->C) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_9A_SBC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->D) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->D) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_9B_SBC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->E) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->E) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_9C_SBC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->H) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->H) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_9D_SBC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->L) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->L) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_9E_SBC_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = ((regs->A) - (regs->TR) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->TR) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_9F_SBC_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->A) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->A) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A0_AND_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) & (regs->B);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A1_AND_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) & (regs->C);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A2_AND_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) & (regs->D);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A3_AND_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) & (regs->E);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A4_AND_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) & (regs->H);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A5_AND_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) & (regs->L);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A6_AND_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->TR = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A7_AND_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) & (regs->A);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A8_XOR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) ^ (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_A9_XOR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) ^ (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_AA_XOR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) ^ (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_AB_XOR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) ^ (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_AC_XOR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) ^ (regs->H);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_AD_XOR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) ^ (regs->L);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_AE_XOR_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->TR = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_AF_XOR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) ^ (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B0_OR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) | (regs->B);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B1_OR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) | (regs->C);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B2_OR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) | (regs->D);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B3_OR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) | (regs->E);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B4_OR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) | (regs->H);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B5_OR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) | (regs->L);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B6_OR_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->TR = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B7_OR_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->TR = (regs->A) | (regs->A);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B8_CP_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->B)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->B) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_B9_CP_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->C)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->C) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_BA_CP_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->D)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->D) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_BB_CP_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->E)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->E) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_BC_CP_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->H)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->H) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_BD_CP_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->L)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->L) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_BE_CP_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = ((regs->A) - (regs->TR)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->TR) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_BF_CP_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs->A) - (regs->A)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->A) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_C0_RET_cond(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            if (!(regs->F.Z == 0)) { pins->RD = 0; pins->MRQ = 0; regs->TCU += 3; break; } // CHECKHERE
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs->TR = pins->D;
            regs->TA |= (regs->TR << 8);
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_C1_POP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->C = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs->B = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_C2_JP_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 0)) { regs->TCU++; }
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->PC = regs->TA;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_C3_JP_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_C4_CALL_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 0)) { regs->TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 5: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_C5_PUSH_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->B;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->C;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_C6_ADD_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = (regs->A) + (regs->TR);
            u32 y = ((regs->A) & 0x0F) + ((regs->TR) & 0x0F);
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_C7_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0000;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_C8_RET_cond(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            if (!(regs->F.Z == 1)) { pins->RD = 0; pins->MRQ = 0; regs->TCU += 3; break; } // CHECKHERE
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs->TR = pins->D;
            regs->TA |= (regs->TR << 8);
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_C9_RET(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 3: {
            regs->TR = pins->D;
            regs->TA |= (regs->TR << 8);
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_CA_JP_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 1)) { regs->TCU++; }
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->PC = regs->TA;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_CB_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_CC_CALL_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.Z == 1)) { regs->TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 5: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CD_CALL_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(1)) { regs->TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 5: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CE_ADC_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = (regs->A) + (regs->TR) + regs->F.C;
            u32 y = ((regs->A) & 0x0F) + ((regs->TR) & 0x0F) + regs->F.C;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 0;
            regs->TR = (x & 0xFF);
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CF_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0008;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_D0_RET_cond(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            if (!(regs->F.C == 0)) { pins->RD = 0; pins->MRQ = 0; regs->TCU += 3; break; } // CHECKHERE
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs->TR = pins->D;
            regs->TA |= (regs->TR << 8);
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_D1_POP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->E = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs->D = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_D2_JP_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 0)) { regs->TCU++; }
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->PC = regs->TA;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_D3_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_D4_CALL_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 0)) { regs->TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 5: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_D5_PUSH_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->D;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->E;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_D6_SUB_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = ((regs->A) - (regs->TR)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->TR) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_D7_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0010;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_D8_RET_cond(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            if (!(regs->F.C == 1)) { pins->RD = 0; pins->MRQ = 0; regs->TCU += 3; break; } // CHECKHERE
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            pins->RD = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs->TR = pins->D;
            regs->TA |= (regs->TR << 8);
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_D9_RETI(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 3: {
            regs->TR = pins->D;
            regs->TA |= (regs->TR << 8);
            regs->PC = regs->TA;
            regs->IME = 1;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_DA_JP_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 1)) { regs->TCU++; }
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->PC = regs->TA;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_DB_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_DC_CALL_cond_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!(regs->F.C == 1)) { regs->TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 4: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 5: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_DD_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_DE_SBC_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = ((regs->A) - (regs->TR) - regs->F.C) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->TR) &0x0F) - regs->F.C) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->TR = x & 0xFF;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_DF_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0018;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_E0_LDH_addr_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do write
            regs->TA = pins->D;
            regs->TA |= 0xFF00;
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_E1_POP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->L = pins->D;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs->H = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_E2_LDH_ind_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do write
            regs->TA = 0xFF00 | regs->C;
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_E3_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_E4_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_E5_PUSH_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->H;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->L;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_E6_AND_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->TR = (regs->A) & (regs->TR);
            regs->F.C = regs->F.N = 0;
            regs->F.H = 1;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_E7_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0020;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_E8_ADD_di_rel(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TR = pins->D;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 3: {
            u32 target = regs->SP;
            regs->F.C = +(((target & 0xFF) + regs->TR) > 0xFF);
            regs->F.H = +(((target & 0x0F) + (regs->TR & 0x0F)) > 0x0F);
            regs->F.N = regs->F.Z = 0;
            target = (target + (i32)(i8)regs->TR) & 0xFFFF;
            regs->SP = target;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_E9_JP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->PC = (regs->H << 8) | regs->L;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_EA_LD_addr_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { // Do write
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            pins->Addr = (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_EB_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_EC_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_ED_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_EE_XOR_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->TR = (regs->A) ^ (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_EF_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0028;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_F0_LDH_di_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            regs->TA |= 0xFF00;
            pins->Addr = (regs->TA);
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs->A = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_F1_POP_di_AF(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->SP);
            break; }
        case 2: { // Do read
            regs->TR = pins->D;
            SM83_regs_F_setbyte(&(regs->F), regs->TR & 0xF0);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            pins->Addr = (regs->SP);
            regs->SP = (regs->SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs->A = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_F2_LDH_di_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = 0xFF00 | regs->C;
            pins->Addr = (regs->TA);
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs->A = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_F3_DI(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->IME = 0;
            //console.log('DI!');
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_F4_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_F5_PUSH_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->A;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = SM83_regs_F_getbyte(&(regs->F));
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_F6_OR_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->TR = (regs->A) | (regs->TR);
            regs->F.C = regs->F.N = regs->F.H = 0;
            regs->F.Z = +((regs->TR) == 0);
            regs->A = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_F7_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0030;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_F8_LD_di_di_rel(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs->TR = pins->D;
            u32 source = regs->SP;
            regs->F.C = +(((source & 0xFF) + regs->TR) > 0xFF);
            regs->F.H = +(((source & 0x0F) + (regs->TR & 0x0F)) > 0x0F);
            regs->F.N = regs->F.Z = 0;
            source = (source + (i32)(i8)regs->TR) & 0xFFFF;
            regs->H = (source & 0xFF00) >> 8;
            regs->L = source & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_F9_LD16_di_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->H << 8) | regs->L;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_FA_LD_di_addr(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs->TA = pins->D;
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 3: { // Do read
            regs->RR = pins->D;
            regs->TA |= (regs->RR << 8);
            pins->Addr = (regs->TA);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            regs->A = pins->D;
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_FB_EI(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            //console.log('EI!');
            regs->IME_DELAY = 2;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_FC_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_FD_NONE(struct SM83_regs *regs, struct SM83_pins *pins)
{
}

void SM83_ins_FE_CP_di_da(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = (regs->PC);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            u32 x = ((regs->A) - (regs->TR)) & 0xFFFF;
            u32 y = (((regs->A) & 0x0F) - ((regs->TR) & 0x0F)) & 0xFFFF;
            regs->F.C = +(x > 0xFF);
            regs->F.H = +(y > 0x0F);
            regs->F.N = 1;
            regs->F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_FF_RST_imp(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = regs->PC & 0xFF;
            regs->PC = 0x0038;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_100_S_IRQ(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            regs->IME = 0;
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: {
            regs->PC = (regs->PC - 1) & 0xFFFF;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            break; }
        case 3: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF00) >> 8;
            regs->SP = (regs->SP - 1) & 0xFFFF;
            pins->WR = 1; pins->MRQ = 1;
            break; }
        case 4: { // Do write
            pins->Addr = (regs->SP);
            pins->D = (regs->PC & 0xFF);
            break; }
        case 5: {
            regs->PC = regs->IV;
            // Following is auto-generated code for instruction finish
            pins->WR = 0; pins->MRQ = 0;
            break; }
        case 6: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_101_RESET(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: {
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->MRQ = 1;
            break;
    }}
}

void SM83_ins_CB00_RLC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = ((regs->B << 1) | (regs->B >> 7)) & 0xFF;
            regs->F.C = regs->B & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB01_RLC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = ((regs->C << 1) | (regs->C >> 7)) & 0xFF;
            regs->F.C = regs->C & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB02_RLC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = ((regs->D << 1) | (regs->D >> 7)) & 0xFF;
            regs->F.C = regs->D & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB03_RLC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = ((regs->E << 1) | (regs->E >> 7)) & 0xFF;
            regs->F.C = regs->E & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB04_RLC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = ((regs->H << 1) | (regs->H >> 7)) & 0xFF;
            regs->F.C = regs->H & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB05_RLC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = ((regs->L << 1) | (regs->L >> 7)) & 0xFF;
            regs->F.C = regs->L & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB06_RLC_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR = ((regs->TR << 1) | (regs->TR >> 7)) & 0xFF;
            regs->F.C = regs->TR & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB07_RLC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = ((regs->A << 1) | (regs->A >> 7)) & 0xFF;
            regs->F.C = regs->A & 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB08_RRC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = (((regs->B) << 7) | ((regs->B) >> 1)) & 0xFF;
            regs->F.C = ((regs->B) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB09_RRC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = (((regs->C) << 7) | ((regs->C) >> 1)) & 0xFF;
            regs->F.C = ((regs->C) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB0A_RRC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = (((regs->D) << 7) | ((regs->D) >> 1)) & 0xFF;
            regs->F.C = ((regs->D) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB0B_RRC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = (((regs->E) << 7) | ((regs->E) >> 1)) & 0xFF;
            regs->F.C = ((regs->E) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB0C_RRC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = (((regs->H) << 7) | ((regs->H) >> 1)) & 0xFF;
            regs->F.C = ((regs->H) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB0D_RRC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = (((regs->L) << 7) | ((regs->L) >> 1)) & 0xFF;
            regs->F.C = ((regs->L) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB0E_RRC_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR = (((regs->TR) << 7) | ((regs->TR) >> 1)) & 0xFF;
            regs->F.C = ((regs->TR) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB0F_RRC_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = (((regs->A) << 7) | ((regs->A) >> 1)) & 0xFF;
            regs->F.C = ((regs->A) & 0x80) >> 7;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB10_RL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->B) & 0x80) >> 7;
            regs->B = (((regs->B) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB11_RL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->C) & 0x80) >> 7;
            regs->C = (((regs->C) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB12_RL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->D) & 0x80) >> 7;
            regs->D = (((regs->D) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB13_RL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->E) & 0x80) >> 7;
            regs->E = (((regs->E) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB14_RL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->H) & 0x80) >> 7;
            regs->H = (((regs->H) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB15_RL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->L) & 0x80) >> 7;
            regs->L = (((regs->L) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB16_RL_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            u32 carry = ((regs->TR) & 0x80) >> 7;
            regs->TR = (((regs->TR) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB17_RL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->A) & 0x80) >> 7;
            regs->A = (((regs->A) << 1) & 0xFE) | regs->F.C;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB18_RR_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->B) & 1;
            regs->B = ((regs->B) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB19_RR_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->C) & 1;
            regs->C = ((regs->C) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB1A_RR_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->D) & 1;
            regs->D = ((regs->D) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB1B_RR_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->E) & 1;
            regs->E = ((regs->E) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB1C_RR_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->H) & 1;
            regs->H = ((regs->H) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB1D_RR_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->L) & 1;
            regs->L = ((regs->L) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB1E_RR_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            u32 carry = (regs->TR) & 1;
            regs->TR = ((regs->TR) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB1F_RR_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->A) & 1;
            regs->A = ((regs->A) >> 1) | (regs->F.C << 7);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB20_SLA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->B) & 0x80) >> 7;
            regs->B = ((regs->B) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB21_SLA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->C) & 0x80) >> 7;
            regs->C = ((regs->C) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB22_SLA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->D) & 0x80) >> 7;
            regs->D = ((regs->D) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB23_SLA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->E) & 0x80) >> 7;
            regs->E = ((regs->E) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB24_SLA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->H) & 0x80) >> 7;
            regs->H = ((regs->H) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB25_SLA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->L) & 0x80) >> 7;
            regs->L = ((regs->L) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB26_SLA_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            u32 carry = ((regs->TR) & 0x80) >> 7;
            regs->TR = ((regs->TR) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB27_SLA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs->A) & 0x80) >> 7;
            regs->A = ((regs->A) << 1) & 0xFF;
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB28_SRA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->B) & 1;
            regs->B = ((regs->B) & 0x80) | ((regs->B) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB29_SRA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->C) & 1;
            regs->C = ((regs->C) & 0x80) | ((regs->C) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB2A_SRA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->D) & 1;
            regs->D = ((regs->D) & 0x80) | ((regs->D) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB2B_SRA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->E) & 1;
            regs->E = ((regs->E) & 0x80) | ((regs->E) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB2C_SRA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->H) & 1;
            regs->H = ((regs->H) & 0x80) | ((regs->H) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB2D_SRA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->L) & 1;
            regs->L = ((regs->L) & 0x80) | ((regs->L) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB2E_SRA_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            u32 carry = (regs->TR) & 1;
            regs->TR = ((regs->TR) & 0x80) | ((regs->TR) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB2F_SRA_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs->A) & 1;
            regs->A = ((regs->A) & 0x80) | ((regs->A) >> 1);
            regs->F.C = carry;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB30_SWAP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = (((regs->B) << 4) | ((regs->B) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB31_SWAP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = (((regs->C) << 4) | ((regs->C) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB32_SWAP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = (((regs->D) << 4) | ((regs->D) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB33_SWAP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = (((regs->E) << 4) | ((regs->E) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB34_SWAP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = (((regs->H) << 4) | ((regs->H) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB35_SWAP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = (((regs->L) << 4) | ((regs->L) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB36_SWAP_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR = (((regs->TR) << 4) | ((regs->TR) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB37_SWAP_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = (((regs->A) << 4) | ((regs->A) >> 4)) & 0xFF;
            regs->F.C = regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB38_SRL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = (regs->B) & 1;
            regs->B = (regs->B) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->B) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB39_SRL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = (regs->C) & 1;
            regs->C = (regs->C) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->C) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB3A_SRL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = (regs->D) & 1;
            regs->D = (regs->D) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->D) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB3B_SRL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = (regs->E) & 1;
            regs->E = (regs->E) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->E) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB3C_SRL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = (regs->H) & 1;
            regs->H = (regs->H) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->H) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB3D_SRL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = (regs->L) & 1;
            regs->L = (regs->L) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->L) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB3E_SRL_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->F.C = (regs->TR) & 1;
            regs->TR = (regs->TR) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->TR) == 0);
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB3F_SRL_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.C = (regs->A) & 1;
            regs->A = (regs->A) >> 1;
            regs->F.H = regs->F.N = 0;
            regs->F.Z = +((regs->A) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB40_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB41_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB42_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB43_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB44_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB45_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB46_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB47_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB48_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB49_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB4A_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB4B_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB4C_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB4D_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB4E_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB4F_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB50_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB51_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB52_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB53_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB54_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB55_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB56_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB57_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB58_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB59_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB5A_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB5B_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB5C_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB5D_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB5E_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB5F_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB60_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB61_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB62_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB63_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB64_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB65_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB66_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB67_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB68_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB69_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB6A_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB6B_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB6C_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB6D_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB6E_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB6F_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB70_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB71_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB72_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB73_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB74_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB75_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB76_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB77_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB78_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->B & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB79_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->C & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB7A_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->D & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB7B_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->E & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB7C_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->H & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB7D_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->L & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB7E_BIT_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            pins->Addr = ((regs->H << 8) | regs->L);
            break; }
        case 2: { // cleanup_custom
            regs->TR = pins->D;
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->TR & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB7F_BIT_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->F.H = 1;
            regs->F.N = 0;
            regs->F.Z = +((regs->A & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB80_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB81_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB82_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB83_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB84_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB85_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB86_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0xFE;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB87_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB88_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB89_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB8A_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB8B_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB8C_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB8D_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB8E_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0xFD;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB8F_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB90_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB91_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB92_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB93_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB94_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB95_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB96_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0xFB;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB97_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB98_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB99_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB9A_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB9B_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB9C_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB9D_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CB9E_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0xF7;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CB9F_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA0_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA1_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA2_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA3_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA4_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA5_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA6_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0xEF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBA7_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA8_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBA9_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBAA_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBAB_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBAC_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBAD_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBAE_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0xDF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBAF_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB0_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB1_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB2_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB3_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB4_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB5_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB6_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0xBF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBB7_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB8_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBB9_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBBA_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBBB_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBBC_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBBD_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBBE_RES_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            pins->Addr = (regs->TA);
            pins->D = regs->TR & 0x7F;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBBF_RES_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC0_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x01;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC1_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x01;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC2_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x01;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC3_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x01;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC4_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x01;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC5_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x01;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC6_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x01;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBC7_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x01;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC8_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x02;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBC9_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x02;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBCA_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x02;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBCB_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x02;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBCC_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x02;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBCD_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x02;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBCE_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x02;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBCF_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x02;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD0_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x04;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD1_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x04;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD2_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x04;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD3_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x04;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD4_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x04;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD5_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x04;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD6_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x04;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBD7_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x04;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD8_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x08;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBD9_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x08;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBDA_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x08;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBDB_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x08;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBDC_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x08;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBDD_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x08;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBDE_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x08;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBDF_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x08;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE0_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x10;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE1_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x10;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE2_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x10;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE3_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x10;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE4_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x10;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE5_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x10;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE6_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x10;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBE7_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x10;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE8_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x20;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBE9_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x20;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBEA_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x20;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBEB_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x20;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBEC_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x20;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBED_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x20;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBEE_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x20;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBEF_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x20;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF0_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x40;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF1_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x40;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF2_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x40;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF3_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x40;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF4_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x40;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF5_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x40;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF6_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x40;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBF7_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x40;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF8_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->B = regs->B | 0x80;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBF9_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->C = regs->C | 0x80;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBFA_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->D = regs->D | 0x80;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBFB_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->E = regs->E | 0x80;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBFC_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->H = regs->H | 0x80;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBFD_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->L = regs->L | 0x80;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

void SM83_ins_CBFE_SET_idx_ind(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // Do read
            regs->TA = (regs->H << 8) | regs->L;
            pins->Addr = (regs->TA);
            break; }
        case 2: { // Do write
            regs->TR = pins->D;
            regs->TR |= 0x80;
            pins->Addr = (regs->TA);
            pins->D = regs->TR;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            pins->RD = 1; pins->WR = 0;
            break;
    }}
}

void SM83_ins_CBFF_SET_idx_di(struct SM83_regs *regs, struct SM83_pins *pins)
{
    switch(regs->TCU) {
        case 1: { // cleanup_custom
            regs->A = regs->A | 0x80;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->PC;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            regs->IR = SM83_S_DECODE;
            regs->poll_IRQ = TRUE;
            break;
    }}
}

SM83_ins_func SM83_decoded_opcodes[0x202] = {
        &SM83_ins_00_NOP,   &SM83_ins_01_LD16_di_da,   &SM83_ins_02_LD_ind_di,   &SM83_ins_03_INC16_di,   &SM83_ins_04_INC_di,
        &SM83_ins_05_DEC_di,   &SM83_ins_06_LD_di_da,   &SM83_ins_07_RLCA,   &SM83_ins_08_LD16_addr_di,   &SM83_ins_09_ADD16_di_di,
        &SM83_ins_0A_LD_di_ind,   &SM83_ins_0B_DEC16_di,   &SM83_ins_0C_INC_di,   &SM83_ins_0D_DEC_di,   &SM83_ins_0E_LD_di_da,
        &SM83_ins_0F_RRCA,   &SM83_ins_10_STOP,   &SM83_ins_11_LD16_di_da,   &SM83_ins_12_LD_ind_di,   &SM83_ins_13_INC16_di,
        &SM83_ins_14_INC_di,   &SM83_ins_15_DEC_di,   &SM83_ins_16_LD_di_da,   &SM83_ins_17_RLA,   &SM83_ins_18_JR_cond_rel,
        &SM83_ins_19_ADD16_di_di,   &SM83_ins_1A_LD_di_ind,   &SM83_ins_1B_DEC16_di,   &SM83_ins_1C_INC_di,   &SM83_ins_1D_DEC_di,
        &SM83_ins_1E_LD_di_da,   &SM83_ins_1F_RRA,   &SM83_ins_20_JR_cond_rel,   &SM83_ins_21_LD16_di_da,   &SM83_ins_22_LD_ind_inc_di,
        &SM83_ins_23_INC16_di,   &SM83_ins_24_INC_di,   &SM83_ins_25_DEC_di,   &SM83_ins_26_LD_di_da,   &SM83_ins_27_DAA,
        &SM83_ins_28_JR_cond_rel,   &SM83_ins_29_ADD16_di_di,   &SM83_ins_2A_LD_di_ind_inc,   &SM83_ins_2B_DEC16_di,   &SM83_ins_2C_INC_di,
        &SM83_ins_2D_DEC_di,   &SM83_ins_2E_LD_di_da,   &SM83_ins_2F_CPL,   &SM83_ins_30_JR_cond_rel,   &SM83_ins_31_LD16_di_da,
        &SM83_ins_32_LD_ind_dec_di,   &SM83_ins_33_INC16_di,   &SM83_ins_34_INC_ind,   &SM83_ins_35_DEC_ind,   &SM83_ins_36_LD_ind_da,
        &SM83_ins_37_SCF,   &SM83_ins_38_JR_cond_rel,   &SM83_ins_39_ADD16_di_di,   &SM83_ins_3A_LD_di_ind_dec,   &SM83_ins_3B_DEC16_di,
        &SM83_ins_3C_INC_di,   &SM83_ins_3D_DEC_di,   &SM83_ins_3E_LD_di_da,   &SM83_ins_3F_CCF,   &SM83_ins_40_LD_di_di,
        &SM83_ins_41_LD_di_di,   &SM83_ins_42_LD_di_di,   &SM83_ins_43_LD_di_di,   &SM83_ins_44_LD_di_di,   &SM83_ins_45_LD_di_di,
        &SM83_ins_46_LD_di_ind,   &SM83_ins_47_LD_di_di,   &SM83_ins_48_LD_di_di,   &SM83_ins_49_LD_di_di,   &SM83_ins_4A_LD_di_di,
        &SM83_ins_4B_LD_di_di,   &SM83_ins_4C_LD_di_di,   &SM83_ins_4D_LD_di_di,   &SM83_ins_4E_LD_di_ind,   &SM83_ins_4F_LD_di_di,
        &SM83_ins_50_LD_di_di,   &SM83_ins_51_LD_di_di,   &SM83_ins_52_LD_di_di,   &SM83_ins_53_LD_di_di,   &SM83_ins_54_LD_di_di,
        &SM83_ins_55_LD_di_di,   &SM83_ins_56_LD_di_ind,   &SM83_ins_57_LD_di_di,   &SM83_ins_58_LD_di_di,   &SM83_ins_59_LD_di_di,
        &SM83_ins_5A_LD_di_di,   &SM83_ins_5B_LD_di_di,   &SM83_ins_5C_LD_di_di,   &SM83_ins_5D_LD_di_di,   &SM83_ins_5E_LD_di_ind,
        &SM83_ins_5F_LD_di_di,   &SM83_ins_60_LD_di_di,   &SM83_ins_61_LD_di_di,   &SM83_ins_62_LD_di_di,   &SM83_ins_63_LD_di_di,
        &SM83_ins_64_LD_di_di,   &SM83_ins_65_LD_di_di,   &SM83_ins_66_LD_di_ind,   &SM83_ins_67_LD_di_di,   &SM83_ins_68_LD_di_di,
        &SM83_ins_69_LD_di_di,   &SM83_ins_6A_LD_di_di,   &SM83_ins_6B_LD_di_di,   &SM83_ins_6C_LD_di_di,   &SM83_ins_6D_LD_di_di,
        &SM83_ins_6E_LD_di_ind,   &SM83_ins_6F_LD_di_di,   &SM83_ins_70_LD_ind_di,   &SM83_ins_71_LD_ind_di,   &SM83_ins_72_LD_ind_di,
        &SM83_ins_73_LD_ind_di,   &SM83_ins_74_LD_ind_di,   &SM83_ins_75_LD_ind_di,   &SM83_ins_76_HALT,   &SM83_ins_77_LD_ind_di,
        &SM83_ins_78_LD_di_di,   &SM83_ins_79_LD_di_di,   &SM83_ins_7A_LD_di_di,   &SM83_ins_7B_LD_di_di,   &SM83_ins_7C_LD_di_di,
        &SM83_ins_7D_LD_di_di,   &SM83_ins_7E_LD_di_ind,   &SM83_ins_7F_LD_di_di,   &SM83_ins_80_ADD_di_di,   &SM83_ins_81_ADD_di_di,
        &SM83_ins_82_ADD_di_di,   &SM83_ins_83_ADD_di_di,   &SM83_ins_84_ADD_di_di,   &SM83_ins_85_ADD_di_di,   &SM83_ins_86_ADD_di_ind,
        &SM83_ins_87_ADD_di_di,   &SM83_ins_88_ADC_di_di,   &SM83_ins_89_ADC_di_di,   &SM83_ins_8A_ADC_di_di,   &SM83_ins_8B_ADC_di_di,
        &SM83_ins_8C_ADC_di_di,   &SM83_ins_8D_ADC_di_di,   &SM83_ins_8E_ADC_di_ind,   &SM83_ins_8F_ADC_di_di,   &SM83_ins_90_SUB_di_di,
        &SM83_ins_91_SUB_di_di,   &SM83_ins_92_SUB_di_di,   &SM83_ins_93_SUB_di_di,   &SM83_ins_94_SUB_di_di,   &SM83_ins_95_SUB_di_di,
        &SM83_ins_96_SUB_di_ind,   &SM83_ins_97_SUB_di_di,   &SM83_ins_98_SBC_di_di,   &SM83_ins_99_SBC_di_di,   &SM83_ins_9A_SBC_di_di,
        &SM83_ins_9B_SBC_di_di,   &SM83_ins_9C_SBC_di_di,   &SM83_ins_9D_SBC_di_di,   &SM83_ins_9E_SBC_di_ind,   &SM83_ins_9F_SBC_di_di,
        &SM83_ins_A0_AND_di_di,   &SM83_ins_A1_AND_di_di,   &SM83_ins_A2_AND_di_di,   &SM83_ins_A3_AND_di_di,   &SM83_ins_A4_AND_di_di,
        &SM83_ins_A5_AND_di_di,   &SM83_ins_A6_AND_di_ind,   &SM83_ins_A7_AND_di_di,   &SM83_ins_A8_XOR_di_di,   &SM83_ins_A9_XOR_di_di,
        &SM83_ins_AA_XOR_di_di,   &SM83_ins_AB_XOR_di_di,   &SM83_ins_AC_XOR_di_di,   &SM83_ins_AD_XOR_di_di,   &SM83_ins_AE_XOR_di_ind,
        &SM83_ins_AF_XOR_di_di,   &SM83_ins_B0_OR_di_di,   &SM83_ins_B1_OR_di_di,   &SM83_ins_B2_OR_di_di,   &SM83_ins_B3_OR_di_di,
        &SM83_ins_B4_OR_di_di,   &SM83_ins_B5_OR_di_di,   &SM83_ins_B6_OR_di_ind,   &SM83_ins_B7_OR_di_di,   &SM83_ins_B8_CP_di_di,
        &SM83_ins_B9_CP_di_di,   &SM83_ins_BA_CP_di_di,   &SM83_ins_BB_CP_di_di,   &SM83_ins_BC_CP_di_di,   &SM83_ins_BD_CP_di_di,
        &SM83_ins_BE_CP_di_ind,   &SM83_ins_BF_CP_di_di,   &SM83_ins_C0_RET_cond,   &SM83_ins_C1_POP_di,   &SM83_ins_C2_JP_cond_addr,
        &SM83_ins_C3_JP_cond_addr,   &SM83_ins_C4_CALL_cond_addr,   &SM83_ins_C5_PUSH_di,   &SM83_ins_C6_ADD_di_da,   &SM83_ins_C7_RST_imp,
        &SM83_ins_C8_RET_cond,   &SM83_ins_C9_RET,   &SM83_ins_CA_JP_cond_addr,   &SM83_ins_CB_NONE,&SM83_ins_CC_CALL_cond_addr,   &SM83_ins_CD_CALL_cond_addr,
        &SM83_ins_CE_ADC_di_da,   &SM83_ins_CF_RST_imp,   &SM83_ins_D0_RET_cond,   &SM83_ins_D1_POP_di,   &SM83_ins_D2_JP_cond_addr,
        &SM83_ins_D3_NONE,   &SM83_ins_D4_CALL_cond_addr,   &SM83_ins_D5_PUSH_di,   &SM83_ins_D6_SUB_di_da,   &SM83_ins_D7_RST_imp,
        &SM83_ins_D8_RET_cond,   &SM83_ins_D9_RETI,   &SM83_ins_DA_JP_cond_addr,   &SM83_ins_DB_NONE,   &SM83_ins_DC_CALL_cond_addr,
        &SM83_ins_DD_NONE,   &SM83_ins_DE_SBC_di_da,   &SM83_ins_DF_RST_imp,   &SM83_ins_E0_LDH_addr_di,   &SM83_ins_E1_POP_di,
        &SM83_ins_E2_LDH_ind_di,   &SM83_ins_E3_NONE,   &SM83_ins_E4_NONE,   &SM83_ins_E5_PUSH_di,   &SM83_ins_E6_AND_di_da,
        &SM83_ins_E7_RST_imp,   &SM83_ins_E8_ADD_di_rel,   &SM83_ins_E9_JP_di,   &SM83_ins_EA_LD_addr_di,   &SM83_ins_EB_NONE,
        &SM83_ins_EC_NONE,   &SM83_ins_ED_NONE,   &SM83_ins_EE_XOR_di_da,   &SM83_ins_EF_RST_imp,   &SM83_ins_F0_LDH_di_addr,
        &SM83_ins_F1_POP_di_AF,   &SM83_ins_F2_LDH_di_ind,   &SM83_ins_F3_DI,   &SM83_ins_F4_NONE,   &SM83_ins_F5_PUSH_di,
        &SM83_ins_F6_OR_di_da,   &SM83_ins_F7_RST_imp,   &SM83_ins_F8_LD_di_di_rel,   &SM83_ins_F9_LD16_di_di,   &SM83_ins_FA_LD_di_addr,
        &SM83_ins_FB_EI,   &SM83_ins_FC_NONE,   &SM83_ins_FD_NONE,   &SM83_ins_FE_CP_di_da,   &SM83_ins_FF_RST_imp,
        &SM83_ins_100_S_IRQ,   &SM83_ins_101_RESET,
        &SM83_ins_CB00_RLC_di,   &SM83_ins_CB01_RLC_di,   &SM83_ins_CB02_RLC_di,   &SM83_ins_CB03_RLC_di,   &SM83_ins_CB04_RLC_di,
        &SM83_ins_CB05_RLC_di,   &SM83_ins_CB06_RLC_ind,   &SM83_ins_CB07_RLC_di,   &SM83_ins_CB08_RRC_di,   &SM83_ins_CB09_RRC_di,
        &SM83_ins_CB0A_RRC_di,   &SM83_ins_CB0B_RRC_di,   &SM83_ins_CB0C_RRC_di,   &SM83_ins_CB0D_RRC_di,   &SM83_ins_CB0E_RRC_ind,
        &SM83_ins_CB0F_RRC_di,   &SM83_ins_CB10_RL_di,   &SM83_ins_CB11_RL_di,   &SM83_ins_CB12_RL_di,   &SM83_ins_CB13_RL_di,
        &SM83_ins_CB14_RL_di,   &SM83_ins_CB15_RL_di,   &SM83_ins_CB16_RL_ind,   &SM83_ins_CB17_RL_di,   &SM83_ins_CB18_RR_di,
        &SM83_ins_CB19_RR_di,   &SM83_ins_CB1A_RR_di,   &SM83_ins_CB1B_RR_di,   &SM83_ins_CB1C_RR_di,   &SM83_ins_CB1D_RR_di,
        &SM83_ins_CB1E_RR_ind,   &SM83_ins_CB1F_RR_di,   &SM83_ins_CB20_SLA_di,   &SM83_ins_CB21_SLA_di,   &SM83_ins_CB22_SLA_di,
        &SM83_ins_CB23_SLA_di,   &SM83_ins_CB24_SLA_di,   &SM83_ins_CB25_SLA_di,   &SM83_ins_CB26_SLA_ind,   &SM83_ins_CB27_SLA_di,
        &SM83_ins_CB28_SRA_di,   &SM83_ins_CB29_SRA_di,   &SM83_ins_CB2A_SRA_di,   &SM83_ins_CB2B_SRA_di,   &SM83_ins_CB2C_SRA_di,
        &SM83_ins_CB2D_SRA_di,   &SM83_ins_CB2E_SRA_ind,   &SM83_ins_CB2F_SRA_di,   &SM83_ins_CB30_SWAP_di,   &SM83_ins_CB31_SWAP_di,
        &SM83_ins_CB32_SWAP_di,   &SM83_ins_CB33_SWAP_di,   &SM83_ins_CB34_SWAP_di,   &SM83_ins_CB35_SWAP_di,   &SM83_ins_CB36_SWAP_ind,
        &SM83_ins_CB37_SWAP_di,   &SM83_ins_CB38_SRL_di,   &SM83_ins_CB39_SRL_di,   &SM83_ins_CB3A_SRL_di,   &SM83_ins_CB3B_SRL_di,
        &SM83_ins_CB3C_SRL_di,   &SM83_ins_CB3D_SRL_di,   &SM83_ins_CB3E_SRL_ind,   &SM83_ins_CB3F_SRL_di,   &SM83_ins_CB40_BIT_idx_di,
        &SM83_ins_CB41_BIT_idx_di,   &SM83_ins_CB42_BIT_idx_di,   &SM83_ins_CB43_BIT_idx_di,   &SM83_ins_CB44_BIT_idx_di,   &SM83_ins_CB45_BIT_idx_di,
        &SM83_ins_CB46_BIT_idx_ind,   &SM83_ins_CB47_BIT_idx_di,   &SM83_ins_CB48_BIT_idx_di,   &SM83_ins_CB49_BIT_idx_di,   &SM83_ins_CB4A_BIT_idx_di,
        &SM83_ins_CB4B_BIT_idx_di,   &SM83_ins_CB4C_BIT_idx_di,   &SM83_ins_CB4D_BIT_idx_di,   &SM83_ins_CB4E_BIT_idx_ind,   &SM83_ins_CB4F_BIT_idx_di,
        &SM83_ins_CB50_BIT_idx_di,   &SM83_ins_CB51_BIT_idx_di,   &SM83_ins_CB52_BIT_idx_di,   &SM83_ins_CB53_BIT_idx_di,   &SM83_ins_CB54_BIT_idx_di,
        &SM83_ins_CB55_BIT_idx_di,   &SM83_ins_CB56_BIT_idx_ind,   &SM83_ins_CB57_BIT_idx_di,   &SM83_ins_CB58_BIT_idx_di,   &SM83_ins_CB59_BIT_idx_di,
        &SM83_ins_CB5A_BIT_idx_di,   &SM83_ins_CB5B_BIT_idx_di,   &SM83_ins_CB5C_BIT_idx_di,   &SM83_ins_CB5D_BIT_idx_di,   &SM83_ins_CB5E_BIT_idx_ind,
        &SM83_ins_CB5F_BIT_idx_di,   &SM83_ins_CB60_BIT_idx_di,   &SM83_ins_CB61_BIT_idx_di,   &SM83_ins_CB62_BIT_idx_di,   &SM83_ins_CB63_BIT_idx_di,
        &SM83_ins_CB64_BIT_idx_di,   &SM83_ins_CB65_BIT_idx_di,   &SM83_ins_CB66_BIT_idx_ind,   &SM83_ins_CB67_BIT_idx_di,   &SM83_ins_CB68_BIT_idx_di,
        &SM83_ins_CB69_BIT_idx_di,   &SM83_ins_CB6A_BIT_idx_di,   &SM83_ins_CB6B_BIT_idx_di,   &SM83_ins_CB6C_BIT_idx_di,   &SM83_ins_CB6D_BIT_idx_di,
        &SM83_ins_CB6E_BIT_idx_ind,   &SM83_ins_CB6F_BIT_idx_di,   &SM83_ins_CB70_BIT_idx_di,   &SM83_ins_CB71_BIT_idx_di,   &SM83_ins_CB72_BIT_idx_di,
        &SM83_ins_CB73_BIT_idx_di,   &SM83_ins_CB74_BIT_idx_di,   &SM83_ins_CB75_BIT_idx_di,   &SM83_ins_CB76_BIT_idx_ind,   &SM83_ins_CB77_BIT_idx_di,
        &SM83_ins_CB78_BIT_idx_di,   &SM83_ins_CB79_BIT_idx_di,   &SM83_ins_CB7A_BIT_idx_di,   &SM83_ins_CB7B_BIT_idx_di,   &SM83_ins_CB7C_BIT_idx_di,
        &SM83_ins_CB7D_BIT_idx_di,   &SM83_ins_CB7E_BIT_idx_ind,   &SM83_ins_CB7F_BIT_idx_di,   &SM83_ins_CB80_RES_idx_di,   &SM83_ins_CB81_RES_idx_di,
        &SM83_ins_CB82_RES_idx_di,   &SM83_ins_CB83_RES_idx_di,   &SM83_ins_CB84_RES_idx_di,   &SM83_ins_CB85_RES_idx_di,   &SM83_ins_CB86_RES_idx_ind,
        &SM83_ins_CB87_RES_idx_di,   &SM83_ins_CB88_RES_idx_di,   &SM83_ins_CB89_RES_idx_di,   &SM83_ins_CB8A_RES_idx_di,   &SM83_ins_CB8B_RES_idx_di,
        &SM83_ins_CB8C_RES_idx_di,   &SM83_ins_CB8D_RES_idx_di,   &SM83_ins_CB8E_RES_idx_ind,   &SM83_ins_CB8F_RES_idx_di,   &SM83_ins_CB90_RES_idx_di,
        &SM83_ins_CB91_RES_idx_di,   &SM83_ins_CB92_RES_idx_di,   &SM83_ins_CB93_RES_idx_di,   &SM83_ins_CB94_RES_idx_di,   &SM83_ins_CB95_RES_idx_di,
        &SM83_ins_CB96_RES_idx_ind,   &SM83_ins_CB97_RES_idx_di,   &SM83_ins_CB98_RES_idx_di,   &SM83_ins_CB99_RES_idx_di,   &SM83_ins_CB9A_RES_idx_di,
        &SM83_ins_CB9B_RES_idx_di,   &SM83_ins_CB9C_RES_idx_di,   &SM83_ins_CB9D_RES_idx_di,   &SM83_ins_CB9E_RES_idx_ind,   &SM83_ins_CB9F_RES_idx_di,
        &SM83_ins_CBA0_RES_idx_di,   &SM83_ins_CBA1_RES_idx_di,   &SM83_ins_CBA2_RES_idx_di,   &SM83_ins_CBA3_RES_idx_di,   &SM83_ins_CBA4_RES_idx_di,
        &SM83_ins_CBA5_RES_idx_di,   &SM83_ins_CBA6_RES_idx_ind,   &SM83_ins_CBA7_RES_idx_di,   &SM83_ins_CBA8_RES_idx_di,   &SM83_ins_CBA9_RES_idx_di,
        &SM83_ins_CBAA_RES_idx_di,   &SM83_ins_CBAB_RES_idx_di,   &SM83_ins_CBAC_RES_idx_di,   &SM83_ins_CBAD_RES_idx_di,   &SM83_ins_CBAE_RES_idx_ind,
        &SM83_ins_CBAF_RES_idx_di,   &SM83_ins_CBB0_RES_idx_di,   &SM83_ins_CBB1_RES_idx_di,   &SM83_ins_CBB2_RES_idx_di,   &SM83_ins_CBB3_RES_idx_di,
        &SM83_ins_CBB4_RES_idx_di,   &SM83_ins_CBB5_RES_idx_di,   &SM83_ins_CBB6_RES_idx_ind,   &SM83_ins_CBB7_RES_idx_di,   &SM83_ins_CBB8_RES_idx_di,
        &SM83_ins_CBB9_RES_idx_di,   &SM83_ins_CBBA_RES_idx_di,   &SM83_ins_CBBB_RES_idx_di,   &SM83_ins_CBBC_RES_idx_di,   &SM83_ins_CBBD_RES_idx_di,
        &SM83_ins_CBBE_RES_idx_ind,   &SM83_ins_CBBF_RES_idx_di,   &SM83_ins_CBC0_SET_idx_di,   &SM83_ins_CBC1_SET_idx_di,   &SM83_ins_CBC2_SET_idx_di,
        &SM83_ins_CBC3_SET_idx_di,   &SM83_ins_CBC4_SET_idx_di,   &SM83_ins_CBC5_SET_idx_di,   &SM83_ins_CBC6_SET_idx_ind,   &SM83_ins_CBC7_SET_idx_di,
        &SM83_ins_CBC8_SET_idx_di,   &SM83_ins_CBC9_SET_idx_di,   &SM83_ins_CBCA_SET_idx_di,   &SM83_ins_CBCB_SET_idx_di,   &SM83_ins_CBCC_SET_idx_di,
        &SM83_ins_CBCD_SET_idx_di,   &SM83_ins_CBCE_SET_idx_ind,   &SM83_ins_CBCF_SET_idx_di,   &SM83_ins_CBD0_SET_idx_di,   &SM83_ins_CBD1_SET_idx_di,
        &SM83_ins_CBD2_SET_idx_di,   &SM83_ins_CBD3_SET_idx_di,   &SM83_ins_CBD4_SET_idx_di,   &SM83_ins_CBD5_SET_idx_di,   &SM83_ins_CBD6_SET_idx_ind,
        &SM83_ins_CBD7_SET_idx_di,   &SM83_ins_CBD8_SET_idx_di,   &SM83_ins_CBD9_SET_idx_di,   &SM83_ins_CBDA_SET_idx_di,   &SM83_ins_CBDB_SET_idx_di,
        &SM83_ins_CBDC_SET_idx_di,   &SM83_ins_CBDD_SET_idx_di,   &SM83_ins_CBDE_SET_idx_ind,   &SM83_ins_CBDF_SET_idx_di,   &SM83_ins_CBE0_SET_idx_di,
        &SM83_ins_CBE1_SET_idx_di,   &SM83_ins_CBE2_SET_idx_di,   &SM83_ins_CBE3_SET_idx_di,   &SM83_ins_CBE4_SET_idx_di,   &SM83_ins_CBE5_SET_idx_di,
        &SM83_ins_CBE6_SET_idx_ind,   &SM83_ins_CBE7_SET_idx_di,   &SM83_ins_CBE8_SET_idx_di,   &SM83_ins_CBE9_SET_idx_di,   &SM83_ins_CBEA_SET_idx_di,
        &SM83_ins_CBEB_SET_idx_di,   &SM83_ins_CBEC_SET_idx_di,   &SM83_ins_CBED_SET_idx_di,   &SM83_ins_CBEE_SET_idx_ind,   &SM83_ins_CBEF_SET_idx_di,
        &SM83_ins_CBF0_SET_idx_di,   &SM83_ins_CBF1_SET_idx_di,   &SM83_ins_CBF2_SET_idx_di,   &SM83_ins_CBF3_SET_idx_di,   &SM83_ins_CBF4_SET_idx_di,
        &SM83_ins_CBF5_SET_idx_di,   &SM83_ins_CBF6_SET_idx_ind,   &SM83_ins_CBF7_SET_idx_di,   &SM83_ins_CBF8_SET_idx_di,   &SM83_ins_CBF9_SET_idx_di,
        &SM83_ins_CBFA_SET_idx_di,   &SM83_ins_CBFB_SET_idx_di,   &SM83_ins_CBFC_SET_idx_di,   &SM83_ins_CBFD_SET_idx_di,   &SM83_ins_CBFE_SET_idx_ind,
        &SM83_ins_CBFF_SET_idx_di,
};