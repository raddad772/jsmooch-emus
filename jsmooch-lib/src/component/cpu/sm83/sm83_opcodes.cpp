#include "helpers/int.h"
#include "sm83.h"
#include "sm83_opcodes.h"


 // This file auto-generated by sm83_core_generator.js in JSMoo


namespace SM83 {

void ins_00_NOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            //NOPE!
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_01_LD16_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TR = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs.RR = pins.D;
            regs.TR |= (regs.RR << 8);
            regs.B = (regs.TR & 0xFF00) >> 8;
            regs.C = regs.TR & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_02_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.B << 8) | regs.C;
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_03_INC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = (regs.B << 8) | regs.C;
            a = (a + 1) & 0xFFFF;
            regs.B = (a & 0xFF00) >> 8;
            regs.C = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_04_INC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = ((regs.B) + 1) & 0xFF;
            regs.F.H = +(((regs.B) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_05_DEC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = ((regs.B) - 1) & 0xFF;
            regs.F.H = +(((regs.B) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_06_LD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.B = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_07_RLCA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = ((regs.A << 1) | (regs.A >> 7)) & 0xFF;
            regs.F.C = regs.A & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            regs.F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_08_LD16_addr_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { // Do write
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            pins.Addr = (regs.TA);
            pins.D = regs.SP & 0xFF;
            pins.RD = 0; pins.WR = 1;
            break; }
        case 4: { // Do write
            pins.Addr = ((regs.TA + 1) & 0xFFFF);
            pins.D = (regs.SP & 0xFF00) >> 8;
            // Following is auto-generated code for instruction finish
            break; }
        case 5: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_09_ADD16_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // idle
            u32 target = (regs.H << 8) | regs.L;
            u32 source = (regs.B << 8) | regs.C;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs.H = (x & 0xFF00) >> 8;
            regs.L = x & 0xFF;
            regs.F.C = +(x > 0xFFFF);
            regs.F.H = +(y > 0x0FFF);
            regs.F.N = 0;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_0A_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.B << 8) | regs.C;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_0B_DEC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = (regs.B << 8) | regs.C;
            a = (a - 1) & 0xFFFF;
            regs.B = (a & 0xFF00) >> 8;
            regs.C = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_0C_INC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = ((regs.C) + 1) & 0xFF;
            regs.F.H = +(((regs.C) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_0D_DEC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = ((regs.C) - 1) & 0xFF;
            regs.F.H = +(((regs.C) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_0E_LD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.C = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_0F_RRCA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = (((regs.A) << 7) | ((regs.A) >> 1)) & 0xFF;
            regs.F.C = ((regs.A) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            regs.F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_10_STOP(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.STP = 1;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: {
            if (regs.STP) regs.TCU--;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_11_LD16_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TR = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs.RR = pins.D;
            regs.TR |= (regs.RR << 8);
            regs.D = (regs.TR & 0xFF00) >> 8;
            regs.E = regs.TR & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_12_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.D << 8) | regs.E;
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_13_INC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = (regs.D << 8) | regs.E;
            a = (a + 1) & 0xFFFF;
            regs.D = (a & 0xFF00) >> 8;
            regs.E = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_14_INC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = ((regs.D) + 1) & 0xFF;
            regs.F.H = +(((regs.D) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_15_DEC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = ((regs.D) - 1) & 0xFF;
            regs.F.H = +(((regs.D) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_16_LD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.D = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_17_RLA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.A) & 0x80) >> 7;
            regs.A = (((regs.A) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            regs.F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_18_JR_cond_rel(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(1)) { regs.TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs.TA = pins.D;
            regs.PC = ((i32)(i8)regs.TA + regs.PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_19_ADD16_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // idle
            u32 target = (regs.H << 8) | regs.L;
            u32 source = (regs.D << 8) | regs.E;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs.H = (x & 0xFF00) >> 8;
            regs.L = x & 0xFF;
            regs.F.C = +(x > 0xFFFF);
            regs.F.H = +(y > 0x0FFF);
            regs.F.N = 0;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_1A_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.D << 8) | regs.E;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_1B_DEC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = (regs.D << 8) | regs.E;
            a = (a - 1) & 0xFFFF;
            regs.D = (a & 0xFF00) >> 8;
            regs.E = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_1C_INC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = ((regs.E) + 1) & 0xFF;
            regs.F.H = +(((regs.E) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_1D_DEC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = ((regs.E) - 1) & 0xFF;
            regs.F.H = +(((regs.E) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_1E_LD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.E = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_1F_RRA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.A) & 1;
            regs.A = ((regs.A) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            regs.F.Z = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_20_JR_cond_rel(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.Z == 0)) { regs.TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs.TA = pins.D;
            regs.PC = ((i32)(i8)regs.TA + regs.PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_21_LD16_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TR = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs.RR = pins.D;
            regs.TR |= (regs.RR << 8);
            regs.H = (regs.TR & 0xFF00) >> 8;
            regs.L = regs.TR & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_22_LD_ind_inc_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            regs.TA = (regs.TA + 1) & 0xFFFF;
            regs.H = (regs.TA & 0xFF00) >> 8;
            regs.L = regs.TA & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_23_INC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = (regs.H << 8) | regs.L;
            a = (a + 1) & 0xFFFF;
            regs.H = (a & 0xFF00) >> 8;
            regs.L = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_24_INC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = ((regs.H) + 1) & 0xFF;
            regs.F.H = +(((regs.H) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_25_DEC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = ((regs.H) - 1) & 0xFF;
            regs.F.H = +(((regs.H) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_26_LD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.H = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_27_DAA(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 a = regs.A;
            if (!regs.F.N) {
                if (regs.F.H || ((regs.A & 0x0F) > 0x09)) a += 0x06;
                if (regs.F.C || (regs.A > 0x99)) {
                    a += 0x60;
                    regs.F.C = 1;
                }
            } else {
                a -= (0x06 * regs.F.H);
                a -= (0x60 * regs.F.C);
            }
            regs.A = a & 0xFF;
            regs.F.H = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_28_JR_cond_rel(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.Z == 1)) { regs.TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs.TA = pins.D;
            regs.PC = ((i32)(i8)regs.TA + regs.PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_29_ADD16_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // idle
            u32 target = (regs.H << 8) | regs.L;
            u32 source = (regs.H << 8) | regs.L;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs.H = (x & 0xFF00) >> 8;
            regs.L = x & 0xFF;
            regs.F.C = +(x > 0xFFFF);
            regs.F.H = +(y > 0x0FFF);
            regs.F.N = 0;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_2A_LD_di_ind_inc(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            regs.TA = (regs.TA + 1) & 0xFFFF;
            regs.H = (regs.TA & 0xFF00) >> 8;
            regs.L = regs.TA & 0xFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_2B_DEC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = (regs.H << 8) | regs.L;
            a = (a - 1) & 0xFFFF;
            regs.H = (a & 0xFF00) >> 8;
            regs.L = a & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_2C_INC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = ((regs.L) + 1) & 0xFF;
            regs.F.H = +(((regs.L) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_2D_DEC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = ((regs.L) - 1) & 0xFF;
            regs.F.H = +(((regs.L) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_2E_LD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.L = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_2F_CPL(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A ^= 0xFF;
            regs.F.H = regs.F.N = 1;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_30_JR_cond_rel(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.C == 0)) { regs.TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs.TA = pins.D;
            regs.PC = ((i32)(i8)regs.TA + regs.PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_31_LD16_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TR = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { // cleanup_custom
            regs.RR = pins.D;
            regs.TR |= (regs.RR << 8);
            regs.SP = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_32_LD_ind_dec_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            regs.TA = (regs.TA - 1) & 0xFFFF;
            regs.H = (regs.TA & 0xFF00) >> 8;
            regs.L = regs.TA & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_33_INC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = regs.SP;
            a = (a + 1) & 0xFFFF;
            regs.SP = a;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_34_INC_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR = ((regs.TR) + 1) & 0xFF;
            regs.F.H = +(((regs.TR) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_35_DEC_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR = ((regs.TR) - 1) & 0xFF;
            regs.F.H = +(((regs.TR) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_36_LD_ind_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TA = (regs.H << 8) | regs.L;
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_37_SCF(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = 1;
            regs.F.H = regs.F.N = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_38_JR_cond_rel(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.C == 1)) { regs.TCU += 1; break; } // CHECKHERE
            break; }
        case 2: {
            regs.TA = pins.D;
            regs.PC = ((i32)(i8)regs.TA + regs.PC) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_39_ADD16_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // idle
            u32 target = (regs.H << 8) | regs.L;
            u32 source = regs.SP;
            u32 x = target + source;
            u32 y = (target & 0xFFF) + (source & 0xFFF);
            regs.H = (x & 0xFF00) >> 8;
            regs.L = x & 0xFF;
            regs.F.C = +(x > 0xFFFF);
            regs.F.H = +(y > 0x0FFF);
            regs.F.N = 0;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_3A_LD_di_ind_dec(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            regs.TA = (regs.TA - 1) & 0xFFFF;
            regs.H = (regs.TA & 0xFF00) >> 8;
            regs.L = regs.TA & 0xFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_3B_DEC16_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            u32 a = regs.SP;
            a = (a - 1) & 0xFFFF;
            regs.SP = a;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_3C_INC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = ((regs.A) + 1) & 0xFF;
            regs.F.H = +(((regs.A) & 0x0F) == 0);
            regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_3D_DEC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = ((regs.A) - 1) & 0xFF;
            regs.F.H = +(((regs.A) & 0x0F) == 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_3E_LD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.A = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_3F_CCF(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C ^= 1;
            regs.F.H = regs.F.N = 0;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_40_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_41_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.C;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_42_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.D;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_43_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.E;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_44_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.H;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_45_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_46_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.B = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_47_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.A;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_48_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.B;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_49_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_4A_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.D;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_4B_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.E;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_4C_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.H;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_4D_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_4E_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.C = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_4F_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.A;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_50_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.B;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_51_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.C;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_52_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_53_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.E;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_54_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.H;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_55_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_56_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_57_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.A;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_58_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.B;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_59_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.C;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_5A_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.D;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_5B_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_5C_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.H;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_5D_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_5E_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.E = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_5F_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.A;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_60_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.B;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_61_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.C;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_62_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.D;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_63_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.E;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_64_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_65_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_66_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.H = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_67_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.A;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_68_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.B;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_69_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.C;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_6A_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.D;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_6B_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.E;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_6C_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.H;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_6D_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_6E_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.L = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_6F_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.A;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_70_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.B;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_71_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.C;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_72_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.D;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_73_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.E;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_74_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.H;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_75_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.L;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_76_HALT(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            if ((!regs.IME) && (regs.interrupt_latch != 0)) regs.halt_bug = 1; 
            regs.HLT = 1;
            if (regs.HLT) { regs.poll_IRQ = true; regs.TCU--; }
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            //YOYOYO
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_77_LD_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_78_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.B;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_79_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.C;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_7A_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.D;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_7B_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.E;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_7C_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.H;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_7D_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_7E_LD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_7F_LD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_80_ADD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.B);
            u32 y = ((regs.A) & 0x0F) + ((regs.B) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_81_ADD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.C);
            u32 y = ((regs.A) & 0x0F) + ((regs.C) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_82_ADD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.D);
            u32 y = ((regs.A) & 0x0F) + ((regs.D) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_83_ADD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.E);
            u32 y = ((regs.A) & 0x0F) + ((regs.E) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_84_ADD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.H);
            u32 y = ((regs.A) & 0x0F) + ((regs.H) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_85_ADD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.L);
            u32 y = ((regs.A) & 0x0F) + ((regs.L) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_86_ADD_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = (regs.A) + (regs.TR);
            u32 y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_87_ADD_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.A);
            u32 y = ((regs.A) & 0x0F) + ((regs.A) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_88_ADC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.B) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.B) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_89_ADC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.C) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.C) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_8A_ADC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.D) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.D) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_8B_ADC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.E) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.E) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_8C_ADC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.H) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.H) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_8D_ADC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.L) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.L) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_8E_ADC_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = (regs.A) + (regs.TR) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_8F_ADC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = (regs.A) + (regs.A) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.A) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_90_SUB_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.B)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.B) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_91_SUB_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.C)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.C) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_92_SUB_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.D)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.D) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_93_SUB_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.E)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.E) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_94_SUB_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.H)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.H) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_95_SUB_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.L)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.L) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_96_SUB_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = ((regs.A) - (regs.TR)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_97_SUB_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.A)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.A) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_98_SBC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.B) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.B) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_99_SBC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.C) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.C) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_9A_SBC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.D) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.D) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_9B_SBC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.E) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.E) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_9C_SBC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.H) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.H) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_9D_SBC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.L) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.L) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_9E_SBC_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = ((regs.A) - (regs.TR) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.TR) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_9F_SBC_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.A) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.A) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A0_AND_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) & (regs.B);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A1_AND_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) & (regs.C);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A2_AND_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) & (regs.D);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A3_AND_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) & (regs.E);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A4_AND_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) & (regs.H);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A5_AND_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) & (regs.L);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A6_AND_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.TR = (regs.A) & (regs.TR);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A7_AND_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) & (regs.A);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A8_XOR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) ^ (regs.B);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_A9_XOR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) ^ (regs.C);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_AA_XOR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) ^ (regs.D);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_AB_XOR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) ^ (regs.E);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_AC_XOR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) ^ (regs.H);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_AD_XOR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) ^ (regs.L);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_AE_XOR_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.TR = (regs.A) ^ (regs.TR);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_AF_XOR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) ^ (regs.A);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B0_OR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) | (regs.B);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B1_OR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) | (regs.C);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B2_OR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) | (regs.D);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B3_OR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) | (regs.E);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B4_OR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) | (regs.H);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B5_OR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) | (regs.L);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B6_OR_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.TR = (regs.A) | (regs.TR);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B7_OR_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.TR = (regs.A) | (regs.A);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B8_CP_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.B)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.B) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_B9_CP_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.C)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.C) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_BA_CP_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.D)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.D) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_BB_CP_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.E)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.E) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_BC_CP_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.H)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.H) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_BD_CP_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.L)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.L) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_BE_CP_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = ((regs.A) - (regs.TR)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_BF_CP_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 x = ((regs.A) - (regs.A)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.A) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_C0_RET_cond(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            if (!(regs.F.Z == 0)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            pins.RD = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs.TR = pins.D;
            regs.TA |= (regs.TR << 8);
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_C1_POP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.C = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs.B = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_C2_JP_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.Z == 0)) { regs.TCU++; }
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.PC = regs.TA;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_C3_JP_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_C4_CALL_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.Z == 0)) { regs.TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 5: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_C5_PUSH_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.B;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.C;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_C6_ADD_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = (regs.A) + (regs.TR);
            u32 y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F);
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_C7_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0000;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_C8_RET_cond(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            if (!(regs.F.Z == 1)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            pins.RD = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs.TR = pins.D;
            regs.TA |= (regs.TR << 8);
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_C9_RET(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 3: {
            regs.TR = pins.D;
            regs.TA |= (regs.TR << 8);
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_CA_JP_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.Z == 1)) { regs.TCU++; }
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.PC = regs.TA;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_CB_NONE(regs &regs, pins &pins)
{
}

void ins_CC_CALL_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.Z == 1)) { regs.TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 5: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CD_CALL_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(1)) { regs.TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 5: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CE_ADC_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = (regs.A) + (regs.TR) + regs.F.C;
            u32 y = ((regs.A) & 0x0F) + ((regs.TR) & 0x0F) + regs.F.C;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 0;
            regs.TR = (x & 0xFF);
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CF_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0008;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_D0_RET_cond(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            if (!(regs.F.C == 0)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            pins.RD = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs.TR = pins.D;
            regs.TA |= (regs.TR << 8);
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_D1_POP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.E = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs.D = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_D2_JP_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.C == 0)) { regs.TCU++; }
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.PC = regs.TA;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_D3_NONE(regs &regs, pins &pins)
{
}

void ins_D4_CALL_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.C == 0)) { regs.TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 5: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_D5_PUSH_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.D;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.E;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_D6_SUB_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = ((regs.A) - (regs.TR)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_D7_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0010;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_D8_RET_cond(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            if (!(regs.F.C == 1)) { pins.RD = 0; pins.MRQ = 0; regs.TCU += 3; break; } // CHECKHERE
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            pins.RD = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 4: {
            regs.TR = pins.D;
            regs.TA |= (regs.TR << 8);
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 5: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_D9_RETI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 3: {
            regs.TR = pins.D;
            regs.TA |= (regs.TR << 8);
            regs.PC = regs.TA;
            regs.IME = 1;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_DA_JP_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.C == 1)) { regs.TCU++; }
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.PC = regs.TA;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // cleanup_custom
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_DB_NONE(regs &regs, pins &pins)
{
}

void ins_DC_CALL_cond_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            if (!(regs.F.C == 1)) { regs.TCU += 3; break; } // CHECKHERE
            break; }
        case 3: {
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 4: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 5: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = regs.TA;
            // Following is auto-generated code for instruction finish
            break; }
        case 6: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_DD_NONE(regs &regs, pins &pins)
{
}

void ins_DE_SBC_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = ((regs.A) - (regs.TR) - regs.F.C) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.TR) &0x0F) - regs.F.C) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.TR = x & 0xFF;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_DF_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0018;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_E0_LDH_addr_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do write
            regs.TA = pins.D;
            regs.TA |= 0xFF00;
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_E1_POP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.L = pins.D;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs.H = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_E2_LDH_ind_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do write
            regs.TA = 0xFF00 | regs.C;
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_E3_NONE(regs &regs, pins &pins)
{
}

void ins_E4_NONE(regs &regs, pins &pins)
{
}

void ins_E5_PUSH_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.H;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.L;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_E6_AND_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.TR = (regs.A) & (regs.TR);
            regs.F.C = regs.F.N = 0;
            regs.F.H = 1;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_E7_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0020;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_E8_ADD_di_rel(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TR = pins.D;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 3: {
            u32 target = regs.SP;
            regs.F.C = +(((target & 0xFF) + regs.TR) > 0xFF);
            regs.F.H = +(((target & 0x0F) + (regs.TR & 0x0F)) > 0x0F);
            regs.F.N = regs.F.Z = 0;
            target = (target + (i32)(i8)regs.TR) & 0xFFFF;
            regs.SP = target;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_E9_JP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.PC = (regs.H << 8) | regs.L;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_EA_LD_addr_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { // Do write
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            pins.Addr = (regs.TA);
            pins.D = regs.A;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_EB_NONE(regs &regs, pins &pins)
{
}

void ins_EC_NONE(regs &regs, pins &pins)
{
}

void ins_ED_NONE(regs &regs, pins &pins)
{
}

void ins_EE_XOR_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.TR = (regs.A) ^ (regs.TR);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_EF_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0028;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_F0_LDH_di_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            regs.TA |= 0xFF00;
            pins.Addr = (regs.TA);
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs.A = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_F1_POP_di_AF(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.SP);
            break; }
        case 2: { // Do read
            regs.TR = pins.D;
            regs.F.setbyte(regs.TR & 0xF0);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            pins.Addr = (regs.SP);
            regs.SP = (regs.SP + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            break; }
        case 3: { // cleanup_custom
            regs.A = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_F2_LDH_di_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = 0xFF00 | regs.C;
            pins.Addr = (regs.TA);
            // Following is auto-generated code for instruction finish
            break; }
        case 2: { // cleanup_custom
            regs.A = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_F3_DI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.IME = 0;
            //console.log('DI!');
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_F4_NONE(regs &regs, pins &pins)
{
}

void ins_F5_PUSH_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.A;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.F.getbyte();
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_F6_OR_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.TR = (regs.A) | (regs.TR);
            regs.F.C = regs.F.N = regs.F.H = 0;
            regs.F.Z = +((regs.TR) == 0);
            regs.A = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_F7_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0030;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_F8_LD_di_di_rel(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: {
            regs.TR = pins.D;
            u32 source = regs.SP;
            regs.F.C = +(((source & 0xFF) + regs.TR) > 0xFF);
            regs.F.H = +(((source & 0x0F) + (regs.TR & 0x0F)) > 0x0F);
            regs.F.N = regs.F.Z = 0;
            source = (source + (i32)(i8)regs.TR) & 0xFFFF;
            regs.H = (source & 0xFF00) >> 8;
            regs.L = source & 0xFF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_F9_LD16_di_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.H << 8) | regs.L;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_FA_LD_di_addr(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // Do read
            regs.TA = pins.D;
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 3: { // Do read
            regs.RR = pins.D;
            regs.TA |= (regs.RR << 8);
            pins.Addr = (regs.TA);
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            regs.A = pins.D;
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_FB_EI(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            //console.log('EI!');
            regs.IME_DELAY = 2;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_FC_NONE(regs &regs, pins &pins)
{
}

void ins_FD_NONE(regs &regs, pins &pins)
{
}

void ins_FE_CP_di_da(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = (regs.PC);
            regs.PC = (regs.PC + 1) & 0xFFFF;
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            u32 x = ((regs.A) - (regs.TR)) & 0xFFFF;
            u32 y = (((regs.A) & 0x0F) - ((regs.TR) & 0x0F)) & 0xFFFF;
            regs.F.C = +(x > 0xFF);
            regs.F.H = +(y > 0x0F);
            regs.F.N = 1;
            regs.F.Z = +((x & 0xFF) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_FF_RST_imp(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = regs.PC & 0xFF;
            regs.PC = 0x0038;
            // Following is auto-generated code for instruction finish
            break; }
        case 4: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_100_S_IRQ(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            regs.IME = 0;
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: {
            regs.PC = (regs.PC - 1) & 0xFFFF;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            break; }
        case 3: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF00) >> 8;
            regs.SP = (regs.SP - 1) & 0xFFFF;
            pins.WR = 1; pins.MRQ = 1;
            break; }
        case 4: { // Do write
            pins.Addr = (regs.SP);
            pins.D = (regs.PC & 0xFF);
            break; }
        case 5: {
            regs.PC = regs.IV;
            // Following is auto-generated code for instruction finish
            pins.WR = 0; pins.MRQ = 0;
            break; }
        case 6: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_101_RESET(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: {
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.MRQ = 0;
            break; }
        case 2: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.MRQ = 1;
            break;
    }}
}

void ins_CB00_RLC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = ((regs.B << 1) | (regs.B >> 7)) & 0xFF;
            regs.F.C = regs.B & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB01_RLC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = ((regs.C << 1) | (regs.C >> 7)) & 0xFF;
            regs.F.C = regs.C & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB02_RLC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = ((regs.D << 1) | (regs.D >> 7)) & 0xFF;
            regs.F.C = regs.D & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB03_RLC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = ((regs.E << 1) | (regs.E >> 7)) & 0xFF;
            regs.F.C = regs.E & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB04_RLC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = ((regs.H << 1) | (regs.H >> 7)) & 0xFF;
            regs.F.C = regs.H & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB05_RLC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = ((regs.L << 1) | (regs.L >> 7)) & 0xFF;
            regs.F.C = regs.L & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB06_RLC_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR = ((regs.TR << 1) | (regs.TR >> 7)) & 0xFF;
            regs.F.C = regs.TR & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB07_RLC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = ((regs.A << 1) | (regs.A >> 7)) & 0xFF;
            regs.F.C = regs.A & 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB08_RRC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = (((regs.B) << 7) | ((regs.B) >> 1)) & 0xFF;
            regs.F.C = ((regs.B) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB09_RRC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = (((regs.C) << 7) | ((regs.C) >> 1)) & 0xFF;
            regs.F.C = ((regs.C) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB0A_RRC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = (((regs.D) << 7) | ((regs.D) >> 1)) & 0xFF;
            regs.F.C = ((regs.D) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB0B_RRC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = (((regs.E) << 7) | ((regs.E) >> 1)) & 0xFF;
            regs.F.C = ((regs.E) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB0C_RRC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = (((regs.H) << 7) | ((regs.H) >> 1)) & 0xFF;
            regs.F.C = ((regs.H) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB0D_RRC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = (((regs.L) << 7) | ((regs.L) >> 1)) & 0xFF;
            regs.F.C = ((regs.L) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB0E_RRC_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR = (((regs.TR) << 7) | ((regs.TR) >> 1)) & 0xFF;
            regs.F.C = ((regs.TR) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB0F_RRC_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = (((regs.A) << 7) | ((regs.A) >> 1)) & 0xFF;
            regs.F.C = ((regs.A) & 0x80) >> 7;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB10_RL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.B) & 0x80) >> 7;
            regs.B = (((regs.B) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB11_RL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.C) & 0x80) >> 7;
            regs.C = (((regs.C) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB12_RL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.D) & 0x80) >> 7;
            regs.D = (((regs.D) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB13_RL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.E) & 0x80) >> 7;
            regs.E = (((regs.E) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB14_RL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.H) & 0x80) >> 7;
            regs.H = (((regs.H) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB15_RL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.L) & 0x80) >> 7;
            regs.L = (((regs.L) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB16_RL_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            u32 carry = ((regs.TR) & 0x80) >> 7;
            regs.TR = (((regs.TR) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB17_RL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.A) & 0x80) >> 7;
            regs.A = (((regs.A) << 1) & 0xFE) | regs.F.C;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB18_RR_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.B) & 1;
            regs.B = ((regs.B) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB19_RR_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.C) & 1;
            regs.C = ((regs.C) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB1A_RR_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.D) & 1;
            regs.D = ((regs.D) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB1B_RR_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.E) & 1;
            regs.E = ((regs.E) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB1C_RR_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.H) & 1;
            regs.H = ((regs.H) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB1D_RR_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.L) & 1;
            regs.L = ((regs.L) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB1E_RR_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            u32 carry = (regs.TR) & 1;
            regs.TR = ((regs.TR) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB1F_RR_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.A) & 1;
            regs.A = ((regs.A) >> 1) | (regs.F.C << 7);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB20_SLA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.B) & 0x80) >> 7;
            regs.B = ((regs.B) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB21_SLA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.C) & 0x80) >> 7;
            regs.C = ((regs.C) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB22_SLA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.D) & 0x80) >> 7;
            regs.D = ((regs.D) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB23_SLA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.E) & 0x80) >> 7;
            regs.E = ((regs.E) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB24_SLA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.H) & 0x80) >> 7;
            regs.H = ((regs.H) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB25_SLA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.L) & 0x80) >> 7;
            regs.L = ((regs.L) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB26_SLA_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            u32 carry = ((regs.TR) & 0x80) >> 7;
            regs.TR = ((regs.TR) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB27_SLA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = ((regs.A) & 0x80) >> 7;
            regs.A = ((regs.A) << 1) & 0xFF;
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB28_SRA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.B) & 1;
            regs.B = ((regs.B) & 0x80) | ((regs.B) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB29_SRA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.C) & 1;
            regs.C = ((regs.C) & 0x80) | ((regs.C) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB2A_SRA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.D) & 1;
            regs.D = ((regs.D) & 0x80) | ((regs.D) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB2B_SRA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.E) & 1;
            regs.E = ((regs.E) & 0x80) | ((regs.E) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB2C_SRA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.H) & 1;
            regs.H = ((regs.H) & 0x80) | ((regs.H) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB2D_SRA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.L) & 1;
            regs.L = ((regs.L) & 0x80) | ((regs.L) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB2E_SRA_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            u32 carry = (regs.TR) & 1;
            regs.TR = ((regs.TR) & 0x80) | ((regs.TR) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB2F_SRA_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            u32 carry = (regs.A) & 1;
            regs.A = ((regs.A) & 0x80) | ((regs.A) >> 1);
            regs.F.C = carry;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB30_SWAP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = (((regs.B) << 4) | ((regs.B) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB31_SWAP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = (((regs.C) << 4) | ((regs.C) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB32_SWAP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = (((regs.D) << 4) | ((regs.D) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB33_SWAP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = (((regs.E) << 4) | ((regs.E) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB34_SWAP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = (((regs.H) << 4) | ((regs.H) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB35_SWAP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = (((regs.L) << 4) | ((regs.L) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB36_SWAP_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR = (((regs.TR) << 4) | ((regs.TR) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB37_SWAP_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = (((regs.A) << 4) | ((regs.A) >> 4)) & 0xFF;
            regs.F.C = regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB38_SRL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = (regs.B) & 1;
            regs.B = (regs.B) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.B) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB39_SRL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = (regs.C) & 1;
            regs.C = (regs.C) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.C) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB3A_SRL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = (regs.D) & 1;
            regs.D = (regs.D) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.D) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB3B_SRL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = (regs.E) & 1;
            regs.E = (regs.E) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.E) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB3C_SRL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = (regs.H) & 1;
            regs.H = (regs.H) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.H) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB3D_SRL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = (regs.L) & 1;
            regs.L = (regs.L) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.L) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB3E_SRL_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.F.C = (regs.TR) & 1;
            regs.TR = (regs.TR) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.TR) == 0);
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB3F_SRL_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.C = (regs.A) & 1;
            regs.A = (regs.A) >> 1;
            regs.F.H = regs.F.N = 0;
            regs.F.Z = +((regs.A) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB40_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB41_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB42_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB43_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB44_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB45_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB46_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB47_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 1) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB48_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB49_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB4A_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB4B_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB4C_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB4D_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB4E_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB4F_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 2) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB50_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB51_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB52_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB53_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB54_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB55_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB56_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB57_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 4) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB58_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB59_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB5A_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB5B_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB5C_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB5D_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB5E_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB5F_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 8) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB60_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB61_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB62_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB63_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB64_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB65_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB66_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB67_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 16) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB68_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB69_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB6A_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB6B_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB6C_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB6D_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB6E_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB6F_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 32) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB70_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB71_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB72_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB73_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB74_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB75_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB76_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB77_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 64) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB78_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.B & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB79_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.C & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB7A_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.D & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB7B_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.E & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB7C_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.H & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB7D_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.L & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB7E_BIT_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            pins.Addr = ((regs.H << 8) | regs.L);
            break; }
        case 2: { // cleanup_custom
            regs.TR = pins.D;
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.TR & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB7F_BIT_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.F.H = 1;
            regs.F.N = 0;
            regs.F.Z = +((regs.A & 128) == 0);
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB80_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB81_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB82_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB83_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB84_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB85_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB86_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0xFE;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB87_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0xFE;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB88_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB89_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB8A_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB8B_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB8C_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB8D_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB8E_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0xFD;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB8F_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0xFD;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB90_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB91_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB92_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB93_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB94_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB95_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB96_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0xFB;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB97_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0xFB;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB98_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB99_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB9A_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB9B_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB9C_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB9D_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CB9E_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0xF7;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CB9F_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0xF7;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA0_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA1_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA2_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA3_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA4_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA5_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA6_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0xEF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBA7_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA8_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBA9_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBAA_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBAB_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBAC_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBAD_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBAE_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0xDF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBAF_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0xDF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB0_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB1_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB2_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB3_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB4_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB5_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB6_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0xBF;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBB7_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0xBF;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB8_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBB9_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBBA_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBBB_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBBC_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBBD_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBBE_RES_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            pins.Addr = (regs.TA);
            pins.D = regs.TR & 0x7F;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBBF_RES_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A &= 0x7F;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC0_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x01;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC1_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x01;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC2_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x01;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC3_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x01;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC4_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x01;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC5_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x01;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC6_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x01;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBC7_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x01;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC8_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x02;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBC9_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x02;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBCA_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x02;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBCB_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x02;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBCC_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x02;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBCD_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x02;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBCE_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x02;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBCF_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x02;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD0_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x04;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD1_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x04;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD2_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x04;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD3_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x04;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD4_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x04;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD5_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x04;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD6_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x04;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBD7_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x04;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD8_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x08;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBD9_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x08;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBDA_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x08;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBDB_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x08;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBDC_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x08;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBDD_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x08;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBDE_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x08;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBDF_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x08;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE0_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x10;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE1_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x10;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE2_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x10;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE3_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x10;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE4_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x10;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE5_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x10;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE6_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x10;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBE7_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x10;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE8_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x20;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBE9_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x20;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBEA_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x20;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBEB_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x20;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBEC_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x20;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBED_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x20;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBEE_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x20;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBEF_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x20;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF0_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x40;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF1_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x40;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF2_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x40;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF3_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x40;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF4_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x40;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF5_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x40;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF6_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x40;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBF7_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x40;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF8_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.B = regs.B | 0x80;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBF9_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.C = regs.C | 0x80;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBFA_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.D = regs.D | 0x80;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBFB_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.E = regs.E | 0x80;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBFC_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.H = regs.H | 0x80;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBFD_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.L = regs.L | 0x80;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

void ins_CBFE_SET_idx_ind(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // Do read
            regs.TA = (regs.H << 8) | regs.L;
            pins.Addr = (regs.TA);
            break; }
        case 2: { // Do write
            regs.TR = pins.D;
            regs.TR |= 0x80;
            pins.Addr = (regs.TA);
            pins.D = regs.TR;
            // Following is auto-generated code for instruction finish
            pins.RD = 0; pins.WR = 1;
            break; }
        case 3: { // cleanup_custom
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            pins.RD = 1; pins.WR = 0;
            break;
    }}
}

void ins_CBFF_SET_idx_di(regs &regs, pins &pins)
{
    switch(regs.TCU) {
        case 1: { // cleanup_custom
            regs.A = regs.A | 0x80;
            // Following is auto-generated code for instruction finish
            pins.Addr = regs.PC;
            regs.PC = (regs.PC + 1) & 0xFFFF;
            regs.TCU = 0;
            regs.IR = INS_DECODE;
            regs.poll_IRQ = true;
            break;
    }}
}

ins_func decoded_opcodes[0x202] = {
        &ins_00_NOP,   &ins_01_LD16_di_da,   &ins_02_LD_ind_di,   &ins_03_INC16_di,   &ins_04_INC_di,
        &ins_05_DEC_di,   &ins_06_LD_di_da,   &ins_07_RLCA,   &ins_08_LD16_addr_di,   &ins_09_ADD16_di_di,
        &ins_0A_LD_di_ind,   &ins_0B_DEC16_di,   &ins_0C_INC_di,   &ins_0D_DEC_di,   &ins_0E_LD_di_da,
        &ins_0F_RRCA,   &ins_10_STOP,   &ins_11_LD16_di_da,   &ins_12_LD_ind_di,   &ins_13_INC16_di,
        &ins_14_INC_di,   &ins_15_DEC_di,   &ins_16_LD_di_da,   &ins_17_RLA,   &ins_18_JR_cond_rel,
        &ins_19_ADD16_di_di,   &ins_1A_LD_di_ind,   &ins_1B_DEC16_di,   &ins_1C_INC_di,   &ins_1D_DEC_di,
        &ins_1E_LD_di_da,   &ins_1F_RRA,   &ins_20_JR_cond_rel,   &ins_21_LD16_di_da,   &ins_22_LD_ind_inc_di,
        &ins_23_INC16_di,   &ins_24_INC_di,   &ins_25_DEC_di,   &ins_26_LD_di_da,   &ins_27_DAA,
        &ins_28_JR_cond_rel,   &ins_29_ADD16_di_di,   &ins_2A_LD_di_ind_inc,   &ins_2B_DEC16_di,   &ins_2C_INC_di,
        &ins_2D_DEC_di,   &ins_2E_LD_di_da,   &ins_2F_CPL,   &ins_30_JR_cond_rel,   &ins_31_LD16_di_da,
        &ins_32_LD_ind_dec_di,   &ins_33_INC16_di,   &ins_34_INC_ind,   &ins_35_DEC_ind,   &ins_36_LD_ind_da,
        &ins_37_SCF,   &ins_38_JR_cond_rel,   &ins_39_ADD16_di_di,   &ins_3A_LD_di_ind_dec,   &ins_3B_DEC16_di,
        &ins_3C_INC_di,   &ins_3D_DEC_di,   &ins_3E_LD_di_da,   &ins_3F_CCF,   &ins_40_LD_di_di,
        &ins_41_LD_di_di,   &ins_42_LD_di_di,   &ins_43_LD_di_di,   &ins_44_LD_di_di,   &ins_45_LD_di_di,
        &ins_46_LD_di_ind,   &ins_47_LD_di_di,   &ins_48_LD_di_di,   &ins_49_LD_di_di,   &ins_4A_LD_di_di,
        &ins_4B_LD_di_di,   &ins_4C_LD_di_di,   &ins_4D_LD_di_di,   &ins_4E_LD_di_ind,   &ins_4F_LD_di_di,
        &ins_50_LD_di_di,   &ins_51_LD_di_di,   &ins_52_LD_di_di,   &ins_53_LD_di_di,   &ins_54_LD_di_di,
        &ins_55_LD_di_di,   &ins_56_LD_di_ind,   &ins_57_LD_di_di,   &ins_58_LD_di_di,   &ins_59_LD_di_di,
        &ins_5A_LD_di_di,   &ins_5B_LD_di_di,   &ins_5C_LD_di_di,   &ins_5D_LD_di_di,   &ins_5E_LD_di_ind,
        &ins_5F_LD_di_di,   &ins_60_LD_di_di,   &ins_61_LD_di_di,   &ins_62_LD_di_di,   &ins_63_LD_di_di,
        &ins_64_LD_di_di,   &ins_65_LD_di_di,   &ins_66_LD_di_ind,   &ins_67_LD_di_di,   &ins_68_LD_di_di,
        &ins_69_LD_di_di,   &ins_6A_LD_di_di,   &ins_6B_LD_di_di,   &ins_6C_LD_di_di,   &ins_6D_LD_di_di,
        &ins_6E_LD_di_ind,   &ins_6F_LD_di_di,   &ins_70_LD_ind_di,   &ins_71_LD_ind_di,   &ins_72_LD_ind_di,
        &ins_73_LD_ind_di,   &ins_74_LD_ind_di,   &ins_75_LD_ind_di,   &ins_76_HALT,   &ins_77_LD_ind_di,
        &ins_78_LD_di_di,   &ins_79_LD_di_di,   &ins_7A_LD_di_di,   &ins_7B_LD_di_di,   &ins_7C_LD_di_di,
        &ins_7D_LD_di_di,   &ins_7E_LD_di_ind,   &ins_7F_LD_di_di,   &ins_80_ADD_di_di,   &ins_81_ADD_di_di,
        &ins_82_ADD_di_di,   &ins_83_ADD_di_di,   &ins_84_ADD_di_di,   &ins_85_ADD_di_di,   &ins_86_ADD_di_ind,
        &ins_87_ADD_di_di,   &ins_88_ADC_di_di,   &ins_89_ADC_di_di,   &ins_8A_ADC_di_di,   &ins_8B_ADC_di_di,
        &ins_8C_ADC_di_di,   &ins_8D_ADC_di_di,   &ins_8E_ADC_di_ind,   &ins_8F_ADC_di_di,   &ins_90_SUB_di_di,
        &ins_91_SUB_di_di,   &ins_92_SUB_di_di,   &ins_93_SUB_di_di,   &ins_94_SUB_di_di,   &ins_95_SUB_di_di,
        &ins_96_SUB_di_ind,   &ins_97_SUB_di_di,   &ins_98_SBC_di_di,   &ins_99_SBC_di_di,   &ins_9A_SBC_di_di,
        &ins_9B_SBC_di_di,   &ins_9C_SBC_di_di,   &ins_9D_SBC_di_di,   &ins_9E_SBC_di_ind,   &ins_9F_SBC_di_di,
        &ins_A0_AND_di_di,   &ins_A1_AND_di_di,   &ins_A2_AND_di_di,   &ins_A3_AND_di_di,   &ins_A4_AND_di_di,
        &ins_A5_AND_di_di,   &ins_A6_AND_di_ind,   &ins_A7_AND_di_di,   &ins_A8_XOR_di_di,   &ins_A9_XOR_di_di,
        &ins_AA_XOR_di_di,   &ins_AB_XOR_di_di,   &ins_AC_XOR_di_di,   &ins_AD_XOR_di_di,   &ins_AE_XOR_di_ind,
        &ins_AF_XOR_di_di,   &ins_B0_OR_di_di,   &ins_B1_OR_di_di,   &ins_B2_OR_di_di,   &ins_B3_OR_di_di,
        &ins_B4_OR_di_di,   &ins_B5_OR_di_di,   &ins_B6_OR_di_ind,   &ins_B7_OR_di_di,   &ins_B8_CP_di_di,
        &ins_B9_CP_di_di,   &ins_BA_CP_di_di,   &ins_BB_CP_di_di,   &ins_BC_CP_di_di,   &ins_BD_CP_di_di,
        &ins_BE_CP_di_ind,   &ins_BF_CP_di_di,   &ins_C0_RET_cond,   &ins_C1_POP_di,   &ins_C2_JP_cond_addr,
        &ins_C3_JP_cond_addr,   &ins_C4_CALL_cond_addr,   &ins_C5_PUSH_di,   &ins_C6_ADD_di_da,   &ins_C7_RST_imp,
        &ins_C8_RET_cond,   &ins_C9_RET,   &ins_CA_JP_cond_addr,   &ins_CB_NONE,&ins_CC_CALL_cond_addr,   &ins_CD_CALL_cond_addr,
        &ins_CE_ADC_di_da,   &ins_CF_RST_imp,   &ins_D0_RET_cond,   &ins_D1_POP_di,   &ins_D2_JP_cond_addr,
        &ins_D3_NONE,   &ins_D4_CALL_cond_addr,   &ins_D5_PUSH_di,   &ins_D6_SUB_di_da,   &ins_D7_RST_imp,
        &ins_D8_RET_cond,   &ins_D9_RETI,   &ins_DA_JP_cond_addr,   &ins_DB_NONE,   &ins_DC_CALL_cond_addr,
        &ins_DD_NONE,   &ins_DE_SBC_di_da,   &ins_DF_RST_imp,   &ins_E0_LDH_addr_di,   &ins_E1_POP_di,
        &ins_E2_LDH_ind_di,   &ins_E3_NONE,   &ins_E4_NONE,   &ins_E5_PUSH_di,   &ins_E6_AND_di_da,
        &ins_E7_RST_imp,   &ins_E8_ADD_di_rel,   &ins_E9_JP_di,   &ins_EA_LD_addr_di,   &ins_EB_NONE,
        &ins_EC_NONE,   &ins_ED_NONE,   &ins_EE_XOR_di_da,   &ins_EF_RST_imp,   &ins_F0_LDH_di_addr,
        &ins_F1_POP_di_AF,   &ins_F2_LDH_di_ind,   &ins_F3_DI,   &ins_F4_NONE,   &ins_F5_PUSH_di,
        &ins_F6_OR_di_da,   &ins_F7_RST_imp,   &ins_F8_LD_di_di_rel,   &ins_F9_LD16_di_di,   &ins_FA_LD_di_addr,
        &ins_FB_EI,   &ins_FC_NONE,   &ins_FD_NONE,   &ins_FE_CP_di_da,   &ins_FF_RST_imp,
        &ins_100_S_IRQ,   &ins_101_RESET,
        &ins_CB00_RLC_di,   &ins_CB01_RLC_di,   &ins_CB02_RLC_di,   &ins_CB03_RLC_di,   &ins_CB04_RLC_di,
        &ins_CB05_RLC_di,   &ins_CB06_RLC_ind,   &ins_CB07_RLC_di,   &ins_CB08_RRC_di,   &ins_CB09_RRC_di,
        &ins_CB0A_RRC_di,   &ins_CB0B_RRC_di,   &ins_CB0C_RRC_di,   &ins_CB0D_RRC_di,   &ins_CB0E_RRC_ind,
        &ins_CB0F_RRC_di,   &ins_CB10_RL_di,   &ins_CB11_RL_di,   &ins_CB12_RL_di,   &ins_CB13_RL_di,
        &ins_CB14_RL_di,   &ins_CB15_RL_di,   &ins_CB16_RL_ind,   &ins_CB17_RL_di,   &ins_CB18_RR_di,
        &ins_CB19_RR_di,   &ins_CB1A_RR_di,   &ins_CB1B_RR_di,   &ins_CB1C_RR_di,   &ins_CB1D_RR_di,
        &ins_CB1E_RR_ind,   &ins_CB1F_RR_di,   &ins_CB20_SLA_di,   &ins_CB21_SLA_di,   &ins_CB22_SLA_di,
        &ins_CB23_SLA_di,   &ins_CB24_SLA_di,   &ins_CB25_SLA_di,   &ins_CB26_SLA_ind,   &ins_CB27_SLA_di,
        &ins_CB28_SRA_di,   &ins_CB29_SRA_di,   &ins_CB2A_SRA_di,   &ins_CB2B_SRA_di,   &ins_CB2C_SRA_di,
        &ins_CB2D_SRA_di,   &ins_CB2E_SRA_ind,   &ins_CB2F_SRA_di,   &ins_CB30_SWAP_di,   &ins_CB31_SWAP_di,
        &ins_CB32_SWAP_di,   &ins_CB33_SWAP_di,   &ins_CB34_SWAP_di,   &ins_CB35_SWAP_di,   &ins_CB36_SWAP_ind,
        &ins_CB37_SWAP_di,   &ins_CB38_SRL_di,   &ins_CB39_SRL_di,   &ins_CB3A_SRL_di,   &ins_CB3B_SRL_di,
        &ins_CB3C_SRL_di,   &ins_CB3D_SRL_di,   &ins_CB3E_SRL_ind,   &ins_CB3F_SRL_di,   &ins_CB40_BIT_idx_di,
        &ins_CB41_BIT_idx_di,   &ins_CB42_BIT_idx_di,   &ins_CB43_BIT_idx_di,   &ins_CB44_BIT_idx_di,   &ins_CB45_BIT_idx_di,
        &ins_CB46_BIT_idx_ind,   &ins_CB47_BIT_idx_di,   &ins_CB48_BIT_idx_di,   &ins_CB49_BIT_idx_di,   &ins_CB4A_BIT_idx_di,
        &ins_CB4B_BIT_idx_di,   &ins_CB4C_BIT_idx_di,   &ins_CB4D_BIT_idx_di,   &ins_CB4E_BIT_idx_ind,   &ins_CB4F_BIT_idx_di,
        &ins_CB50_BIT_idx_di,   &ins_CB51_BIT_idx_di,   &ins_CB52_BIT_idx_di,   &ins_CB53_BIT_idx_di,   &ins_CB54_BIT_idx_di,
        &ins_CB55_BIT_idx_di,   &ins_CB56_BIT_idx_ind,   &ins_CB57_BIT_idx_di,   &ins_CB58_BIT_idx_di,   &ins_CB59_BIT_idx_di,
        &ins_CB5A_BIT_idx_di,   &ins_CB5B_BIT_idx_di,   &ins_CB5C_BIT_idx_di,   &ins_CB5D_BIT_idx_di,   &ins_CB5E_BIT_idx_ind,
        &ins_CB5F_BIT_idx_di,   &ins_CB60_BIT_idx_di,   &ins_CB61_BIT_idx_di,   &ins_CB62_BIT_idx_di,   &ins_CB63_BIT_idx_di,
        &ins_CB64_BIT_idx_di,   &ins_CB65_BIT_idx_di,   &ins_CB66_BIT_idx_ind,   &ins_CB67_BIT_idx_di,   &ins_CB68_BIT_idx_di,
        &ins_CB69_BIT_idx_di,   &ins_CB6A_BIT_idx_di,   &ins_CB6B_BIT_idx_di,   &ins_CB6C_BIT_idx_di,   &ins_CB6D_BIT_idx_di,
        &ins_CB6E_BIT_idx_ind,   &ins_CB6F_BIT_idx_di,   &ins_CB70_BIT_idx_di,   &ins_CB71_BIT_idx_di,   &ins_CB72_BIT_idx_di,
        &ins_CB73_BIT_idx_di,   &ins_CB74_BIT_idx_di,   &ins_CB75_BIT_idx_di,   &ins_CB76_BIT_idx_ind,   &ins_CB77_BIT_idx_di,
        &ins_CB78_BIT_idx_di,   &ins_CB79_BIT_idx_di,   &ins_CB7A_BIT_idx_di,   &ins_CB7B_BIT_idx_di,   &ins_CB7C_BIT_idx_di,
        &ins_CB7D_BIT_idx_di,   &ins_CB7E_BIT_idx_ind,   &ins_CB7F_BIT_idx_di,   &ins_CB80_RES_idx_di,   &ins_CB81_RES_idx_di,
        &ins_CB82_RES_idx_di,   &ins_CB83_RES_idx_di,   &ins_CB84_RES_idx_di,   &ins_CB85_RES_idx_di,   &ins_CB86_RES_idx_ind,
        &ins_CB87_RES_idx_di,   &ins_CB88_RES_idx_di,   &ins_CB89_RES_idx_di,   &ins_CB8A_RES_idx_di,   &ins_CB8B_RES_idx_di,
        &ins_CB8C_RES_idx_di,   &ins_CB8D_RES_idx_di,   &ins_CB8E_RES_idx_ind,   &ins_CB8F_RES_idx_di,   &ins_CB90_RES_idx_di,
        &ins_CB91_RES_idx_di,   &ins_CB92_RES_idx_di,   &ins_CB93_RES_idx_di,   &ins_CB94_RES_idx_di,   &ins_CB95_RES_idx_di,
        &ins_CB96_RES_idx_ind,   &ins_CB97_RES_idx_di,   &ins_CB98_RES_idx_di,   &ins_CB99_RES_idx_di,   &ins_CB9A_RES_idx_di,
        &ins_CB9B_RES_idx_di,   &ins_CB9C_RES_idx_di,   &ins_CB9D_RES_idx_di,   &ins_CB9E_RES_idx_ind,   &ins_CB9F_RES_idx_di,
        &ins_CBA0_RES_idx_di,   &ins_CBA1_RES_idx_di,   &ins_CBA2_RES_idx_di,   &ins_CBA3_RES_idx_di,   &ins_CBA4_RES_idx_di,
        &ins_CBA5_RES_idx_di,   &ins_CBA6_RES_idx_ind,   &ins_CBA7_RES_idx_di,   &ins_CBA8_RES_idx_di,   &ins_CBA9_RES_idx_di,
        &ins_CBAA_RES_idx_di,   &ins_CBAB_RES_idx_di,   &ins_CBAC_RES_idx_di,   &ins_CBAD_RES_idx_di,   &ins_CBAE_RES_idx_ind,
        &ins_CBAF_RES_idx_di,   &ins_CBB0_RES_idx_di,   &ins_CBB1_RES_idx_di,   &ins_CBB2_RES_idx_di,   &ins_CBB3_RES_idx_di,
        &ins_CBB4_RES_idx_di,   &ins_CBB5_RES_idx_di,   &ins_CBB6_RES_idx_ind,   &ins_CBB7_RES_idx_di,   &ins_CBB8_RES_idx_di,
        &ins_CBB9_RES_idx_di,   &ins_CBBA_RES_idx_di,   &ins_CBBB_RES_idx_di,   &ins_CBBC_RES_idx_di,   &ins_CBBD_RES_idx_di,
        &ins_CBBE_RES_idx_ind,   &ins_CBBF_RES_idx_di,   &ins_CBC0_SET_idx_di,   &ins_CBC1_SET_idx_di,   &ins_CBC2_SET_idx_di,
        &ins_CBC3_SET_idx_di,   &ins_CBC4_SET_idx_di,   &ins_CBC5_SET_idx_di,   &ins_CBC6_SET_idx_ind,   &ins_CBC7_SET_idx_di,
        &ins_CBC8_SET_idx_di,   &ins_CBC9_SET_idx_di,   &ins_CBCA_SET_idx_di,   &ins_CBCB_SET_idx_di,   &ins_CBCC_SET_idx_di,
        &ins_CBCD_SET_idx_di,   &ins_CBCE_SET_idx_ind,   &ins_CBCF_SET_idx_di,   &ins_CBD0_SET_idx_di,   &ins_CBD1_SET_idx_di,
        &ins_CBD2_SET_idx_di,   &ins_CBD3_SET_idx_di,   &ins_CBD4_SET_idx_di,   &ins_CBD5_SET_idx_di,   &ins_CBD6_SET_idx_ind,
        &ins_CBD7_SET_idx_di,   &ins_CBD8_SET_idx_di,   &ins_CBD9_SET_idx_di,   &ins_CBDA_SET_idx_di,   &ins_CBDB_SET_idx_di,
        &ins_CBDC_SET_idx_di,   &ins_CBDD_SET_idx_di,   &ins_CBDE_SET_idx_ind,   &ins_CBDF_SET_idx_di,   &ins_CBE0_SET_idx_di,
        &ins_CBE1_SET_idx_di,   &ins_CBE2_SET_idx_di,   &ins_CBE3_SET_idx_di,   &ins_CBE4_SET_idx_di,   &ins_CBE5_SET_idx_di,
        &ins_CBE6_SET_idx_ind,   &ins_CBE7_SET_idx_di,   &ins_CBE8_SET_idx_di,   &ins_CBE9_SET_idx_di,   &ins_CBEA_SET_idx_di,
        &ins_CBEB_SET_idx_di,   &ins_CBEC_SET_idx_di,   &ins_CBED_SET_idx_di,   &ins_CBEE_SET_idx_ind,   &ins_CBEF_SET_idx_di,
        &ins_CBF0_SET_idx_di,   &ins_CBF1_SET_idx_di,   &ins_CBF2_SET_idx_di,   &ins_CBF3_SET_idx_di,   &ins_CBF4_SET_idx_di,
        &ins_CBF5_SET_idx_di,   &ins_CBF6_SET_idx_ind,   &ins_CBF7_SET_idx_di,   &ins_CBF8_SET_idx_di,   &ins_CBF9_SET_idx_di,
        &ins_CBFA_SET_idx_di,   &ins_CBFB_SET_idx_di,   &ins_CBFC_SET_idx_di,   &ins_CBFD_SET_idx_di,   &ins_CBFE_SET_idx_ind,
        &ins_CBFF_SET_idx_di,
};
}
