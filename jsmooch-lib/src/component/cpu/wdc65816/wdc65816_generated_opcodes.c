
// Auto-generated by wdc65816_core_generator.js decode_opcodes_c()
#include "wdc65816.h"



static void WDC65816_opcode_00_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRK s
        switch(regs->TCU) {
        // BRK s E=0 M=0 X=0
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE6); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE7); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_01_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,x)
        switch(regs->TCU) {
        // ORA (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_02_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // COP s
        switch(regs->TCU) {
        // COP s E=0 M=0 X=0
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE4); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE5); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_03_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,s
        switch(regs->TCU) {
        // ORA d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_04_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB d
        switch(regs->TCU) {
        // TSB d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_05_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d
        switch(regs->TCU) {
        // ORA d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_06_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d
        switch(regs->TCU) {
        // ASL d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_07_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d]
        switch(regs->TCU) {
        // ORA [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_08_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHP s
        switch(regs->TCU) {
        // PHP s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->P.v;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_09_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA #
        switch(regs->TCU) {
        // ORA # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL A
        switch(regs->TCU) {
        // ASL A E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHD s
        switch(regs->TCU) {
        // PHD s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->D);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB a
        switch(regs->TCU) {
        // TSB a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a
        switch(regs->TCU) {
        // ORA a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a
        switch(regs->TCU) {
        // ASL a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al
        switch(regs->TCU) {
        // ORA al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_10_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BPL r
        switch(regs->TCU) {
        // BPL r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_11_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d),y
        switch(regs->TCU) {
        // ORA (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_12_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d)
        switch(regs->TCU) {
        // ORA (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_13_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,s),y
        switch(regs->TCU) {
        // ORA (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_14_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB d
        switch(regs->TCU) {
        // TRB d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_15_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,x
        switch(regs->TCU) {
        // ORA d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_16_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d,x
        switch(regs->TCU) {
        // ASL d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_17_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d],y
        switch(regs->TCU) {
        // ORA [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_18_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLC i
        switch(regs->TCU) {
        // CLC i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_19_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,y
        switch(regs->TCU) {
        // ORA a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC A
        switch(regs->TCU) {
        // INC A E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCS i
        switch(regs->TCU) {
        // TCS i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->C;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB a
        switch(regs->TCU) {
        // TRB a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,x
        switch(regs->TCU) {
        // ORA a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a,x
        switch(regs->TCU) {
        // ASL a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al,x
        switch(regs->TCU) {
        // ORA al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_20_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR a
        switch(regs->TCU) {
        // JSR a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->PDV = 0;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 6
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_21_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,x)
        switch(regs->TCU) {
        // AND (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_22_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSL al
        switch(regs->TCU) {
        // JSL al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        regs->TA += pins->D << 8;
        pins->D = (regs->PBR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0; pins->PDV = 0;
                break;
            case 5: // 6
        pins->PDV = 1;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 6: // 7
        regs->PBR = pins->D;
        pins->RW = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 7: // 8
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_23_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,s
        switch(regs->TCU) {
        // AND d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_24_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d
        switch(regs->TCU) {
        // BIT d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_25_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d
        switch(regs->TCU) {
        // AND d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_26_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d
        switch(regs->TCU) {
        // ROL d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_27_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d]
        switch(regs->TCU) {
        // AND [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_28_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLP s
        switch(regs->TCU) {
        // PLP s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.v = regs->TR;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_29_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND #
        switch(regs->TCU) {
        // AND # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL A
        switch(regs->TCU) {
        // ROL A E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLD s
        switch(regs->TCU) {
        // PLD s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->D = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a
        switch(regs->TCU) {
        // BIT a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a
        switch(regs->TCU) {
        // AND a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a
        switch(regs->TCU) {
        // ROL a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al
        switch(regs->TCU) {
        // AND al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_30_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BMI r
        switch(regs->TCU) {
        // BMI r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_31_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d),y
        switch(regs->TCU) {
        // AND (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_32_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d)
        switch(regs->TCU) {
        // AND (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_33_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,s),y
        switch(regs->TCU) {
        // AND (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_34_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d,x
        switch(regs->TCU) {
        // BIT d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_35_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,x
        switch(regs->TCU) {
        // AND d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_36_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d,x
        switch(regs->TCU) {
        // ROL d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_37_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d],y
        switch(regs->TCU) {
        // AND [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_38_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEC i
        switch(regs->TCU) {
        // SEC i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_39_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,y
        switch(regs->TCU) {
        // AND a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC A
        switch(regs->TCU) {
        // DEC A E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSC i
        switch(regs->TCU) {
        // TSC i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->S);
        regs->P.Z = +((regs->S) == 0);
        regs->P.N = ((regs->S) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a,x
        switch(regs->TCU) {
        // BIT a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,x
        switch(regs->TCU) {
        // AND a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a,x
        switch(regs->TCU) {
        // ROL a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al,x
        switch(regs->TCU) {
        // AND al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_40_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTI s
        switch(regs->TCU) {
        // RTI s E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        pins->PDV = 1;
                break;
            case 4: // 5
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->P.v = pins->D;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x100;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA = pins->D;
                break;
            case 6: // 7
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA += pins->D << 8;
                break;
            case 7: // cleanup_custom
        regs->PC = regs->TA;
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_41_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,x)
        switch(regs->TCU) {
        // EOR (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_42_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WDM i
        switch(regs->TCU) {
        // WDM i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_43_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,s
        switch(regs->TCU) {
        // EOR d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_44_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVP xyc
        switch(regs->TCU) {
        // MVP xyc E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = (regs->X); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = (regs->Y); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
                break;
            case 7: // cleanup_custom
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X - 1) & 0xFFFF;
        regs->Y = (regs->Y - 1) & 0xFFFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_45_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d
        switch(regs->TCU) {
        // EOR d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_46_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d
        switch(regs->TCU) {
        // LSR d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_47_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d]
        switch(regs->TCU) {
        // EOR [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_48_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHA s
        switch(regs->TCU) {
        // PHA s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->C);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_49_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR #
        switch(regs->TCU) {
        // EOR # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR A
        switch(regs->TCU) {
        // LSR A E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHK s
        switch(regs->TCU) {
        // PHK s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->PBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP a
        switch(regs->TCU) {
        // JMP a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a
        switch(regs->TCU) {
        // EOR a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a
        switch(regs->TCU) {
        // LSR a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al
        switch(regs->TCU) {
        // EOR al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_50_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVC r
        switch(regs->TCU) {
        // BVC r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_51_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d),y
        switch(regs->TCU) {
        // EOR (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_52_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d)
        switch(regs->TCU) {
        // EOR (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_53_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,s),y
        switch(regs->TCU) {
        // EOR (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_54_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVN xyc
        switch(regs->TCU) {
        // MVN xyc E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = ((regs->X + regs->MD) & 0xFFFF); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = ((regs->Y + regs->MD) & 0xFFFF); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X + 1) & 0xFFFF;
        regs->Y = (regs->Y + 1) & 0xFFFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_55_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,x
        switch(regs->TCU) {
        // EOR d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_56_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d,x
        switch(regs->TCU) {
        // LSR d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_57_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d],y
        switch(regs->TCU) {
        // EOR [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_58_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLI i
        switch(regs->TCU) {
        // CLI i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_59_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,y
        switch(regs->TCU) {
        // EOR a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHY s
        switch(regs->TCU) {
        // PHY s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->Y);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCD i
        switch(regs->TCU) {
        // TCD i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->D = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP al
        switch(regs->TCU) {
        // JMP al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = regs->TA + (pins->D << 8);
                break;
            case 4: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,x
        switch(regs->TCU) {
        // EOR a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a,x
        switch(regs->TCU) {
        // LSR a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al,x
        switch(regs->TCU) {
        // EOR al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_60_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTS s
        switch(regs->TCU) {
        // RTS s E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_61_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,x)
        switch(regs->TCU) {
        // ADC (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_62_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PER s
        switch(regs->TCU) {
        // PER s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = (regs->PC + regs->TR + (pins->D << 8)) & 0xFFFF;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
                break;
            case 6: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_63_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,s
        switch(regs->TCU) {
        // ADC d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_64_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d
        switch(regs->TCU) {
        // STZ d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_65_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d
        switch(regs->TCU) {
        // ADC d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_66_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d
        switch(regs->TCU) {
        // ROR d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_67_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d]
        switch(regs->TCU) {
        // ADC [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_68_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLA s
        switch(regs->TCU) {
        // PLA s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->C = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_69_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC #
        switch(regs->TCU) {
        // ADC # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR A
        switch(regs->TCU) {
        // ROR A E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTL s
        switch(regs->TCU) {
        // RTL s E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a)
        switch(regs->TCU) {
        // JMP (a) E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a
        switch(regs->TCU) {
        // ADC a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a
        switch(regs->TCU) {
        // ROR a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al
        switch(regs->TCU) {
        // ADC al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_70_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVS r
        switch(regs->TCU) {
        // BVS r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_71_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d),y
        switch(regs->TCU) {
        // ADC (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_72_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d)
        switch(regs->TCU) {
        // ADC (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_73_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,s),y
        switch(regs->TCU) {
        // ADC (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_74_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d,x
        switch(regs->TCU) {
        // STZ d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_75_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,x
        switch(regs->TCU) {
        // ADC d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_76_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d,x
        switch(regs->TCU) {
        // ROR d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_77_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d],y
        switch(regs->TCU) {
        // ADC [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_78_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEI i
        switch(regs->TCU) {
        // SEI i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_79_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,y
        switch(regs->TCU) {
        // ADC a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLY s
        switch(regs->TCU) {
        // PLY s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TDC i
        switch(regs->TCU) {
        // TDC i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->D);
        regs->P.Z = +((regs->D) == 0);
        regs->P.N = ((regs->D) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a,x)
        switch(regs->TCU) {
        // JMP (a,x) E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        regs->TA = (regs->X + regs->TA) & 0xFFFF;
        pins->PDV = 0;
                break;
            case 4:
        pins->PDV = 1;
        pins->Addr = regs->TA; pins->BA = regs->PBR;
                break;
            case 5:
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,x
        switch(regs->TCU) {
        // ADC a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a,x
        switch(regs->TCU) {
        // ROR a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al,x
        switch(regs->TCU) {
        // ADC al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_80_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRA r
        switch(regs->TCU) {
        // BRA r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_81_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,x)
        switch(regs->TCU) {
        // STA (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_82_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRL rl
        switch(regs->TCU) {
        // BRL rl E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TA = (u32)(i16)(regs->TA + (pins->D << 8));
        regs->PC = (regs->PC + regs->TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_83_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,s
        switch(regs->TCU) {
        // STA d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_84_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d
        switch(regs->TCU) {
        // STY d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_85_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d
        switch(regs->TCU) {
        // STA d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_86_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d
        switch(regs->TCU) {
        // STX d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_87_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d]
        switch(regs->TCU) {
        // STA [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_88_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEY i
        switch(regs->TCU) {
        // DEY i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) - 1) & 0xFFFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_89_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT #
        switch(regs->TCU) {
        // BIT # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXA i
        switch(regs->TCU) {
        // TXA i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->X);
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHB s
        switch(regs->TCU) {
        // PHB s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->DBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY a
        switch(regs->TCU) {
        // STY a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->Y;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a
        switch(regs->TCU) {
        // STA a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX a
        switch(regs->TCU) {
        // STX a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->X;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al
        switch(regs->TCU) {
        // STA al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 5a
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_90_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCC r
        switch(regs->TCU) {
        // BCC r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_91_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d),y
        switch(regs->TCU) {
        // STA (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_92_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d)
        switch(regs->TCU) {
        // STA (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 6: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_93_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,s),y
        switch(regs->TCU) {
        // STA (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_94_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d,x
        switch(regs->TCU) {
        // STY d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_95_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,x
        switch(regs->TCU) {
        // STA d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_96_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d,y
        switch(regs->TCU) {
        // STX d,y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_97_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d],y
        switch(regs->TCU) {
        // STA [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_98_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYA i
        switch(regs->TCU) {
        // TYA i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->Y);
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_99_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,y
        switch(regs->TCU) {
        // STA a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9A_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXS i
        switch(regs->TCU) {
        // TXS i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->X;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9B_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXY i
        switch(regs->TCU) {
        // TXY i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = (regs->X);
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9C_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a
        switch(regs->TCU) {
        // STZ a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9D_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,x
        switch(regs->TCU) {
        // STA a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9E_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a,x
        switch(regs->TCU) {
        // STZ a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9F_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al,x
        switch(regs->TCU) {
        // STA al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A0_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY #
        switch(regs->TCU) {
        // LDY # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A1_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,x)
        switch(regs->TCU) {
        // LDA (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A2_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX #
        switch(regs->TCU) {
        // LDX # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A3_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,s
        switch(regs->TCU) {
        // LDA d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A4_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d
        switch(regs->TCU) {
        // LDY d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A5_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d
        switch(regs->TCU) {
        // LDA d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A6_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d
        switch(regs->TCU) {
        // LDX d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A7_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d]
        switch(regs->TCU) {
        // LDA [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A8_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAY i
        switch(regs->TCU) {
        // TAY i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A9_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA #
        switch(regs->TCU) {
        // LDA # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AA_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAX i
        switch(regs->TCU) {
        // TAX i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AB_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLB s
        switch(regs->TCU) {
        // PLB s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->DBR = ((regs->DBR) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AC_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a
        switch(regs->TCU) {
        // LDY a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AD_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a
        switch(regs->TCU) {
        // LDA a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AE_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a
        switch(regs->TCU) {
        // LDX a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AF_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al
        switch(regs->TCU) {
        // LDA al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B0_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCS r
        switch(regs->TCU) {
        // BCS r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B1_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d),y
        switch(regs->TCU) {
        // LDA (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B2_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d)
        switch(regs->TCU) {
        // LDA (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B3_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,s),y
        switch(regs->TCU) {
        // LDA (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B4_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d,x
        switch(regs->TCU) {
        // LDY d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B5_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,x
        switch(regs->TCU) {
        // LDA d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B6_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d,y
        switch(regs->TCU) {
        // LDX d,y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B7_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d],y
        switch(regs->TCU) {
        // LDA [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B8_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLV i
        switch(regs->TCU) {
        // CLV i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.V = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B9_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,y
        switch(regs->TCU) {
        // LDA a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BA_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSX i
        switch(regs->TCU) {
        // TSX i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = (regs->S);
        regs->P.Z = +((regs->S) == 0);
        regs->P.N = ((regs->S) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BB_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYX i
        switch(regs->TCU) {
        // TYX i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = (regs->Y);
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BC_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a,x
        switch(regs->TCU) {
        // LDY a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BD_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,x
        switch(regs->TCU) {
        // LDA a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BE_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a,y
        switch(regs->TCU) {
        // LDX a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BF_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al,x
        switch(regs->TCU) {
        // LDA al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C0_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY #
        switch(regs->TCU) {
        // CPY # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->Y) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C1_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,x)
        switch(regs->TCU) {
        // CMP (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C2_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // REP #
        switch(regs->TCU) {
        // REP # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v &= (~regs->TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C3_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,s
        switch(regs->TCU) {
        // CMP d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C4_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY d
        switch(regs->TCU) {
        // CPY d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->Y) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C5_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d
        switch(regs->TCU) {
        // CMP d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C6_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d
        switch(regs->TCU) {
        // DEC d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C7_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d]
        switch(regs->TCU) {
        // CMP [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C8_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INY i
        switch(regs->TCU) {
        // INY i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) + 1) & 0xFFFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C9_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP #
        switch(regs->TCU) {
        // CMP # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CA_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEX i
        switch(regs->TCU) {
        // DEX i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) - 1) & 0xFFFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CB_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WAI i
        switch(regs->TCU) {
        // WAI i E=0 M=0 X=0
            case 1: // 1
        regs->WAI = 1;
                break;
            case 2: // 2
        if (regs->WAI) {
            regs->TCU--;
            break;
        }
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 3: // 3
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CC_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY a
        switch(regs->TCU) {
        // CPY a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->Y) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CD_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a
        switch(regs->TCU) {
        // CMP a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CE_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a
        switch(regs->TCU) {
        // DEC a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CF_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al
        switch(regs->TCU) {
        // CMP al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D0_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BNE r
        switch(regs->TCU) {
        // BNE r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D1_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d),y
        switch(regs->TCU) {
        // CMP (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D2_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d)
        switch(regs->TCU) {
        // CMP (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D3_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,s),y
        switch(regs->TCU) {
        // CMP (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D4_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEI s
        switch(regs->TCU) {
        // PEI s E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->D = regs->TR;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 7: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D5_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,x
        switch(regs->TCU) {
        // CMP d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D6_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d,x
        switch(regs->TCU) {
        // DEC d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D7_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d],y
        switch(regs->TCU) {
        // CMP [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D8_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLD i
        switch(regs->TCU) {
        // CLD i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D9_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,y
        switch(regs->TCU) {
        // CMP a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DA_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHX s
        switch(regs->TCU) {
        // PHX s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->X);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DB_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STP i
        switch(regs->TCU) {
        // STP i E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // cleanup_custom
        regs->STP = 1;
        // Following is auto-generated code for instruction finish
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DC_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JML (a)
        switch(regs->TCU) {
        // JML (a) E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->TA + (pins->D << 8); pins->BA = 0;
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->PC = regs->TR + (pins->D << 8);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DD_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,x
        switch(regs->TCU) {
        // CMP a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DE_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a,x
        switch(regs->TCU) {
        // DEC a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DF_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al,x
        switch(regs->TCU) {
        // CMP al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E0_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX #
        switch(regs->TCU) {
        // CPX # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->X) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E1_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,x)
        switch(regs->TCU) {
        // SBC (d,x) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E2_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEP #
        switch(regs->TCU) {
        // SEP # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v |= regs->TR;
        if (regs->P.X) { regs->X &= 0xFF, regs->Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E3_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,s
        switch(regs->TCU) {
        // SBC d,s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E4_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX d
        switch(regs->TCU) {
        // CPX d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->X) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E5_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d
        switch(regs->TCU) {
        // SBC d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E6_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d
        switch(regs->TCU) {
        // INC d E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E7_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d]
        switch(regs->TCU) {
        // SBC [d] E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E8_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INX i
        switch(regs->TCU) {
        // INX i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) + 1) & 0xFFFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E9_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC #
        switch(regs->TCU) {
        // SBC # E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EA_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // NOP i
        switch(regs->TCU) {
        // NOP i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EB_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XBA i
        switch(regs->TCU) {
        // XBA i E=0 M=0 X=0
            case 1:
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2:
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->C = ((regs->C << 8) & 0xFF00) + ((regs->C >> 8) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EC_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX a
        switch(regs->TCU) {
        // CPX a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->X) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_ED_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a
        switch(regs->TCU) {
        // SBC a E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EE_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a
        switch(regs->TCU) {
        // INC a E=0 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EF_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al
        switch(regs->TCU) {
        // SBC al E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F0_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BEQ r
        switch(regs->TCU) {
        // BEQ r E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F1_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d),y
        switch(regs->TCU) {
        // SBC (d),y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F2_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d)
        switch(regs->TCU) {
        // SBC (d) E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F3_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,s),y
        switch(regs->TCU) {
        // SBC (d,s),y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F4_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEA s
        switch(regs->TCU) {
        // PEA s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR;
                break;
            case 5: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F5_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,x
        switch(regs->TCU) {
        // SBC d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F6_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d,x
        switch(regs->TCU) {
        // INC d,x E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F7_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d],y
        switch(regs->TCU) {
        // SBC [d],y E=0 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F8_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SED i
        switch(regs->TCU) {
        // SED i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F9_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,y
        switch(regs->TCU) {
        // SBC a,y E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FA_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLX s
        switch(regs->TCU) {
        // PLX s E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FB_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XCE i
        switch(regs->TCU) {
        // XCE i E=0 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        u32 TMP = regs->P.C; regs->P.C = regs->E; regs->E = TMP;
        if (regs->E) {
            regs->P.X = regs->P.M = 1;
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
            regs->S = (regs->S & 0xFF) | 0x100;
        }
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FC_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR (a,x)
        switch(regs->TCU) {
        // JSR (a,x) E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->RW = 1;
        regs->TA = pins->D;
        pins->D = ((regs->PC) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 4
        pins->D = (regs->PC) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TA = (regs->TA + regs->X + (pins->D << 8)) & 0xFFFF;
                break;
            case 6: // 7
        pins->PDV = 1;
        pins->Addr = regs->TA;
                break;
            case 7: // 8
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->PC = pins->D;
                break;
            case 8: // cleanup_custom
        regs->PC += (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FD_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,x
        switch(regs->TCU) {
        // SBC a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FE_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a,x
        switch(regs->TCU) {
        // INC a,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FF_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al,x
        switch(regs->TCU) {
        // SBC al,x E=0 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_100_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_RESET s
        switch(regs->TCU) {
        // S_RESET s E=0 M=0 X=0
            case 1: // 3
        pins->RW = 0; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 7
        pins->Addr = (0xFFFC); pins->BA = (0);
        regs->DBR = 0;
        regs->D = 0;
        regs->PBR = 0;
        regs->X &= 0xFF;
        regs->Y &= 0xFF;
        regs->E = 1;
        regs->P.M = regs->P.X = regs->P.I = 1; regs->P.C = 0;
        regs->P.D = 0;
        regs->STP = regs->WAI = 0;
        regs->S = 0x1FF;
                break;
            case 6: // 8
        regs->PC = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->PC += (pins->D << 8);
        pins->PDV = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_101_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_ABORT s
        switch(regs->TCU) {
        // S_ABORT s E=0 M=0 X=0
            case 1: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFE8); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFE9); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_102_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_IRQ s
        switch(regs->TCU) {
        // S_IRQ s E=0 M=0 X=0
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEE); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEF); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_103_mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_NMI s
        switch(regs->TCU) {
        // S_NMI s E=0 M=0 X=0
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEA); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEB); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_00_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRK s
        switch(regs->TCU) {
        // BRK s E=0 M=1 X=0
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE6); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE7); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_01_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,x)
        switch(regs->TCU) {
        // ORA (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_02_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // COP s
        switch(regs->TCU) {
        // COP s E=0 M=1 X=0
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE4); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE5); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_03_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,s
        switch(regs->TCU) {
        // ORA d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_04_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB d
        switch(regs->TCU) {
        // TSB d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_05_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d
        switch(regs->TCU) {
        // ORA d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_06_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d
        switch(regs->TCU) {
        // ASL d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_07_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d]
        switch(regs->TCU) {
        // ORA [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_08_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHP s
        switch(regs->TCU) {
        // PHP s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->P.v;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_09_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA #
        switch(regs->TCU) {
        // ORA # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL A
        switch(regs->TCU) {
        // ASL A E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHD s
        switch(regs->TCU) {
        // PHD s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->D);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB a
        switch(regs->TCU) {
        // TSB a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a
        switch(regs->TCU) {
        // ORA a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a
        switch(regs->TCU) {
        // ASL a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al
        switch(regs->TCU) {
        // ORA al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_10_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BPL r
        switch(regs->TCU) {
        // BPL r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_11_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d),y
        switch(regs->TCU) {
        // ORA (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_12_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d)
        switch(regs->TCU) {
        // ORA (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_13_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,s),y
        switch(regs->TCU) {
        // ORA (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_14_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB d
        switch(regs->TCU) {
        // TRB d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_15_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,x
        switch(regs->TCU) {
        // ORA d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_16_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d,x
        switch(regs->TCU) {
        // ASL d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_17_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d],y
        switch(regs->TCU) {
        // ORA [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_18_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLC i
        switch(regs->TCU) {
        // CLC i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_19_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,y
        switch(regs->TCU) {
        // ORA a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC A
        switch(regs->TCU) {
        // INC A E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCS i
        switch(regs->TCU) {
        // TCS i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->C;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB a
        switch(regs->TCU) {
        // TRB a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,x
        switch(regs->TCU) {
        // ORA a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a,x
        switch(regs->TCU) {
        // ASL a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al,x
        switch(regs->TCU) {
        // ORA al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_20_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR a
        switch(regs->TCU) {
        // JSR a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->PDV = 0;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 6
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_21_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,x)
        switch(regs->TCU) {
        // AND (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_22_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSL al
        switch(regs->TCU) {
        // JSL al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        regs->TA += pins->D << 8;
        pins->D = (regs->PBR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0; pins->PDV = 0;
                break;
            case 5: // 6
        pins->PDV = 1;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 6: // 7
        regs->PBR = pins->D;
        pins->RW = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 7: // 8
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_23_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,s
        switch(regs->TCU) {
        // AND d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_24_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d
        switch(regs->TCU) {
        // BIT d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_25_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d
        switch(regs->TCU) {
        // AND d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_26_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d
        switch(regs->TCU) {
        // ROL d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_27_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d]
        switch(regs->TCU) {
        // AND [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_28_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLP s
        switch(regs->TCU) {
        // PLP s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.v = regs->TR;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_29_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND #
        switch(regs->TCU) {
        // AND # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL A
        switch(regs->TCU) {
        // ROL A E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLD s
        switch(regs->TCU) {
        // PLD s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->D = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a
        switch(regs->TCU) {
        // BIT a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a
        switch(regs->TCU) {
        // AND a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a
        switch(regs->TCU) {
        // ROL a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al
        switch(regs->TCU) {
        // AND al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_30_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BMI r
        switch(regs->TCU) {
        // BMI r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_31_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d),y
        switch(regs->TCU) {
        // AND (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_32_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d)
        switch(regs->TCU) {
        // AND (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_33_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,s),y
        switch(regs->TCU) {
        // AND (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_34_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d,x
        switch(regs->TCU) {
        // BIT d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_35_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,x
        switch(regs->TCU) {
        // AND d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_36_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d,x
        switch(regs->TCU) {
        // ROL d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_37_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d],y
        switch(regs->TCU) {
        // AND [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_38_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEC i
        switch(regs->TCU) {
        // SEC i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_39_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,y
        switch(regs->TCU) {
        // AND a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC A
        switch(regs->TCU) {
        // DEC A E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSC i
        switch(regs->TCU) {
        // TSC i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->S);
        regs->P.Z = +((regs->S) == 0);
        regs->P.N = ((regs->S) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a,x
        switch(regs->TCU) {
        // BIT a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,x
        switch(regs->TCU) {
        // AND a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a,x
        switch(regs->TCU) {
        // ROL a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al,x
        switch(regs->TCU) {
        // AND al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_40_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTI s
        switch(regs->TCU) {
        // RTI s E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        pins->PDV = 1;
                break;
            case 4: // 5
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->P.v = pins->D;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x100;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA = pins->D;
                break;
            case 6: // 7
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA += pins->D << 8;
                break;
            case 7: // cleanup_custom
        regs->PC = regs->TA;
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_41_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,x)
        switch(regs->TCU) {
        // EOR (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_42_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WDM i
        switch(regs->TCU) {
        // WDM i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_43_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,s
        switch(regs->TCU) {
        // EOR d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_44_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVP xyc
        switch(regs->TCU) {
        // MVP xyc E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = (regs->X); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = (regs->Y); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
                break;
            case 7: // cleanup_custom
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X - 1) & 0xFFFF;
        regs->Y = (regs->Y - 1) & 0xFFFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_45_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d
        switch(regs->TCU) {
        // EOR d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_46_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d
        switch(regs->TCU) {
        // LSR d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_47_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d]
        switch(regs->TCU) {
        // EOR [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_48_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHA s
        switch(regs->TCU) {
        // PHA s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->C) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_49_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR #
        switch(regs->TCU) {
        // EOR # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR A
        switch(regs->TCU) {
        // LSR A E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHK s
        switch(regs->TCU) {
        // PHK s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->PBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP a
        switch(regs->TCU) {
        // JMP a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a
        switch(regs->TCU) {
        // EOR a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a
        switch(regs->TCU) {
        // LSR a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al
        switch(regs->TCU) {
        // EOR al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_50_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVC r
        switch(regs->TCU) {
        // BVC r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_51_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d),y
        switch(regs->TCU) {
        // EOR (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_52_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d)
        switch(regs->TCU) {
        // EOR (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_53_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,s),y
        switch(regs->TCU) {
        // EOR (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_54_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVN xyc
        switch(regs->TCU) {
        // MVN xyc E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = ((regs->X + regs->MD) & 0xFFFF); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = ((regs->Y + regs->MD) & 0xFFFF); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X + 1) & 0xFFFF;
        regs->Y = (regs->Y + 1) & 0xFFFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_55_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,x
        switch(regs->TCU) {
        // EOR d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_56_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d,x
        switch(regs->TCU) {
        // LSR d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_57_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d],y
        switch(regs->TCU) {
        // EOR [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_58_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLI i
        switch(regs->TCU) {
        // CLI i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_59_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,y
        switch(regs->TCU) {
        // EOR a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHY s
        switch(regs->TCU) {
        // PHY s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->Y);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCD i
        switch(regs->TCU) {
        // TCD i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->D = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP al
        switch(regs->TCU) {
        // JMP al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = regs->TA + (pins->D << 8);
                break;
            case 4: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,x
        switch(regs->TCU) {
        // EOR a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a,x
        switch(regs->TCU) {
        // LSR a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al,x
        switch(regs->TCU) {
        // EOR al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_60_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTS s
        switch(regs->TCU) {
        // RTS s E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_61_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,x)
        switch(regs->TCU) {
        // ADC (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_62_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PER s
        switch(regs->TCU) {
        // PER s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = (regs->PC + regs->TR + (pins->D << 8)) & 0xFFFF;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
                break;
            case 6: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_63_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,s
        switch(regs->TCU) {
        // ADC d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_64_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d
        switch(regs->TCU) {
        // STZ d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_65_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d
        switch(regs->TCU) {
        // ADC d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_66_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d
        switch(regs->TCU) {
        // ROR d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_67_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d]
        switch(regs->TCU) {
        // ADC [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_68_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLA s
        switch(regs->TCU) {
        // PLA s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_69_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC #
        switch(regs->TCU) {
        // ADC # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR A
        switch(regs->TCU) {
        // ROR A E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTL s
        switch(regs->TCU) {
        // RTL s E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a)
        switch(regs->TCU) {
        // JMP (a) E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a
        switch(regs->TCU) {
        // ADC a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a
        switch(regs->TCU) {
        // ROR a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al
        switch(regs->TCU) {
        // ADC al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_70_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVS r
        switch(regs->TCU) {
        // BVS r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_71_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d),y
        switch(regs->TCU) {
        // ADC (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_72_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d)
        switch(regs->TCU) {
        // ADC (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_73_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,s),y
        switch(regs->TCU) {
        // ADC (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_74_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d,x
        switch(regs->TCU) {
        // STZ d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_75_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,x
        switch(regs->TCU) {
        // ADC d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_76_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d,x
        switch(regs->TCU) {
        // ROR d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_77_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d],y
        switch(regs->TCU) {
        // ADC [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_78_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEI i
        switch(regs->TCU) {
        // SEI i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_79_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,y
        switch(regs->TCU) {
        // ADC a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLY s
        switch(regs->TCU) {
        // PLY s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TDC i
        switch(regs->TCU) {
        // TDC i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->D);
        regs->P.Z = +((regs->D) == 0);
        regs->P.N = ((regs->D) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a,x)
        switch(regs->TCU) {
        // JMP (a,x) E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        regs->TA = (regs->X + regs->TA) & 0xFFFF;
        pins->PDV = 0;
                break;
            case 4:
        pins->PDV = 1;
        pins->Addr = regs->TA; pins->BA = regs->PBR;
                break;
            case 5:
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,x
        switch(regs->TCU) {
        // ADC a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a,x
        switch(regs->TCU) {
        // ROR a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al,x
        switch(regs->TCU) {
        // ADC al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_80_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRA r
        switch(regs->TCU) {
        // BRA r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_81_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,x)
        switch(regs->TCU) {
        // STA (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_82_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRL rl
        switch(regs->TCU) {
        // BRL rl E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TA = (u32)(i16)(regs->TA + (pins->D << 8));
        regs->PC = (regs->PC + regs->TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_83_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,s
        switch(regs->TCU) {
        // STA d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_84_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d
        switch(regs->TCU) {
        // STY d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_85_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d
        switch(regs->TCU) {
        // STA d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_86_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d
        switch(regs->TCU) {
        // STX d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_87_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d]
        switch(regs->TCU) {
        // STA [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_88_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEY i
        switch(regs->TCU) {
        // DEY i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) - 1) & 0xFFFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_89_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT #
        switch(regs->TCU) {
        // BIT # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXA i
        switch(regs->TCU) {
        // TXA i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->X) & 0xFF);
        regs->P.Z = +((regs->X & 0xFF) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHB s
        switch(regs->TCU) {
        // PHB s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->DBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY a
        switch(regs->TCU) {
        // STY a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->Y;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a
        switch(regs->TCU) {
        // STA a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX a
        switch(regs->TCU) {
        // STX a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->X;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al
        switch(regs->TCU) {
        // STA al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_90_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCC r
        switch(regs->TCU) {
        // BCC r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_91_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d),y
        switch(regs->TCU) {
        // STA (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_92_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d)
        switch(regs->TCU) {
        // STA (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_93_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,s),y
        switch(regs->TCU) {
        // STA (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_94_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d,x
        switch(regs->TCU) {
        // STY d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_95_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,x
        switch(regs->TCU) {
        // STA d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_96_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d,y
        switch(regs->TCU) {
        // STX d,y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_97_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d],y
        switch(regs->TCU) {
        // STA [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_98_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYA i
        switch(regs->TCU) {
        // TYA i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->Y) & 0xFF);
        regs->P.Z = +((regs->Y & 0xFF) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_99_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,y
        switch(regs->TCU) {
        // STA a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9A_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXS i
        switch(regs->TCU) {
        // TXS i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->X;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9B_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXY i
        switch(regs->TCU) {
        // TXY i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = (regs->X);
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9C_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a
        switch(regs->TCU) {
        // STZ a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9D_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,x
        switch(regs->TCU) {
        // STA a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9E_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a,x
        switch(regs->TCU) {
        // STZ a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9F_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al,x
        switch(regs->TCU) {
        // STA al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A0_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY #
        switch(regs->TCU) {
        // LDY # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A1_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,x)
        switch(regs->TCU) {
        // LDA (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A2_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX #
        switch(regs->TCU) {
        // LDX # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A3_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,s
        switch(regs->TCU) {
        // LDA d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A4_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d
        switch(regs->TCU) {
        // LDY d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A5_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d
        switch(regs->TCU) {
        // LDA d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A6_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d
        switch(regs->TCU) {
        // LDX d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A7_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d]
        switch(regs->TCU) {
        // LDA [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A8_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAY i
        switch(regs->TCU) {
        // TAY i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A9_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA #
        switch(regs->TCU) {
        // LDA # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AA_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAX i
        switch(regs->TCU) {
        // TAX i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AB_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLB s
        switch(regs->TCU) {
        // PLB s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->DBR = ((regs->DBR) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AC_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a
        switch(regs->TCU) {
        // LDY a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AD_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a
        switch(regs->TCU) {
        // LDA a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AE_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a
        switch(regs->TCU) {
        // LDX a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AF_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al
        switch(regs->TCU) {
        // LDA al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B0_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCS r
        switch(regs->TCU) {
        // BCS r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B1_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d),y
        switch(regs->TCU) {
        // LDA (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B2_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d)
        switch(regs->TCU) {
        // LDA (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B3_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,s),y
        switch(regs->TCU) {
        // LDA (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B4_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d,x
        switch(regs->TCU) {
        // LDY d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B5_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,x
        switch(regs->TCU) {
        // LDA d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B6_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d,y
        switch(regs->TCU) {
        // LDX d,y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B7_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d],y
        switch(regs->TCU) {
        // LDA [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B8_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLV i
        switch(regs->TCU) {
        // CLV i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.V = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B9_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,y
        switch(regs->TCU) {
        // LDA a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BA_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSX i
        switch(regs->TCU) {
        // TSX i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = (regs->S);
        regs->P.Z = +((regs->S) == 0);
        regs->P.N = ((regs->S) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BB_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYX i
        switch(regs->TCU) {
        // TYX i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = (regs->Y);
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BC_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a,x
        switch(regs->TCU) {
        // LDY a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->Y = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BD_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,x
        switch(regs->TCU) {
        // LDA a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BE_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a,y
        switch(regs->TCU) {
        // LDX a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BF_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al,x
        switch(regs->TCU) {
        // LDA al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C0_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY #
        switch(regs->TCU) {
        // CPY # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->Y) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C1_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,x)
        switch(regs->TCU) {
        // CMP (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C2_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // REP #
        switch(regs->TCU) {
        // REP # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v &= (~regs->TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C3_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,s
        switch(regs->TCU) {
        // CMP d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C4_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY d
        switch(regs->TCU) {
        // CPY d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->Y) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C5_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d
        switch(regs->TCU) {
        // CMP d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C6_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d
        switch(regs->TCU) {
        // DEC d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C7_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d]
        switch(regs->TCU) {
        // CMP [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C8_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INY i
        switch(regs->TCU) {
        // INY i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) + 1) & 0xFFFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C9_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP #
        switch(regs->TCU) {
        // CMP # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CA_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEX i
        switch(regs->TCU) {
        // DEX i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) - 1) & 0xFFFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CB_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WAI i
        switch(regs->TCU) {
        // WAI i E=0 M=1 X=0
            case 1: // 1
        regs->WAI = 1;
                break;
            case 2: // 2
        if (regs->WAI) {
            regs->TCU--;
            break;
        }
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 3: // 3
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CC_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY a
        switch(regs->TCU) {
        // CPY a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->Y) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CD_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a
        switch(regs->TCU) {
        // CMP a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CE_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a
        switch(regs->TCU) {
        // DEC a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CF_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al
        switch(regs->TCU) {
        // CMP al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D0_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BNE r
        switch(regs->TCU) {
        // BNE r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D1_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d),y
        switch(regs->TCU) {
        // CMP (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D2_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d)
        switch(regs->TCU) {
        // CMP (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D3_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,s),y
        switch(regs->TCU) {
        // CMP (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D4_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEI s
        switch(regs->TCU) {
        // PEI s E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->D = regs->TR;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 7: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D5_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,x
        switch(regs->TCU) {
        // CMP d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D6_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d,x
        switch(regs->TCU) {
        // DEC d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D7_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d],y
        switch(regs->TCU) {
        // CMP [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D8_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLD i
        switch(regs->TCU) {
        // CLD i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D9_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,y
        switch(regs->TCU) {
        // CMP a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DA_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHX s
        switch(regs->TCU) {
        // PHX s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->X);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DB_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STP i
        switch(regs->TCU) {
        // STP i E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // cleanup_custom
        regs->STP = 1;
        // Following is auto-generated code for instruction finish
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DC_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JML (a)
        switch(regs->TCU) {
        // JML (a) E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->TA + (pins->D << 8); pins->BA = 0;
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->PC = regs->TR + (pins->D << 8);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DD_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,x
        switch(regs->TCU) {
        // CMP a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DE_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a,x
        switch(regs->TCU) {
        // DEC a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DF_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al,x
        switch(regs->TCU) {
        // CMP al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E0_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX #
        switch(regs->TCU) {
        // CPX # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->X) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E1_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,x)
        switch(regs->TCU) {
        // SBC (d,x) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E2_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEP #
        switch(regs->TCU) {
        // SEP # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v |= regs->TR;
        if (regs->P.X) { regs->X &= 0xFF, regs->Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E3_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,s
        switch(regs->TCU) {
        // SBC d,s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E4_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX d
        switch(regs->TCU) {
        // CPX d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->X) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E5_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d
        switch(regs->TCU) {
        // SBC d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E6_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d
        switch(regs->TCU) {
        // INC d E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E7_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d]
        switch(regs->TCU) {
        // SBC [d] E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E8_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INX i
        switch(regs->TCU) {
        // INX i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) + 1) & 0xFFFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E9_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC #
        switch(regs->TCU) {
        // SBC # E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EA_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // NOP i
        switch(regs->TCU) {
        // NOP i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EB_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XBA i
        switch(regs->TCU) {
        // XBA i E=0 M=1 X=0
            case 1:
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2:
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->C = ((regs->C << 8) & 0xFF00) + ((regs->C >> 8) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EC_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX a
        switch(regs->TCU) {
        // CPX a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->X) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_ED_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a
        switch(regs->TCU) {
        // SBC a E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EE_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a
        switch(regs->TCU) {
        // INC a E=0 M=1 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EF_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al
        switch(regs->TCU) {
        // SBC al E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F0_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BEQ r
        switch(regs->TCU) {
        // BEQ r E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F1_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d),y
        switch(regs->TCU) {
        // SBC (d),y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F2_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d)
        switch(regs->TCU) {
        // SBC (d) E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F3_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,s),y
        switch(regs->TCU) {
        // SBC (d,s),y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F4_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEA s
        switch(regs->TCU) {
        // PEA s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR;
                break;
            case 5: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F5_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,x
        switch(regs->TCU) {
        // SBC d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F6_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d,x
        switch(regs->TCU) {
        // INC d,x E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F7_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d],y
        switch(regs->TCU) {
        // SBC [d],y E=0 M=1 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F8_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SED i
        switch(regs->TCU) {
        // SED i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F9_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,y
        switch(regs->TCU) {
        // SBC a,y E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FA_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLX s
        switch(regs->TCU) {
        // PLX s E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->X = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FB_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XCE i
        switch(regs->TCU) {
        // XCE i E=0 M=1 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        u32 TMP = regs->P.C; regs->P.C = regs->E; regs->E = TMP;
        if (regs->E) {
            regs->P.X = regs->P.M = 1;
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
            regs->S = (regs->S & 0xFF) | 0x100;
        }
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FC_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR (a,x)
        switch(regs->TCU) {
        // JSR (a,x) E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->RW = 1;
        regs->TA = pins->D;
        pins->D = ((regs->PC) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 4
        pins->D = (regs->PC) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TA = (regs->TA + regs->X + (pins->D << 8)) & 0xFFFF;
                break;
            case 6: // 7
        pins->PDV = 1;
        pins->Addr = regs->TA;
                break;
            case 7: // 8
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->PC = pins->D;
                break;
            case 8: // cleanup_custom
        regs->PC += (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FD_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,x
        switch(regs->TCU) {
        // SBC a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FE_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a,x
        switch(regs->TCU) {
        // INC a,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FF_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al,x
        switch(regs->TCU) {
        // SBC al,x E=0 M=1 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_100_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_RESET s
        switch(regs->TCU) {
        // S_RESET s E=0 M=1 X=0
            case 1: // 3
        pins->RW = 0; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 7
        pins->Addr = (0xFFFC); pins->BA = (0);
        regs->DBR = 0;
        regs->D = 0;
        regs->PBR = 0;
        regs->X &= 0xFF;
        regs->Y &= 0xFF;
        regs->E = 1;
        regs->P.M = regs->P.X = regs->P.I = 1; regs->P.C = 0;
        regs->P.D = 0;
        regs->STP = regs->WAI = 0;
        regs->S = 0x1FF;
                break;
            case 6: // 8
        regs->PC = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->PC += (pins->D << 8);
        pins->PDV = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_101_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_ABORT s
        switch(regs->TCU) {
        // S_ABORT s E=0 M=1 X=0
            case 1: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFE8); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFE9); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_102_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_IRQ s
        switch(regs->TCU) {
        // S_IRQ s E=0 M=1 X=0
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEE); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEF); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_103_Mx(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_NMI s
        switch(regs->TCU) {
        // S_NMI s E=0 M=1 X=0
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEA); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEB); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_00_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRK s
        switch(regs->TCU) {
        // BRK s E=0 M=0 X=1
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE6); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE7); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_01_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,x)
        switch(regs->TCU) {
        // ORA (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_02_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // COP s
        switch(regs->TCU) {
        // COP s E=0 M=0 X=1
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE4); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE5); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_03_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,s
        switch(regs->TCU) {
        // ORA d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_04_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB d
        switch(regs->TCU) {
        // TSB d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_05_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d
        switch(regs->TCU) {
        // ORA d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_06_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d
        switch(regs->TCU) {
        // ASL d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_07_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d]
        switch(regs->TCU) {
        // ORA [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_08_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHP s
        switch(regs->TCU) {
        // PHP s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->P.v;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_09_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA #
        switch(regs->TCU) {
        // ORA # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL A
        switch(regs->TCU) {
        // ASL A E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHD s
        switch(regs->TCU) {
        // PHD s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->D);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB a
        switch(regs->TCU) {
        // TSB a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a
        switch(regs->TCU) {
        // ORA a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a
        switch(regs->TCU) {
        // ASL a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al
        switch(regs->TCU) {
        // ORA al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_10_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BPL r
        switch(regs->TCU) {
        // BPL r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_11_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d),y
        switch(regs->TCU) {
        // ORA (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_12_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d)
        switch(regs->TCU) {
        // ORA (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_13_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,s),y
        switch(regs->TCU) {
        // ORA (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_14_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB d
        switch(regs->TCU) {
        // TRB d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_15_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,x
        switch(regs->TCU) {
        // ORA d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_16_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d,x
        switch(regs->TCU) {
        // ASL d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_17_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d],y
        switch(regs->TCU) {
        // ORA [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_18_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLC i
        switch(regs->TCU) {
        // CLC i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_19_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,y
        switch(regs->TCU) {
        // ORA a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC A
        switch(regs->TCU) {
        // INC A E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCS i
        switch(regs->TCU) {
        // TCS i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->C;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB a
        switch(regs->TCU) {
        // TRB a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFFFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFFFF;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,x
        switch(regs->TCU) {
        // ORA a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a,x
        switch(regs->TCU) {
        // ASL a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = (regs->TR & 0x7FFF) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al,x
        switch(regs->TCU) {
        // ORA al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C |= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_20_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR a
        switch(regs->TCU) {
        // JSR a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->PDV = 0;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 6
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_21_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,x)
        switch(regs->TCU) {
        // AND (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_22_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSL al
        switch(regs->TCU) {
        // JSL al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        regs->TA += pins->D << 8;
        pins->D = (regs->PBR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0; pins->PDV = 0;
                break;
            case 5: // 6
        pins->PDV = 1;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 6: // 7
        regs->PBR = pins->D;
        pins->RW = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 7: // 8
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_23_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,s
        switch(regs->TCU) {
        // AND d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_24_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d
        switch(regs->TCU) {
        // BIT d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_25_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d
        switch(regs->TCU) {
        // AND d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_26_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d
        switch(regs->TCU) {
        // ROL d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_27_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d]
        switch(regs->TCU) {
        // AND [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_28_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLP s
        switch(regs->TCU) {
        // PLP s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.v = regs->TR;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_29_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND #
        switch(regs->TCU) {
        // AND # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL A
        switch(regs->TCU) {
        // ROL A E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLD s
        switch(regs->TCU) {
        // PLD s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->D = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a
        switch(regs->TCU) {
        // BIT a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a
        switch(regs->TCU) {
        // AND a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a
        switch(regs->TCU) {
        // ROL a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al
        switch(regs->TCU) {
        // AND al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_30_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BMI r
        switch(regs->TCU) {
        // BMI r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_31_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d),y
        switch(regs->TCU) {
        // AND (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_32_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d)
        switch(regs->TCU) {
        // AND (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_33_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,s),y
        switch(regs->TCU) {
        // AND (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_34_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d,x
        switch(regs->TCU) {
        // BIT d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_35_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,x
        switch(regs->TCU) {
        // AND d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_36_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d,x
        switch(regs->TCU) {
        // ROL d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_37_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d],y
        switch(regs->TCU) {
        // AND [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_38_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEC i
        switch(regs->TCU) {
        // SEC i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_39_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,y
        switch(regs->TCU) {
        // AND a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC A
        switch(regs->TCU) {
        // DEC A E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSC i
        switch(regs->TCU) {
        // TSC i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->S);
        regs->P.Z = +((regs->S) == 0);
        regs->P.N = ((regs->S) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a,x
        switch(regs->TCU) {
        // BIT a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        regs->P.V = (regs->TR & 0x4000) >> 14;
        regs->P.N = (regs->TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,x
        switch(regs->TCU) {
        // AND a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a,x
        switch(regs->TCU) {
        // ROL a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x8000) >> 15;
        regs->TR = ((regs->TR & 0x7FFF) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al,x
        switch(regs->TCU) {
        // AND al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C &= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_40_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTI s
        switch(regs->TCU) {
        // RTI s E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        pins->PDV = 1;
                break;
            case 4: // 5
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->P.v = pins->D;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x100;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA = pins->D;
                break;
            case 6: // 7
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA += pins->D << 8;
                break;
            case 7: // cleanup_custom
        regs->PC = regs->TA;
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_41_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,x)
        switch(regs->TCU) {
        // EOR (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_42_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WDM i
        switch(regs->TCU) {
        // WDM i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_43_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,s
        switch(regs->TCU) {
        // EOR d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_44_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVP xyc
        switch(regs->TCU) {
        // MVP xyc E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = (regs->X); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = (regs->Y); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
                break;
            case 7: // cleanup_custom
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X - 1) & 0xFF;
        regs->Y = (regs->Y - 1) & 0xFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_45_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d
        switch(regs->TCU) {
        // EOR d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_46_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d
        switch(regs->TCU) {
        // LSR d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_47_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d]
        switch(regs->TCU) {
        // EOR [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_48_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHA s
        switch(regs->TCU) {
        // PHA s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->C);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_49_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR #
        switch(regs->TCU) {
        // EOR # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR A
        switch(regs->TCU) {
        // LSR A E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHK s
        switch(regs->TCU) {
        // PHK s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->PBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP a
        switch(regs->TCU) {
        // JMP a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a
        switch(regs->TCU) {
        // EOR a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a
        switch(regs->TCU) {
        // LSR a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al
        switch(regs->TCU) {
        // EOR al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_50_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVC r
        switch(regs->TCU) {
        // BVC r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_51_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d),y
        switch(regs->TCU) {
        // EOR (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_52_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d)
        switch(regs->TCU) {
        // EOR (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_53_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,s),y
        switch(regs->TCU) {
        // EOR (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_54_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVN xyc
        switch(regs->TCU) {
        // MVN xyc E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = ((regs->X + regs->MD) & 0xFFFF); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = ((regs->Y + regs->MD) & 0xFFFF); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X + 1) & 0xFF;
        regs->Y = (regs->Y + 1) & 0xFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_55_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,x
        switch(regs->TCU) {
        // EOR d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_56_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d,x
        switch(regs->TCU) {
        // LSR d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_57_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d],y
        switch(regs->TCU) {
        // EOR [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_58_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLI i
        switch(regs->TCU) {
        // CLI i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_59_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,y
        switch(regs->TCU) {
        // EOR a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHY s
        switch(regs->TCU) {
        // PHY s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->Y) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCD i
        switch(regs->TCU) {
        // TCD i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->D = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP al
        switch(regs->TCU) {
        // JMP al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = regs->TA + (pins->D << 8);
                break;
            case 4: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,x
        switch(regs->TCU) {
        // EOR a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a,x
        switch(regs->TCU) {
        // LSR a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al,x
        switch(regs->TCU) {
        // EOR al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C ^= regs->TR;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_60_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTS s
        switch(regs->TCU) {
        // RTS s E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_61_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,x)
        switch(regs->TCU) {
        // ADC (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_62_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PER s
        switch(regs->TCU) {
        // PER s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = (regs->PC + regs->TR + (pins->D << 8)) & 0xFFFF;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
                break;
            case 6: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_63_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,s
        switch(regs->TCU) {
        // ADC d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_64_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d
        switch(regs->TCU) {
        // STZ d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_65_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d
        switch(regs->TCU) {
        // ADC d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_66_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d
        switch(regs->TCU) {
        // ROR d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_67_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d]
        switch(regs->TCU) {
        // ADC [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_68_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLA s
        switch(regs->TCU) {
        // PLA s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->C = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_69_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC #
        switch(regs->TCU) {
        // ADC # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR A
        switch(regs->TCU) {
        // ROR A E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        regs->C = regs->TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTL s
        switch(regs->TCU) {
        // RTL s E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a)
        switch(regs->TCU) {
        // JMP (a) E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a
        switch(regs->TCU) {
        // ADC a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a
        switch(regs->TCU) {
        // ROR a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al
        switch(regs->TCU) {
        // ADC al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_70_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVS r
        switch(regs->TCU) {
        // BVS r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_71_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d),y
        switch(regs->TCU) {
        // ADC (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_72_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d)
        switch(regs->TCU) {
        // ADC (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_73_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,s),y
        switch(regs->TCU) {
        // ADC (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_74_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d,x
        switch(regs->TCU) {
        // STZ d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_75_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,x
        switch(regs->TCU) {
        // ADC d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_76_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d,x
        switch(regs->TCU) {
        // ROR d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_77_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d],y
        switch(regs->TCU) {
        // ADC [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_78_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEI i
        switch(regs->TCU) {
        // SEI i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_79_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,y
        switch(regs->TCU) {
        // ADC a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLY s
        switch(regs->TCU) {
        // PLY s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TDC i
        switch(regs->TCU) {
        // TDC i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->D);
        regs->P.Z = +((regs->D) == 0);
        regs->P.N = ((regs->D) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a,x)
        switch(regs->TCU) {
        // JMP (a,x) E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        regs->TA = (regs->X + regs->TA) & 0xFFFF;
        pins->PDV = 0;
                break;
            case 4:
        pins->PDV = 1;
        pins->Addr = regs->TA; pins->BA = regs->PBR;
                break;
            case 5:
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,x
        switch(regs->TCU) {
        // ADC a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a,x
        switch(regs->TCU) {
        // ROR a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 carry = regs->P.C << 15;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFFFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al,x
        switch(regs->TCU) {
        // ADC al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        u32 result;
        if (!regs->P.D) result = regs->C + regs->TR + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (regs->TR & 0x000F) + (regs->P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (regs->TR & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (regs->TR & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (regs->TR & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ regs->TR)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result > 0x9FFF) result += 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +(((result & 0xFFFF)) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_80_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRA r
        switch(regs->TCU) {
        // BRA r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_81_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,x)
        switch(regs->TCU) {
        // STA (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_82_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRL rl
        switch(regs->TCU) {
        // BRL rl E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TA = (u32)(i16)(regs->TA + (pins->D << 8));
        regs->PC = (regs->PC + regs->TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_83_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,s
        switch(regs->TCU) {
        // STA d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_84_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d
        switch(regs->TCU) {
        // STY d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_85_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d
        switch(regs->TCU) {
        // STA d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_86_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d
        switch(regs->TCU) {
        // STX d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_87_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d]
        switch(regs->TCU) {
        // STA [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_88_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEY i
        switch(regs->TCU) {
        // DEY i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) - 1) & 0xFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_89_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT #
        switch(regs->TCU) {
        // BIT # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFFFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXA i
        switch(regs->TCU) {
        // TXA i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->X);
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHB s
        switch(regs->TCU) {
        // PHB s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->DBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY a
        switch(regs->TCU) {
        // STY a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a
        switch(regs->TCU) {
        // STA a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX a
        switch(regs->TCU) {
        // STX a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al
        switch(regs->TCU) {
        // STA al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 5a
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_90_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCC r
        switch(regs->TCU) {
        // BCC r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_91_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d),y
        switch(regs->TCU) {
        // STA (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_92_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d)
        switch(regs->TCU) {
        // STA (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 6: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_93_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,s),y
        switch(regs->TCU) {
        // STA (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_94_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d,x
        switch(regs->TCU) {
        // STY d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_95_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,x
        switch(regs->TCU) {
        // STA d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_96_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d,y
        switch(regs->TCU) {
        // STX d,y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_97_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d],y
        switch(regs->TCU) {
        // STA [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 7: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_98_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYA i
        switch(regs->TCU) {
        // TYA i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->Y);
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_99_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,y
        switch(regs->TCU) {
        // STA a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9A_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXS i
        switch(regs->TCU) {
        // TXS i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->X;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9B_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXY i
        switch(regs->TCU) {
        // TXY i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->X) & 0xFF);
        regs->P.Z = +((regs->X & 0xFF) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9C_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a
        switch(regs->TCU) {
        // STZ a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9D_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,x
        switch(regs->TCU) {
        // STA a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9E_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a,x
        switch(regs->TCU) {
        // STZ a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9F_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al,x
        switch(regs->TCU) {
        // STA al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // finish_RW8or16p W16H
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
        pins->D = (regs->TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A0_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY #
        switch(regs->TCU) {
        // LDY # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A1_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,x)
        switch(regs->TCU) {
        // LDA (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A2_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX #
        switch(regs->TCU) {
        // LDX # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A3_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,s
        switch(regs->TCU) {
        // LDA d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A4_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d
        switch(regs->TCU) {
        // LDY d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A5_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d
        switch(regs->TCU) {
        // LDA d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A6_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d
        switch(regs->TCU) {
        // LDX d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A7_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d]
        switch(regs->TCU) {
        // LDA [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A8_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAY i
        switch(regs->TCU) {
        // TAY i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->C) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A9_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA #
        switch(regs->TCU) {
        // LDA # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AA_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAX i
        switch(regs->TCU) {
        // TAX i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->C) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AB_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLB s
        switch(regs->TCU) {
        // PLB s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->DBR = ((regs->DBR) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AC_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a
        switch(regs->TCU) {
        // LDY a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AD_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a
        switch(regs->TCU) {
        // LDA a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AE_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a
        switch(regs->TCU) {
        // LDX a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AF_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al
        switch(regs->TCU) {
        // LDA al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B0_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCS r
        switch(regs->TCU) {
        // BCS r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B1_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d),y
        switch(regs->TCU) {
        // LDA (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B2_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d)
        switch(regs->TCU) {
        // LDA (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B3_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,s),y
        switch(regs->TCU) {
        // LDA (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B4_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d,x
        switch(regs->TCU) {
        // LDY d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B5_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,x
        switch(regs->TCU) {
        // LDA d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B6_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d,y
        switch(regs->TCU) {
        // LDX d,y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B7_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d],y
        switch(regs->TCU) {
        // LDA [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B8_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLV i
        switch(regs->TCU) {
        // CLV i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.V = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B9_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,y
        switch(regs->TCU) {
        // LDA a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BA_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSX i
        switch(regs->TCU) {
        // TSX i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X  = regs->S & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BB_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYX i
        switch(regs->TCU) {
        // TYX i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->Y) & 0xFF);
        regs->P.Z = +((regs->Y & 0xFF) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BC_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a,x
        switch(regs->TCU) {
        // LDY a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BD_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,x
        switch(regs->TCU) {
        // LDA a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BE_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a,y
        switch(regs->TCU) {
        // LDX a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BF_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al,x
        switch(regs->TCU) {
        // LDA al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->C = regs->TR & 0xFFFF;
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C0_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY #
        switch(regs->TCU) {
        // CPY # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C1_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,x)
        switch(regs->TCU) {
        // CMP (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C2_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // REP #
        switch(regs->TCU) {
        // REP # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v &= (~regs->TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C3_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,s
        switch(regs->TCU) {
        // CMP d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C4_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY d
        switch(regs->TCU) {
        // CPY d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C5_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d
        switch(regs->TCU) {
        // CMP d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C6_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d
        switch(regs->TCU) {
        // DEC d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C7_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d]
        switch(regs->TCU) {
        // CMP [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C8_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INY i
        switch(regs->TCU) {
        // INY i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) + 1) & 0xFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C9_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP #
        switch(regs->TCU) {
        // CMP # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CA_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEX i
        switch(regs->TCU) {
        // DEX i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) - 1) & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CB_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WAI i
        switch(regs->TCU) {
        // WAI i E=0 M=0 X=1
            case 1: // 1
        regs->WAI = 1;
                break;
            case 2: // 2
        if (regs->WAI) {
            regs->TCU--;
            break;
        }
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 3: // 3
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CC_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY a
        switch(regs->TCU) {
        // CPY a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CD_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a
        switch(regs->TCU) {
        // CMP a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CE_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a
        switch(regs->TCU) {
        // DEC a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CF_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al
        switch(regs->TCU) {
        // CMP al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D0_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BNE r
        switch(regs->TCU) {
        // BNE r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D1_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d),y
        switch(regs->TCU) {
        // CMP (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D2_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d)
        switch(regs->TCU) {
        // CMP (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D3_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,s),y
        switch(regs->TCU) {
        // CMP (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D4_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEI s
        switch(regs->TCU) {
        // PEI s E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->D = regs->TR;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 7: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D5_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,x
        switch(regs->TCU) {
        // CMP d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D6_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d,x
        switch(regs->TCU) {
        // DEC d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D7_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d],y
        switch(regs->TCU) {
        // CMP [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D8_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLD i
        switch(regs->TCU) {
        // CLD i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D9_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,y
        switch(regs->TCU) {
        // CMP a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DA_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHX s
        switch(regs->TCU) {
        // PHX s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->X) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DB_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STP i
        switch(regs->TCU) {
        // STP i E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // cleanup_custom
        regs->STP = 1;
        // Following is auto-generated code for instruction finish
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DC_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JML (a)
        switch(regs->TCU) {
        // JML (a) E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->TA + (pins->D << 8); pins->BA = 0;
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->PC = regs->TR + (pins->D << 8);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DD_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,x
        switch(regs->TCU) {
        // CMP a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DE_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a,x
        switch(regs->TCU) {
        // DEC a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DF_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al,x
        switch(regs->TCU) {
        // CMP al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = (regs->C) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E0_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX #
        switch(regs->TCU) {
        // CPX # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E1_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,x)
        switch(regs->TCU) {
        // SBC (d,x) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E2_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEP #
        switch(regs->TCU) {
        // SEP # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v |= regs->TR;
        if (regs->P.X) { regs->X &= 0xFF, regs->Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E3_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,s
        switch(regs->TCU) {
        // SBC d,s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E4_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX d
        switch(regs->TCU) {
        // CPX d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E5_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d
        switch(regs->TCU) {
        // SBC d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E6_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d
        switch(regs->TCU) {
        // INC d E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E7_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d]
        switch(regs->TCU) {
        // SBC [d] E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E8_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INX i
        switch(regs->TCU) {
        // INX i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) + 1) & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E9_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC #
        switch(regs->TCU) {
        // SBC # E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EA_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // NOP i
        switch(regs->TCU) {
        // NOP i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EB_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XBA i
        switch(regs->TCU) {
        // XBA i E=0 M=0 X=1
            case 1:
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2:
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->C = ((regs->C << 8) & 0xFF00) + ((regs->C >> 8) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EC_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX a
        switch(regs->TCU) {
        // CPX a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_ED_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a
        switch(regs->TCU) {
        // SBC a E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EE_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a
        switch(regs->TCU) {
        // INC a E=0 M=0 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 6: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 7: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EF_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al
        switch(regs->TCU) {
        // SBC al E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += (pins-> D & 0xFF) << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F0_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BEQ r
        switch(regs->TCU) {
        // BEQ r E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F1_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d),y
        switch(regs->TCU) {
        // SBC (d),y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F2_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d)
        switch(regs->TCU) {
        // SBC (d) E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F3_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,s),y
        switch(regs->TCU) {
        // SBC (d,s),y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F4_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEA s
        switch(regs->TCU) {
        // PEA s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR;
                break;
            case 5: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F5_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,x
        switch(regs->TCU) {
        // SBC d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F6_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d,x
        switch(regs->TCU) {
        // INC d,x E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 16L
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // fetch_rmw_8or16 16H
        regs->TR += pins->D << 8;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr = (pins->Addr - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F7_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d],y
        switch(regs->TCU) {
        // SBC [d],y E=0 M=0 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 8: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F8_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SED i
        switch(regs->TCU) {
        // SED i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F9_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,y
        switch(regs->TCU) {
        // SBC a,y E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FA_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLX s
        switch(regs->TCU) {
        // PLX s E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FB_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XCE i
        switch(regs->TCU) {
        // XCE i E=0 M=0 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        u32 TMP = regs->P.C; regs->P.C = regs->E; regs->E = TMP;
        if (regs->E) {
            regs->P.X = regs->P.M = 1;
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
            regs->S = (regs->S & 0xFF) | 0x100;
        }
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FC_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR (a,x)
        switch(regs->TCU) {
        // JSR (a,x) E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->RW = 1;
        regs->TA = pins->D;
        pins->D = ((regs->PC) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 4
        pins->D = (regs->PC) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TA = (regs->TA + regs->X + (pins->D << 8)) & 0xFFFF;
                break;
            case 6: // 7
        pins->PDV = 1;
        pins->Addr = regs->TA;
                break;
            case 7: // 8
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->PC = pins->D;
                break;
            case 8: // cleanup_custom
        regs->PC += (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FD_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,x
        switch(regs->TCU) {
        // SBC a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FE_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a,x
        switch(regs->TCU) {
        // INC a,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 5a
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        pins->PDV = 0;
        regs->TR += pins->D << 8;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFFFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 7: // finish_rmw mem16 H
        pins->RW = 1; pins->PDV = 1;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 8: // finish_rmw mem16 L
        pins->Addr--; if (pins->Addr < 0) { pins->Addr = 0xFFFF; pins->BA = (pins->BA - 1) & 0xFF; };
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 9: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FF_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al,x
        switch(regs->TCU) {
        // SBC al,x E=0 M=0 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // finish_R16p
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->TR += pins->D << 8;
        // instruction code follows
        i32 data = (~regs->TR) & 0xFFFF;
        i32 result;
        if (!regs->P.D) result = regs->C + data + regs->P.C;
        else {
            result = (regs->C & 0x000F) + (data & 0x000F) + (regs->P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs->P.C = +(result > 0x000F);
            result = (regs->C & 0x00F0) + (data & 0x00F0) + (regs->P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs->P.C = +(result > 0x00FF);
            result = (regs->C & 0x0F00) + (data & 0x0F00) + (regs->P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs->P.C = +(result > 0x0FFF);
            result = (regs->C & 0xF000) + (data & 0xF000) + (regs->P.C << 12) + (result & 0x0FFF);
        }
        regs->P.V = ((~(regs->C ^ data)) & (regs->C ^ result) & 0x8000) >> 15;
        if (regs->P.D && result <= 0xFFFF) result -= 0x6000;
        regs->P.C = +(result > 0xFFFF);
        regs->P.Z = +((result & 0xFFFF) == 0);
        regs->P.N = ((result) & 0x8000) >> 15;
        regs->C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_100_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_RESET s
        switch(regs->TCU) {
        // S_RESET s E=0 M=0 X=1
            case 1: // 3
        pins->RW = 0; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 7
        pins->Addr = (0xFFFC); pins->BA = (0);
        regs->DBR = 0;
        regs->D = 0;
        regs->PBR = 0;
        regs->X &= 0xFF;
        regs->Y &= 0xFF;
        regs->E = 1;
        regs->P.M = regs->P.X = regs->P.I = 1; regs->P.C = 0;
        regs->P.D = 0;
        regs->STP = regs->WAI = 0;
        regs->S = 0x1FF;
                break;
            case 6: // 8
        regs->PC = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->PC += (pins->D << 8);
        pins->PDV = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_101_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_ABORT s
        switch(regs->TCU) {
        // S_ABORT s E=0 M=0 X=1
            case 1: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFE8); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFE9); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_102_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_IRQ s
        switch(regs->TCU) {
        // S_IRQ s E=0 M=0 X=1
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEE); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEF); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_103_mX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_NMI s
        switch(regs->TCU) {
        // S_NMI s E=0 M=0 X=1
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEA); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEB); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_00_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRK s
        switch(regs->TCU) {
        // BRK s E=0 M=1 X=1
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE6); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE7); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_01_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,x)
        switch(regs->TCU) {
        // ORA (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_02_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // COP s
        switch(regs->TCU) {
        // COP s E=0 M=1 X=1
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 3: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 6: // 7
        pins->Addr = (0xFFE4); pins->BA = (0);
        pins->RW = 0;
                break;
            case 7: // 8
        pins->Addr = (0xFFE5); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 8: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_03_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,s
        switch(regs->TCU) {
        // ORA d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_04_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB d
        switch(regs->TCU) {
        // TSB d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_05_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d
        switch(regs->TCU) {
        // ORA d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_06_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d
        switch(regs->TCU) {
        // ASL d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_07_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d]
        switch(regs->TCU) {
        // ORA [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_08_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHP s
        switch(regs->TCU) {
        // PHP s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->P.v;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_09_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA #
        switch(regs->TCU) {
        // ORA # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL A
        switch(regs->TCU) {
        // ASL A E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHD s
        switch(regs->TCU) {
        // PHD s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->D);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB a
        switch(regs->TCU) {
        // TSB a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a
        switch(regs->TCU) {
        // ORA a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a
        switch(regs->TCU) {
        // ASL a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al
        switch(regs->TCU) {
        // ORA al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_10_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BPL r
        switch(regs->TCU) {
        // BPL r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_11_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d),y
        switch(regs->TCU) {
        // ORA (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_12_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d)
        switch(regs->TCU) {
        // ORA (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_13_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,s),y
        switch(regs->TCU) {
        // ORA (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_14_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB d
        switch(regs->TCU) {
        // TRB d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_15_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,x
        switch(regs->TCU) {
        // ORA d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_16_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d,x
        switch(regs->TCU) {
        // ASL d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_17_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d],y
        switch(regs->TCU) {
        // ORA [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_18_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLC i
        switch(regs->TCU) {
        // CLC i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_19_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,y
        switch(regs->TCU) {
        // ORA a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC A
        switch(regs->TCU) {
        // INC A E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCS i
        switch(regs->TCU) {
        // TCS i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->C;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB a
        switch(regs->TCU) {
        // TRB a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,x
        switch(regs->TCU) {
        // ORA a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a,x
        switch(regs->TCU) {
        // ASL a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al,x
        switch(regs->TCU) {
        // ORA al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_20_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR a
        switch(regs->TCU) {
        // JSR a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->PDV = 0;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 6
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_21_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,x)
        switch(regs->TCU) {
        // AND (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_22_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSL al
        switch(regs->TCU) {
        // JSL al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        regs->TA += pins->D << 8;
        pins->D = (regs->PBR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0; pins->PDV = 0;
                break;
            case 5: // 6
        pins->PDV = 1;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 6: // 7
        regs->PBR = pins->D;
        pins->RW = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 7: // 8
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_23_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,s
        switch(regs->TCU) {
        // AND d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_24_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d
        switch(regs->TCU) {
        // BIT d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_25_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d
        switch(regs->TCU) {
        // AND d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_26_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d
        switch(regs->TCU) {
        // ROL d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_27_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d]
        switch(regs->TCU) {
        // AND [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_28_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLP s
        switch(regs->TCU) {
        // PLP s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.v = regs->TR;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_29_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND #
        switch(regs->TCU) {
        // AND # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL A
        switch(regs->TCU) {
        // ROL A E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLD s
        switch(regs->TCU) {
        // PLD s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->D = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a
        switch(regs->TCU) {
        // BIT a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a
        switch(regs->TCU) {
        // AND a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a
        switch(regs->TCU) {
        // ROL a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al
        switch(regs->TCU) {
        // AND al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_30_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BMI r
        switch(regs->TCU) {
        // BMI r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_31_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d),y
        switch(regs->TCU) {
        // AND (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_32_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d)
        switch(regs->TCU) {
        // AND (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_33_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,s),y
        switch(regs->TCU) {
        // AND (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_34_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d,x
        switch(regs->TCU) {
        // BIT d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_35_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,x
        switch(regs->TCU) {
        // AND d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_36_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d,x
        switch(regs->TCU) {
        // ROL d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_37_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d],y
        switch(regs->TCU) {
        // AND [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_38_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEC i
        switch(regs->TCU) {
        // SEC i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_39_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,y
        switch(regs->TCU) {
        // AND a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC A
        switch(regs->TCU) {
        // DEC A E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSC i
        switch(regs->TCU) {
        // TSC i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->S);
        regs->P.Z = +((regs->S) == 0);
        regs->P.N = ((regs->S) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a,x
        switch(regs->TCU) {
        // BIT a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,x
        switch(regs->TCU) {
        // AND a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a,x
        switch(regs->TCU) {
        // ROL a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al,x
        switch(regs->TCU) {
        // AND al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_40_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTI s
        switch(regs->TCU) {
        // RTI s E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        pins->PDV = 1;
                break;
            case 4: // 5
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->P.v = pins->D;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x100;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA = pins->D;
                break;
            case 6: // 7
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA += pins->D << 8;
                break;
            case 7: // cleanup_custom
        regs->PC = regs->TA;
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_41_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,x)
        switch(regs->TCU) {
        // EOR (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_42_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WDM i
        switch(regs->TCU) {
        // WDM i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_43_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,s
        switch(regs->TCU) {
        // EOR d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_44_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVP xyc
        switch(regs->TCU) {
        // MVP xyc E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = (regs->X); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = (regs->Y); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
                break;
            case 7: // cleanup_custom
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X - 1) & 0xFF;
        regs->Y = (regs->Y - 1) & 0xFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_45_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d
        switch(regs->TCU) {
        // EOR d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_46_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d
        switch(regs->TCU) {
        // LSR d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_47_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d]
        switch(regs->TCU) {
        // EOR [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_48_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHA s
        switch(regs->TCU) {
        // PHA s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->C) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_49_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR #
        switch(regs->TCU) {
        // EOR # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR A
        switch(regs->TCU) {
        // LSR A E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHK s
        switch(regs->TCU) {
        // PHK s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->PBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP a
        switch(regs->TCU) {
        // JMP a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a
        switch(regs->TCU) {
        // EOR a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a
        switch(regs->TCU) {
        // LSR a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al
        switch(regs->TCU) {
        // EOR al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_50_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVC r
        switch(regs->TCU) {
        // BVC r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_51_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d),y
        switch(regs->TCU) {
        // EOR (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_52_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d)
        switch(regs->TCU) {
        // EOR (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_53_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,s),y
        switch(regs->TCU) {
        // EOR (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_54_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVN xyc
        switch(regs->TCU) {
        // MVN xyc E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = ((regs->X + regs->MD) & 0xFFFF); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = ((regs->Y + regs->MD) & 0xFFFF); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X + 1) & 0xFF;
        regs->Y = (regs->Y + 1) & 0xFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_55_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,x
        switch(regs->TCU) {
        // EOR d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_56_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d,x
        switch(regs->TCU) {
        // LSR d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_57_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d],y
        switch(regs->TCU) {
        // EOR [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_58_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLI i
        switch(regs->TCU) {
        // CLI i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_59_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,y
        switch(regs->TCU) {
        // EOR a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHY s
        switch(regs->TCU) {
        // PHY s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->Y) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCD i
        switch(regs->TCU) {
        // TCD i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->D = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP al
        switch(regs->TCU) {
        // JMP al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = regs->TA + (pins->D << 8);
                break;
            case 4: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,x
        switch(regs->TCU) {
        // EOR a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a,x
        switch(regs->TCU) {
        // LSR a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al,x
        switch(regs->TCU) {
        // EOR al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_60_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTS s
        switch(regs->TCU) {
        // RTS s E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_61_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,x)
        switch(regs->TCU) {
        // ADC (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_62_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PER s
        switch(regs->TCU) {
        // PER s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = (regs->PC + regs->TR + (pins->D << 8)) & 0xFFFF;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
                break;
            case 6: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_63_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,s
        switch(regs->TCU) {
        // ADC d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_64_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d
        switch(regs->TCU) {
        // STZ d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_65_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d
        switch(regs->TCU) {
        // ADC d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_66_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d
        switch(regs->TCU) {
        // ROR d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_67_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d]
        switch(regs->TCU) {
        // ADC [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_68_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLA s
        switch(regs->TCU) {
        // PLA s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_69_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC #
        switch(regs->TCU) {
        // ADC # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR A
        switch(regs->TCU) {
        // ROR A E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTL s
        switch(regs->TCU) {
        // RTL s E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a)
        switch(regs->TCU) {
        // JMP (a) E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a
        switch(regs->TCU) {
        // ADC a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a
        switch(regs->TCU) {
        // ROR a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al
        switch(regs->TCU) {
        // ADC al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_70_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVS r
        switch(regs->TCU) {
        // BVS r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_71_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d),y
        switch(regs->TCU) {
        // ADC (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_72_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d)
        switch(regs->TCU) {
        // ADC (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_73_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,s),y
        switch(regs->TCU) {
        // ADC (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_74_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d,x
        switch(regs->TCU) {
        // STZ d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_75_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,x
        switch(regs->TCU) {
        // ADC d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_76_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d,x
        switch(regs->TCU) {
        // ROR d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_77_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d],y
        switch(regs->TCU) {
        // ADC [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_78_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEI i
        switch(regs->TCU) {
        // SEI i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_79_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,y
        switch(regs->TCU) {
        // ADC a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLY s
        switch(regs->TCU) {
        // PLY s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TDC i
        switch(regs->TCU) {
        // TDC i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->D);
        regs->P.Z = +((regs->D) == 0);
        regs->P.N = ((regs->D) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a,x)
        switch(regs->TCU) {
        // JMP (a,x) E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        regs->TA = (regs->X + regs->TA) & 0xFFFF;
        pins->PDV = 0;
                break;
            case 4:
        pins->PDV = 1;
        pins->Addr = regs->TA; pins->BA = regs->PBR;
                break;
            case 5:
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,x
        switch(regs->TCU) {
        // ADC a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a,x
        switch(regs->TCU) {
        // ROR a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al,x
        switch(regs->TCU) {
        // ADC al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_80_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRA r
        switch(regs->TCU) {
        // BRA r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_81_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,x)
        switch(regs->TCU) {
        // STA (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_82_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRL rl
        switch(regs->TCU) {
        // BRL rl E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TA = (u32)(i16)(regs->TA + (pins->D << 8));
        regs->PC = (regs->PC + regs->TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_83_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,s
        switch(regs->TCU) {
        // STA d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_84_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d
        switch(regs->TCU) {
        // STY d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_85_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d
        switch(regs->TCU) {
        // STA d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_86_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d
        switch(regs->TCU) {
        // STX d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_87_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d]
        switch(regs->TCU) {
        // STA [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_88_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEY i
        switch(regs->TCU) {
        // DEY i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) - 1) & 0xFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_89_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT #
        switch(regs->TCU) {
        // BIT # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXA i
        switch(regs->TCU) {
        // TXA i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->X) & 0xFF);
        regs->P.Z = +((regs->X & 0xFF) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHB s
        switch(regs->TCU) {
        // PHB s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->DBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY a
        switch(regs->TCU) {
        // STY a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a
        switch(regs->TCU) {
        // STA a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX a
        switch(regs->TCU) {
        // STX a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al
        switch(regs->TCU) {
        // STA al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_90_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCC r
        switch(regs->TCU) {
        // BCC r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_91_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d),y
        switch(regs->TCU) {
        // STA (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_92_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d)
        switch(regs->TCU) {
        // STA (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_93_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,s),y
        switch(regs->TCU) {
        // STA (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_94_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d,x
        switch(regs->TCU) {
        // STY d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_95_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,x
        switch(regs->TCU) {
        // STA d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_96_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d,y
        switch(regs->TCU) {
        // STX d,y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_97_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d],y
        switch(regs->TCU) {
        // STA [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_98_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYA i
        switch(regs->TCU) {
        // TYA i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->Y) & 0xFF);
        regs->P.Z = +((regs->Y & 0xFF) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_99_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,y
        switch(regs->TCU) {
        // STA a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9A_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXS i
        switch(regs->TCU) {
        // TXS i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->X;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9B_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXY i
        switch(regs->TCU) {
        // TXY i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->X) & 0xFF);
        regs->P.Z = +((regs->X & 0xFF) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9C_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a
        switch(regs->TCU) {
        // STZ a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9D_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,x
        switch(regs->TCU) {
        // STA a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9E_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a,x
        switch(regs->TCU) {
        // STZ a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9F_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al,x
        switch(regs->TCU) {
        // STA al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A0_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY #
        switch(regs->TCU) {
        // LDY # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A1_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,x)
        switch(regs->TCU) {
        // LDA (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A2_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX #
        switch(regs->TCU) {
        // LDX # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A3_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,s
        switch(regs->TCU) {
        // LDA d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A4_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d
        switch(regs->TCU) {
        // LDY d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A5_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d
        switch(regs->TCU) {
        // LDA d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A6_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d
        switch(regs->TCU) {
        // LDX d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A7_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d]
        switch(regs->TCU) {
        // LDA [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A8_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAY i
        switch(regs->TCU) {
        // TAY i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->C) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A9_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA #
        switch(regs->TCU) {
        // LDA # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AA_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAX i
        switch(regs->TCU) {
        // TAX i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->C) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AB_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLB s
        switch(regs->TCU) {
        // PLB s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->DBR = ((regs->DBR) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AC_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a
        switch(regs->TCU) {
        // LDY a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AD_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a
        switch(regs->TCU) {
        // LDA a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AE_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a
        switch(regs->TCU) {
        // LDX a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AF_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al
        switch(regs->TCU) {
        // LDA al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B0_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCS r
        switch(regs->TCU) {
        // BCS r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B1_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d),y
        switch(regs->TCU) {
        // LDA (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B2_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d)
        switch(regs->TCU) {
        // LDA (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B3_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,s),y
        switch(regs->TCU) {
        // LDA (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B4_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d,x
        switch(regs->TCU) {
        // LDY d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B5_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,x
        switch(regs->TCU) {
        // LDA d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B6_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d,y
        switch(regs->TCU) {
        // LDX d,y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B7_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d],y
        switch(regs->TCU) {
        // LDA [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B8_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLV i
        switch(regs->TCU) {
        // CLV i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.V = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B9_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,y
        switch(regs->TCU) {
        // LDA a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BA_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSX i
        switch(regs->TCU) {
        // TSX i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X  = regs->S & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BB_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYX i
        switch(regs->TCU) {
        // TYX i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->Y) & 0xFF);
        regs->P.Z = +((regs->Y & 0xFF) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BC_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a,x
        switch(regs->TCU) {
        // LDY a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BD_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,x
        switch(regs->TCU) {
        // LDA a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BE_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a,y
        switch(regs->TCU) {
        // LDX a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BF_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al,x
        switch(regs->TCU) {
        // LDA al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C0_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY #
        switch(regs->TCU) {
        // CPY # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C1_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,x)
        switch(regs->TCU) {
        // CMP (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C2_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // REP #
        switch(regs->TCU) {
        // REP # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v &= (~regs->TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C3_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,s
        switch(regs->TCU) {
        // CMP d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C4_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY d
        switch(regs->TCU) {
        // CPY d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C5_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d
        switch(regs->TCU) {
        // CMP d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C6_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d
        switch(regs->TCU) {
        // DEC d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C7_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d]
        switch(regs->TCU) {
        // CMP [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C8_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INY i
        switch(regs->TCU) {
        // INY i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) + 1) & 0xFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C9_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP #
        switch(regs->TCU) {
        // CMP # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CA_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEX i
        switch(regs->TCU) {
        // DEX i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) - 1) & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CB_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WAI i
        switch(regs->TCU) {
        // WAI i E=0 M=1 X=1
            case 1: // 1
        regs->WAI = 1;
                break;
            case 2: // 2
        if (regs->WAI) {
            regs->TCU--;
            break;
        }
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 3: // 3
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CC_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY a
        switch(regs->TCU) {
        // CPY a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CD_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a
        switch(regs->TCU) {
        // CMP a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CE_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a
        switch(regs->TCU) {
        // DEC a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CF_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al
        switch(regs->TCU) {
        // CMP al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D0_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BNE r
        switch(regs->TCU) {
        // BNE r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 0;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D1_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d),y
        switch(regs->TCU) {
        // CMP (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D2_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d)
        switch(regs->TCU) {
        // CMP (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D3_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,s),y
        switch(regs->TCU) {
        // CMP (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D4_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEI s
        switch(regs->TCU) {
        // PEI s E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->D = regs->TR;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 7: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D5_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,x
        switch(regs->TCU) {
        // CMP d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D6_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d,x
        switch(regs->TCU) {
        // DEC d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D7_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d],y
        switch(regs->TCU) {
        // CMP [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D8_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLD i
        switch(regs->TCU) {
        // CLD i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D9_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,y
        switch(regs->TCU) {
        // CMP a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DA_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHX s
        switch(regs->TCU) {
        // PHX s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->X) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DB_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STP i
        switch(regs->TCU) {
        // STP i E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // cleanup_custom
        regs->STP = 1;
        // Following is auto-generated code for instruction finish
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DC_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JML (a)
        switch(regs->TCU) {
        // JML (a) E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->TA + (pins->D << 8); pins->BA = 0;
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->PC = regs->TR + (pins->D << 8);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DD_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,x
        switch(regs->TCU) {
        // CMP a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DE_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a,x
        switch(regs->TCU) {
        // DEC a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DF_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al,x
        switch(regs->TCU) {
        // CMP al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E0_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX #
        switch(regs->TCU) {
        // CPX # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E1_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,x)
        switch(regs->TCU) {
        // SBC (d,x) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E2_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEP #
        switch(regs->TCU) {
        // SEP # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v |= regs->TR;
        if (regs->P.X) { regs->X &= 0xFF, regs->Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E3_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,s
        switch(regs->TCU) {
        // SBC d,s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E4_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX d
        switch(regs->TCU) {
        // CPX d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E5_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d
        switch(regs->TCU) {
        // SBC d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E6_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d
        switch(regs->TCU) {
        // INC d E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E7_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d]
        switch(regs->TCU) {
        // SBC [d] E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E8_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INX i
        switch(regs->TCU) {
        // INX i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) + 1) & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E9_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC #
        switch(regs->TCU) {
        // SBC # E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EA_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // NOP i
        switch(regs->TCU) {
        // NOP i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EB_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XBA i
        switch(regs->TCU) {
        // XBA i E=0 M=1 X=1
            case 1:
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2:
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->C = ((regs->C << 8) & 0xFF00) + ((regs->C >> 8) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EC_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX a
        switch(regs->TCU) {
        // CPX a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_ED_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a
        switch(regs->TCU) {
        // SBC a E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EE_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a
        switch(regs->TCU) {
        // INC a E=0 M=1 X=1
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EF_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al
        switch(regs->TCU) {
        // SBC al E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F0_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BEQ r
        switch(regs->TCU) {
        // BEQ r E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 1;
        regs->skipped_cycle = 0;
        regs->TCU++; regs->skipped_cycle++;           // skip cycle for no E
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F1_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d),y
        switch(regs->TCU) {
        // SBC (d),y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F2_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d)
        switch(regs->TCU) {
        // SBC (d) E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F3_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,s),y
        switch(regs->TCU) {
        // SBC (d,s),y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F4_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEA s
        switch(regs->TCU) {
        // PEA s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR;
                break;
            case 5: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F5_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,x
        switch(regs->TCU) {
        // SBC d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F6_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d,x
        switch(regs->TCU) {
        // INC d,x E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F7_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d],y
        switch(regs->TCU) {
        // SBC [d],y E=0 M=1 X=1
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F8_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SED i
        switch(regs->TCU) {
        // SED i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F9_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,y
        switch(regs->TCU) {
        // SBC a,y E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FA_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLX s
        switch(regs->TCU) {
        // PLX s E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FB_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XCE i
        switch(regs->TCU) {
        // XCE i E=0 M=1 X=1
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        u32 TMP = regs->P.C; regs->P.C = regs->E; regs->E = TMP;
        if (regs->E) {
            regs->P.X = regs->P.M = 1;
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
            regs->S = (regs->S & 0xFF) | 0x100;
        }
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FC_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR (a,x)
        switch(regs->TCU) {
        // JSR (a,x) E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->RW = 1;
        regs->TA = pins->D;
        pins->D = ((regs->PC) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 4
        pins->D = (regs->PC) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TA = (regs->TA + regs->X + (pins->D << 8)) & 0xFFFF;
                break;
            case 6: // 7
        pins->PDV = 1;
        pins->Addr = regs->TA;
                break;
            case 7: // 8
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->PC = pins->D;
                break;
            case 8: // cleanup_custom
        regs->PC += (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FD_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,x
        switch(regs->TCU) {
        // SBC a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FE_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a,x
        switch(regs->TCU) {
        // INC a,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->RW = 1; pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FF_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al,x
        switch(regs->TCU) {
        // SBC al,x E=0 M=1 X=1
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_100_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_RESET s
        switch(regs->TCU) {
        // S_RESET s E=0 M=1 X=1
            case 1: // 3
        pins->RW = 0; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 7
        pins->Addr = (0xFFFC); pins->BA = (0);
        regs->DBR = 0;
        regs->D = 0;
        regs->PBR = 0;
        regs->X &= 0xFF;
        regs->Y &= 0xFF;
        regs->E = 1;
        regs->P.M = regs->P.X = regs->P.I = 1; regs->P.C = 0;
        regs->P.D = 0;
        regs->STP = regs->WAI = 0;
        regs->S = 0x1FF;
                break;
            case 6: // 8
        regs->PC = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->PC += (pins->D << 8);
        pins->PDV = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_101_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_ABORT s
        switch(regs->TCU) {
        // S_ABORT s E=0 M=1 X=1
            case 1: // 3
        regs->TR = regs->PC;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFE8); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFE9); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_102_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_IRQ s
        switch(regs->TCU) {
        // S_IRQ s E=0 M=1 X=1
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEE); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEF); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_103_MX(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_NMI s
        switch(regs->TCU) {
        // S_NMI s E=0 M=1 X=1
            case 1: // 3
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->RW = 1;
        pins->D = regs->PBR;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v;
                break;
            case 5: // 7
        pins->Addr = (0xFFEA); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFEB); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_00_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRK s
        switch(regs->TCU) {
        // BRK s E=1 M=0 X=0
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 4
        regs->TR = regs->PC;
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v | 0x38;
                break;
            case 5: // 7
        pins->Addr = (0xFFFE); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFFF); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_01_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,x)
        switch(regs->TCU) {
        // ORA (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_02_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // COP s
        switch(regs->TCU) {
        // COP s E=1 M=0 X=0
        // instruction code follows
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 4
        regs->TR = regs->PC;
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v & 0xF7;
                break;
            case 5: // 7
        pins->Addr = (0xFFF4); pins->BA = (0);
        pins->RW = 0;
                break;
            case 6: // 8
        pins->Addr = (0xFFF5); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 7: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // instruction code ends
        regs->P.D = 0;
        regs->P.I = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_03_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,s
        switch(regs->TCU) {
        // ORA d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_04_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB d
        switch(regs->TCU) {
        // TSB d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_05_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d
        switch(regs->TCU) {
        // ORA d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_06_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d
        switch(regs->TCU) {
        // ASL d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_07_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d]
        switch(regs->TCU) {
        // ORA [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_08_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHP s
        switch(regs->TCU) {
        // PHP s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->P.v;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_09_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA #
        switch(regs->TCU) {
        // ORA # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL A
        switch(regs->TCU) {
        // ASL A E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHD s
        switch(regs->TCU) {
        // PHD s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->D);
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
        regs->S = (regs->S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSB a
        switch(regs->TCU) {
        // TSB a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (regs->C | regs->TR) & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a
        switch(regs->TCU) {
        // ORA a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a
        switch(regs->TCU) {
        // ASL a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_0F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al
        switch(regs->TCU) {
        // ORA al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_10_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BPL r
        switch(regs->TCU) {
        // BPL r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 0;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_11_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d),y
        switch(regs->TCU) {
        // ORA (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_12_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d)
        switch(regs->TCU) {
        // ORA (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_13_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA (d,s),y
        switch(regs->TCU) {
        // ORA (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_14_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB d
        switch(regs->TCU) {
        // TRB d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_15_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA d,x
        switch(regs->TCU) {
        // ORA d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_16_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL d,x
        switch(regs->TCU) {
        // ASL d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_17_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA [d],y
        switch(regs->TCU) {
        // ORA [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_18_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLC i
        switch(regs->TCU) {
        // CLC i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_19_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,y
        switch(regs->TCU) {
        // ORA a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC A
        switch(regs->TCU) {
        // INC A E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCS i
        switch(regs->TCU) {
        // TCS i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->C;
        regs->S = (regs->S & 0xFF) + 0x100;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TRB a
        switch(regs->TCU) {
        // TRB a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.Z = +((regs->TR & regs->C & 0xFF) == 0);
        regs->TR = (~regs->C) & regs->TR & 0xFF;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA a,x
        switch(regs->TCU) {
        // ORA a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ASL a,x
        switch(regs->TCU) {
        // ASL a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->RW = 1; pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = (regs->TR & 0x7F) << 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_1F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ORA al,x
        switch(regs->TCU) {
        // ORA al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->TR | regs->C) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_20_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR a
        switch(regs->TCU) {
        // JSR a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->PDV = 0;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 6
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_21_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,x)
        switch(regs->TCU) {
        // AND (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_22_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSL al
        switch(regs->TCU) {
        // JSL al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        regs->TA += pins->D << 8;
        pins->D = (regs->PBR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0; pins->PDV = 0;
                break;
            case 5: // 6
        pins->PDV = 1;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 6: // 7
        regs->PBR = pins->D;
        pins->RW = 1;
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->D = ((regs->TR) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 7: // 8
        pins->D = (regs->TR) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        regs->PC = regs->TA;
        // Following is auto-generated code for instruction finish
                break;
            case 8: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_23_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,s
        switch(regs->TCU) {
        // AND d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_24_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d
        switch(regs->TCU) {
        // BIT d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_25_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d
        switch(regs->TCU) {
        // AND d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_26_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d
        switch(regs->TCU) {
        // ROL d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_27_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d]
        switch(regs->TCU) {
        // AND [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_28_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLP s
        switch(regs->TCU) {
        // PLP s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.v = regs->TR | 0x30;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_29_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND #
        switch(regs->TCU) {
        // AND # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL A
        switch(regs->TCU) {
        // ROL A E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLD s
        switch(regs->TCU) {
        // PLD s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        regs->S = (regs->S & 0xFF) + 0x100;
        // instruction code follows
        regs->D = regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a
        switch(regs->TCU) {
        // BIT a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a
        switch(regs->TCU) {
        // AND a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a
        switch(regs->TCU) {
        // ROL a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_2F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al
        switch(regs->TCU) {
        // AND al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_30_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BMI r
        switch(regs->TCU) {
        // BMI r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.N == 1;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_31_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d),y
        switch(regs->TCU) {
        // AND (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_32_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d)
        switch(regs->TCU) {
        // AND (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_33_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND (d,s),y
        switch(regs->TCU) {
        // AND (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_34_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT d,x
        switch(regs->TCU) {
        // BIT d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_35_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND d,x
        switch(regs->TCU) {
        // AND d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_36_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL d,x
        switch(regs->TCU) {
        // ROL d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_37_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND [d],y
        switch(regs->TCU) {
        // AND [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_38_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEC i
        switch(regs->TCU) {
        // SEC i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.C = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_39_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,y
        switch(regs->TCU) {
        // AND a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC A
        switch(regs->TCU) {
        // DEC A E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSC i
        switch(regs->TCU) {
        // TSC i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->S);
        regs->P.Z = +((regs->S) == 0);
        regs->P.N = ((regs->S) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT a,x
        switch(regs->TCU) {
        // BIT a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        regs->P.V = (regs->TR & 0x40) >> 6;
        regs->P.N = (regs->TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND a,x
        switch(regs->TCU) {
        // AND a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROL a,x
        switch(regs->TCU) {
        // ROL a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->RW = 1; pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        u32 carry = regs->P.C;
        regs->P.C = (regs->TR & 0x80) >> 7;
        regs->TR = ((regs->TR & 0x7F) << 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_3F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // AND al,x
        switch(regs->TCU) {
        // AND al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & regs->TR & 0xFF;
        regs->P.Z = +((A) == 0);
        regs->P.N = ((A) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_40_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTI s
        switch(regs->TCU) {
        // RTI s E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        pins->PDV = 1;
                break;
            case 4: // 5
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->P.v = pins->D | 0b00110000;
        if (regs->P.X) {
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
        }
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x100;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->TA = pins->D;
                break;
            case 6: // cleanup_custom
        regs->PC = regs->TA + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_41_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,x)
        switch(regs->TCU) {
        // EOR (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_42_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WDM i
        switch(regs->TCU) {
        // WDM i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_43_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,s
        switch(regs->TCU) {
        // EOR d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_44_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVP xyc
        switch(regs->TCU) {
        // MVP xyc E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = (regs->X); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = (regs->Y); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
                break;
            case 7: // cleanup_custom
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X - 1) & 0xFFFF;
        regs->Y = (regs->Y - 1) & 0xFFFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_45_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d
        switch(regs->TCU) {
        // EOR d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_46_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d
        switch(regs->TCU) {
        // LSR d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_47_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d]
        switch(regs->TCU) {
        // EOR [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_48_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHA s
        switch(regs->TCU) {
        // PHA s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->C) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_49_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR #
        switch(regs->TCU) {
        // EOR # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR A
        switch(regs->TCU) {
        // LSR A E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHK s
        switch(regs->TCU) {
        // PHK s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->PBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP a
        switch(regs->TCU) {
        // JMP a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a
        switch(regs->TCU) {
        // EOR a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a
        switch(regs->TCU) {
        // LSR a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_4F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al
        switch(regs->TCU) {
        // EOR al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_50_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVC r
        switch(regs->TCU) {
        // BVC r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 0;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_51_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d),y
        switch(regs->TCU) {
        // EOR (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_52_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d)
        switch(regs->TCU) {
        // EOR (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_53_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR (d,s),y
        switch(regs->TCU) {
        // EOR (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_54_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // MVN xyc
        switch(regs->TCU) {
        // MVN xyc E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->DBR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA = pins->D;
        pins->Addr = ((regs->X + regs->MD) & 0xFFFF); pins->BA = (regs->TA);
                break;
            case 4: // 5
        pins->RW = 1;
        pins->Addr = ((regs->Y + regs->MD) & 0xFFFF); pins->BA = (regs->DBR);
                break;
            case 5: // 6
        pins->RW = 0; pins->PDV = 0;
                break;
            case 6: // 7
        regs->C = (regs->C - 1) & 0xFFFF;
        regs->X = (regs->X + 1) & 0xFFFF;
        regs->Y = (regs->Y + 1) & 0xFFFF;
        if (regs->C != 0xFFFF) regs->PC = (regs->PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_55_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR d,x
        switch(regs->TCU) {
        // EOR d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_56_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR d,x
        switch(regs->TCU) {
        // LSR d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_57_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR [d],y
        switch(regs->TCU) {
        // EOR [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_58_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLI i
        switch(regs->TCU) {
        // CLI i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_59_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,y
        switch(regs->TCU) {
        // EOR a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHY s
        switch(regs->TCU) {
        // PHY s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->Y) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TCD i
        switch(regs->TCU) {
        // TCD i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->D = (regs->C);
        regs->P.Z = +((regs->C) == 0);
        regs->P.N = ((regs->C) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP al
        switch(regs->TCU) {
        // JMP al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = regs->TA + (pins->D << 8);
                break;
            case 4: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR a,x
        switch(regs->TCU) {
        // EOR a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LSR a,x
        switch(regs->TCU) {
        // LSR a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->RW = 1; pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->P.C = regs->TR & 1;
        regs->TR >>= 1;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_5F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // EOR al,x
        switch(regs->TCU) {
        // EOR al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) ^ regs->TR;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_60_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTS s
        switch(regs->TCU) {
        // RTS s E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_61_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,x)
        switch(regs->TCU) {
        // ADC (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_62_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PER s
        switch(regs->TCU) {
        // PER s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = (regs->PC + regs->TR + (pins->D << 8)) & 0xFFFF;
                break;
            case 4: // 5
        pins->RW = 1; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 5: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR & 0xFF;
                break;
            case 6: // cleanup_custom
        regs->S = (regs->S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_63_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,s
        switch(regs->TCU) {
        // ADC d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_64_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d
        switch(regs->TCU) {
        // STZ d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_65_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d
        switch(regs->TCU) {
        // ADC d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_66_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d
        switch(regs->TCU) {
        // ROR d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_67_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d]
        switch(regs->TCU) {
        // ADC [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_68_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLA s
        switch(regs->TCU) {
        // PLA s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_69_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC #
        switch(regs->TCU) {
        // ADC # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR A
        switch(regs->TCU) {
        // ROR A E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
        regs->TR = regs->C & 0xFF;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        regs->C = (regs->C & 0xFF00) | (regs->TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break;
            case 2: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // RTL s
        switch(regs->TCU) {
        // RTL s E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 5
        regs->TA = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // 6
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
        regs->PC = (regs->TA + (pins->D << 8) + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        regs->S = (regs->S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a)
        switch(regs->TCU) {
        // JMP (a) E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a
        switch(regs->TCU) {
        // ADC a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a
        switch(regs->TCU) {
        // ROR a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_6F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al
        switch(regs->TCU) {
        // ADC al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_70_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BVS r
        switch(regs->TCU) {
        // BVS r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.V == 1;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_71_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d),y
        switch(regs->TCU) {
        // ADC (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_72_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d)
        switch(regs->TCU) {
        // ADC (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_73_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC (d,s),y
        switch(regs->TCU) {
        // ADC (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_74_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ d,x
        switch(regs->TCU) {
        // STZ d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_75_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC d,x
        switch(regs->TCU) {
        // ADC d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_76_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR d,x
        switch(regs->TCU) {
        // ROR d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_77_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC [d],y
        switch(regs->TCU) {
        // ADC [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_78_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEI i
        switch(regs->TCU) {
        // SEI i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2: // cleanup_custom
        // instruction code follows
        regs->P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_79_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,y
        switch(regs->TCU) {
        // ADC a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLY s
        switch(regs->TCU) {
        // PLY s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TDC i
        switch(regs->TCU) {
        // TDC i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = (regs->D);
        regs->P.Z = +((regs->D) == 0);
        regs->P.N = ((regs->D) & 0x8000) >> 15;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JMP (a,x)
        switch(regs->TCU) {
        // JMP (a,x) E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        regs->TA = (regs->X + regs->TA) & 0xFFFF;
        pins->PDV = 0;
                break;
            case 4:
        pins->PDV = 1;
        pins->Addr = regs->TA; pins->BA = regs->PBR;
                break;
            case 5:
        regs->TR = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // cleanup_custom
        regs->PC = regs->TR + (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC a,x
        switch(regs->TCU) {
        // ADC a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ROR a,x
        switch(regs->TCU) {
        // ROR a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->RW = 1; pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        u32 carry = regs->P.C << 7;
        regs->P.C = regs->TR & 0x1;
        regs->TR = ((regs->TR & 0xFF) >> 1) | carry;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_7F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // ADC al,x
        switch(regs->TCU) {
        // ADC al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        u32 A = regs->C & 0xFF; regs->TR &= 0xFF;
        u32 result;
        if (!regs->P.D) result = A + regs->TR + regs->P.C;
        else {
            result = (A & 0x0F) + (regs->TR & 0x0F) + (regs->P.C << 0);
            if (result > 0x09) result += 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs->TR & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ regs->TR)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result > 0x9F) result += 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +(((result & 0xFF)) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_80_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRA r
        switch(regs->TCU) {
        // BRA r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = 1;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_81_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,x)
        switch(regs->TCU) {
        // STA (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_82_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BRL rl
        switch(regs->TCU) {
        // BRL rl E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TA = (u32)(i16)(regs->TA + (pins->D << 8));
        regs->PC = (regs->PC + regs->TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_83_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,s
        switch(regs->TCU) {
        // STA d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_84_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d
        switch(regs->TCU) {
        // STY d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_85_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d
        switch(regs->TCU) {
        // STA d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_86_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d
        switch(regs->TCU) {
        // STX d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_87_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d]
        switch(regs->TCU) {
        // STA [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_88_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEY i
        switch(regs->TCU) {
        // DEY i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) - 1) & 0xFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_89_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BIT #
        switch(regs->TCU) {
        // BIT # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->P.Z = +((regs->C & regs->TR & 0xFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXA i
        switch(regs->TCU) {
        // TXA i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->X) & 0xFF);
        regs->P.Z = +((regs->X & 0xFF) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHB s
        switch(regs->TCU) {
        // PHB s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->DBR) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 3: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY a
        switch(regs->TCU) {
        // STY a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a
        switch(regs->TCU) {
        // STA a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX a
        switch(regs->TCU) {
        // STX a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_8F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al
        switch(regs->TCU) {
        // STA al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_90_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCC r
        switch(regs->TCU) {
        // BCC r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 0;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_91_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d),y
        switch(regs->TCU) {
        // STA (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_92_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d)
        switch(regs->TCU) {
        // STA (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_93_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA (d,s),y
        switch(regs->TCU) {
        // STA (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_94_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STY d,x
        switch(regs->TCU) {
        // STY d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->Y & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_95_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA d,x
        switch(regs->TCU) {
        // STA d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_96_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STX d,y
        switch(regs->TCU) {
        // STX d,y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFF); pins->BA = (0);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = regs->X & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_97_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA [d],y
        switch(regs->TCU) {
        // STA [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_98_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYA i
        switch(regs->TCU) {
        // TYA i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->Y) & 0xFF);
        regs->P.Z = +((regs->Y & 0xFF) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_99_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,y
        switch(regs->TCU) {
        // STA a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9A_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXS i
        switch(regs->TCU) {
        // TXS i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->S = regs->X;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9B_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TXY i
        switch(regs->TCU) {
        // TXY i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->X) & 0xFF);
        regs->P.Z = +((regs->X & 0xFF) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9C_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a
        switch(regs->TCU) {
        // STZ a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
        pins->RW = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9D_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA a,x
        switch(regs->TCU) {
        // STA a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9E_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STZ a,x
        switch(regs->TCU) {
        // STZ a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = 0;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_9F_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STA al,x
        switch(regs->TCU) {
        // STA al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
        pins->RW = 1;
        // instruction code follows
        // #STA
        regs->TR = regs->C & 0xFF;
        // instruction code ends
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 5: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A0_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY #
        switch(regs->TCU) {
        // LDY # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A1_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,x)
        switch(regs->TCU) {
        // LDA (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A2_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX #
        switch(regs->TCU) {
        // LDX # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A3_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,s
        switch(regs->TCU) {
        // LDA d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A4_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d
        switch(regs->TCU) {
        // LDY d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A5_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d
        switch(regs->TCU) {
        // LDA d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A6_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d
        switch(regs->TCU) {
        // LDX d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A7_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d]
        switch(regs->TCU) {
        // LDA [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A8_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAY i
        switch(regs->TCU) {
        // TAY i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->C) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_A9_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA #
        switch(regs->TCU) {
        // LDA # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AA_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TAX i
        switch(regs->TCU) {
        // TAX i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->C) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AB_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLB s
        switch(regs->TCU) {
        // PLB s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->DBR = ((regs->DBR) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AC_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a
        switch(regs->TCU) {
        // LDY a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AD_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a
        switch(regs->TCU) {
        // LDA a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AE_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a
        switch(regs->TCU) {
        // LDX a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_AF_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al
        switch(regs->TCU) {
        // LDA al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B0_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BCS r
        switch(regs->TCU) {
        // BCS r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.C == 1;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B1_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d),y
        switch(regs->TCU) {
        // LDA (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B2_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d)
        switch(regs->TCU) {
        // LDA (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B3_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA (d,s),y
        switch(regs->TCU) {
        // LDA (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B4_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY d,x
        switch(regs->TCU) {
        // LDY d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B5_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA d,x
        switch(regs->TCU) {
        // LDA d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B6_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX d,y
        switch(regs->TCU) {
        // LDX d,y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->Y + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B7_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA [d],y
        switch(regs->TCU) {
        // LDA [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B8_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLV i
        switch(regs->TCU) {
        // CLV i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.V = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_B9_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,y
        switch(regs->TCU) {
        // LDA a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BA_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TSX i
        switch(regs->TCU) {
        // TSX i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X  = regs->S & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BB_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // TYX i
        switch(regs->TCU) {
        // TYX i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->Y) & 0xFF);
        regs->P.Z = +((regs->Y & 0xFF) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BC_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDY a,x
        switch(regs->TCU) {
        // LDY a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->Y = ((regs->Y) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BD_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA a,x
        switch(regs->TCU) {
        // LDA a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BE_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDX a,y
        switch(regs->TCU) {
        // LDX a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_BF_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // LDA al,x
        switch(regs->TCU) {
        // LDA al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->C = ((regs->C) & 0xFF00) + ((regs->TR) & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C0_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY #
        switch(regs->TCU) {
        // CPY # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C1_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,x)
        switch(regs->TCU) {
        // CMP (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C2_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // REP #
        switch(regs->TCU) {
        // REP # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v = ((regs->P.v | 0x30) & (~(regs->TR | 0x30) & 0xFF));
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C3_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,s
        switch(regs->TCU) {
        // CMP d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C4_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY d
        switch(regs->TCU) {
        // CPY d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C5_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d
        switch(regs->TCU) {
        // CMP d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C6_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d
        switch(regs->TCU) {
        // DEC d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C7_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d]
        switch(regs->TCU) {
        // CMP [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C8_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INY i
        switch(regs->TCU) {
        // INY i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->Y = ((regs->Y) + 1) & 0xFF;
        regs->P.Z = +((regs->Y) == 0);
        regs->P.N = ((regs->Y) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_C9_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP #
        switch(regs->TCU) {
        // CMP # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CA_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEX i
        switch(regs->TCU) {
        // DEX i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) - 1) & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CB_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // WAI i
        switch(regs->TCU) {
        // WAI i E=1 M=0 X=0
            case 1: // 1
        regs->WAI = 1;
                break;
            case 2: // 2
        if (regs->WAI) {
            regs->TCU--;
            break;
        }
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 3: // 3
        regs->PC = (regs->PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CC_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPY a
        switch(regs->TCU) {
        // CPY a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->Y & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CD_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a
        switch(regs->TCU) {
        // CMP a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CE_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a
        switch(regs->TCU) {
        // DEC a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_CF_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al
        switch(regs->TCU) {
        // CMP al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D0_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BNE r
        switch(regs->TCU) {
        // BNE r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 0;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D1_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d),y
        switch(regs->TCU) {
        // CMP (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D2_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d)
        switch(regs->TCU) {
        // CMP (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D3_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP (d,s),y
        switch(regs->TCU) {
        // CMP (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D4_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEI s
        switch(regs->TCU) {
        // PEI s E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->D = regs->TR;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 7: // cleanup_custom
        regs->S = (regs->S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D5_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP d,x
        switch(regs->TCU) {
        // CMP d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D6_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC d,x
        switch(regs->TCU) {
        // DEC d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D7_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP [d],y
        switch(regs->TCU) {
        // CMP [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D8_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CLD i
        switch(regs->TCU) {
        // CLD i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 0;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_D9_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,y
        switch(regs->TCU) {
        // CMP a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DA_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PHX s
        switch(regs->TCU) {
        // PHX s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
        pins->RW = 1; pins->PDV = 1;
        // instruction code follows
        regs->TR = (regs->X) & 0xFF;
        // instruction code ends
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR & 0xFF00) >> 8;
                break;
            case 3:
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 4: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DB_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // STP i
        switch(regs->TCU) {
        // STP i E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // cleanup_custom
        regs->STP = 1;
        // Following is auto-generated code for instruction finish
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DC_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JML (a)
        switch(regs->TCU) {
        // JML (a) E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = regs->TA + (pins->D << 8); pins->BA = 0;
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->PC = regs->TR + (pins->D << 8);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // cleanup_custom
        regs->PBR = pins->D;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DD_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP a,x
        switch(regs->TCU) {
        // CMP a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DE_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // DEC a,x
        switch(regs->TCU) {
        // DEC a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->RW = 1; pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = ((regs->TR) - 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_DF_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CMP al,x
        switch(regs->TCU) {
        // CMP al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->C & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E0_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX #
        switch(regs->TCU) {
        // CPX # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E1_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,x)
        switch(regs->TCU) {
        // SBC (d,x) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        regs->TA = (regs->TA + regs->D + regs->X) & 0xFFFF;
                break;
            case 4: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // 5
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E2_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SEP #
        switch(regs->TCU) {
        // SEP # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 2a for REP/SEP
        regs->TR = pins->D;
        pins->PDV = 0;
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->P.v = regs->P.v | 0x30 | regs->TR;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E3_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,s
        switch(regs->TCU) {
        // SBC d,s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E4_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX d
        switch(regs->TCU) {
        // CPX d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E5_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d
        switch(regs->TCU) {
        // SBC d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->Addr = ((regs->D + pins->D) & 0xFFFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E6_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d
        switch(regs->TCU) {
        // INC d E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->D) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E7_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d]
        switch(regs->TCU) {
        // SBC [d] E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = (regs->D + regs->TA & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 5: // 5
        regs->TA += pins->D << 8;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA > 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E8_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INX i
        switch(regs->TCU) {
        // INX i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->X = ((regs->X) + 1) & 0xFF;
        regs->P.Z = +((regs->X) == 0);
        regs->P.N = ((regs->X) & 0x80) >> 7;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_E9_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC #
        switch(regs->TCU) {
        // SBC # E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EA_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // NOP i
        switch(regs->TCU) {
        // NOP i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EB_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XBA i
        switch(regs->TCU) {
        // XBA i E=1 M=0 X=0
            case 1:
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
                break;
            case 2:
                break;
            case 3: // cleanup_custom
        // instruction code follows
        regs->C = ((regs->C << 8) & 0xFF00) + ((regs->C >> 8) & 0xFF);
        regs->P.Z = +((regs->C & 0xFF) == 0);
        regs->P.N = ((regs->C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EC_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // CPX a
        switch(regs->TCU) {
        // CPX a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = (regs->X & 0xFF) - regs->TR;
        regs->P.C = +(regs->TR >= 0);
        regs->P.Z = +((regs->TR & 0xFF) == 0);
        regs->P.N = ((regs->TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_ED_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a
        switch(regs->TCU) {
        // SBC a E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->Addr = (regs->TA + (pins->D << 8)); pins->BA = (regs->DBR);
                break;
            case 4: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EE_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a
        switch(regs->TCU) {
        // INC a E=1 M=0 X=0
        //case AM.Ad
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = (regs->TA); pins->BA = (regs->DBR);
                break;
            case 4: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 5: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 6: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_EF_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al
        switch(regs->TCU) {
        // SBC al E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = (regs->TA); pins->BA = (pins->D);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F0_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // BEQ r
        switch(regs->TCU) {
        // BEQ r E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TR = regs->P.Z == 1;
        regs->skipped_cycle = 0;
        if (!regs->TR) { regs->TCU++; regs->skipped_cycle++; } // skip cycle if NOT taken
                break;
            case 2: // 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // 2b
        if (regs->skipped_cycle == 1) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
                break;
            case 4: // cleanup_custom
        if (regs->skipped_cycle == 2) { regs->TA = pins->D; pins->RW = 0; pins->PDV = 0; } 
        if (regs->TR) regs->PC = (regs->PC + ((u32)(i8)(regs->TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F1_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d),y
        switch(regs->TCU) {
        // SBC (d),y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + (regs->Y & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 5: // 4a
        regs->TA += pins->D << 8;
        pins->Addr = (pins->D << 8) + (regs->TR & 0xFF); pins->BA = regs->DBR;
        pins->PDV = 0;
                break;
            case 6: // 5
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TR = regs->DBR;
        regs->TA += regs->Y;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F2_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d)
        switch(regs->TCU) {
        // SBC (d) E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        pins->Addr = ((regs->TA + (pins->D << 8))); pins->BA = (regs->DBR);
                break;
            case 6: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F3_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC (d,s),y
        switch(regs->TCU) {
        // SBC (d,s),y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->PDV = 0;
        regs->TA = (pins->D + regs->S) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (0);
                break;
            case 4: // 5
        regs->TR = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 6
        regs->TA = (regs->TR + (pins->D << 8) + regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->PDV = 0;
                break;
            case 6: // 7
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F4_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PEA s
        switch(regs->TCU) {
        // PEA s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TR = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
                break;
            case 4: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        pins->D = regs->TR;
                break;
            case 5: // cleanup_custom
        regs->S = (regs->S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F5_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC d,x
        switch(regs->TCU) {
        // SBC d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F6_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC d,x
        switch(regs->TCU) {
        // INC d,x E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
                break;
            case 4: // 4
        pins->PDV = 1;
        pins->Addr = ((regs->TA + regs->X + regs->D) & 0xFF); pins->BA = (0);
                break;
            case 5: // fetch_rmw_8or16 8
        regs->TR = pins->D;
        pins->RW = 1; pins->PDV = 0;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F7_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC [d],y
        switch(regs->TCU) {
        // SBC [d],y E=1 M=0 X=0
            case 1: // fetch_D0_and_skip_cycle 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        if ((regs->D & 0xFF) == 0) { regs->skipped_cycle = 1; regs->TCU++; }
                break;
            case 2: // fetch_D0_and_skip_cycle 2a
        regs->TA = pins->D;
        pins->PDV = 0;
                break;
            case 3: // fetch_D0_and_skip_cycle 3
        if (regs->skipped_cycle) {
            regs->TA = pins->D;
            pins->PDV = 0;
        }
        pins->PDV = 1;
        pins->Addr = ((regs->D + regs->TA) & 0xFFFF); pins->BA = (0);
                break;
            case 4: // 4
        regs->TA = pins->D;
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 5: // 5
        regs->TA = (regs->TA + (pins->D << 8) + regs->Y);
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
                break;
            case 6: // 6
        regs->TR = pins->D;
        if (regs->TA >= 0x10000) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 7: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F8_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SED i
        switch(regs->TCU) {
        // SED i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        regs->P.D = 1;
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_F9_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,y
        switch(regs->TCU) {
        // SBC a,y E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->Y) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->Y ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->Y);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FA_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // PLX s
        switch(regs->TCU) {
        // PLX s E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        pins->PDV = 0;
                break;
            case 2: // 3
                break;
            case 3: // 4
        pins->PDV = 1;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 4: // 4a
        regs->TR = pins->D;
        regs->S = (regs->S + 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->Addr = regs->S; pins->BA = 0;
                break;
            case 5: // cleanup_custom
        regs->TR += (pins->D << 8);
        // instruction code follows
        regs->X = ((regs->X) & 0xFF00) + (regs->TR & 0xFF);
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FB_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // XCE i
        switch(regs->TCU) {
        // XCE i E=1 M=0 X=0
            case 1: // 2
        pins->PDV = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        // instruction code follows
        u32 TMP = regs->P.C; regs->P.C = regs->E; regs->E = TMP;
        if (regs->E) {
            regs->P.X = regs->P.M = 1;
            regs->X &= 0xFF;
            regs->Y &= 0xFF;
            regs->S = (regs->S & 0xFF) | 0x100;
        }
        // instruction code ends
                break;
            case 2: // cleanup_custom
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->PDV = 1;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FC_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // JSR (a,x)
        switch(regs->TCU) {
        // JSR (a,x) E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        pins->RW = 1;
        regs->TA = pins->D;
        pins->D = ((regs->PC) & 0xFF00) >> 8;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 4
        pins->D = (regs->PC) & 0xFF;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 5
        pins->RW = 0;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 5: // 6
        pins->PDV = 0;
        regs->TA = (regs->TA + regs->X + (pins->D << 8)) & 0xFFFF;
                break;
            case 6: // 7
        pins->PDV = 1;
        pins->Addr = regs->TA;
                break;
            case 7: // 8
        pins->Addr = (pins->Addr + 1) & 0xFFFF;
        regs->PC = pins->D;
                break;
            case 8: // cleanup_custom
        regs->PC += (pins->D << 8);
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FD_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC a,x
        switch(regs->TCU) {
        // SBC a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->skipped_cycle = 0;
        regs->TR = regs->TA + ((regs->X) & 0xFF);
        if (regs->TR < 0x100) { regs->skipped_cycle = 1; regs->TCU++; } 
                break;
            case 3: // 3a
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += pins->D << 8;
        pins->Addr = ((pins->D << 8) + (regs->TA + (regs->X ) & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 4
        if (regs->skipped_cycle) regs->TA += pins->D << 8;
        regs->TA += (regs->X);
        regs->TR = regs->DBR;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
        pins->PDV = 1;
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FE_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // INC a,x
        switch(regs->TCU) {
        // INC a,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        pins->PDV = 0;
        regs->TR = regs->DBR;
        regs->TA += (pins->D << 8) + regs->X;
        if (regs->TA > 0xFFFF) { regs->TA -= 0x10000; regs->TR = (regs->TR + 1) & 0xFF; }
        pins->Addr = ((pins->D << 8) + (regs->TA & 0xFF)); pins->BA = (regs->DBR);
                break;
            case 4: // 5
        pins->PDV = 1;
        pins->Addr = (regs->TA); pins->BA = (regs->TR);
                break;
            case 5: // 6
        pins->RW = 1; pins->PDV = 0;
        regs->TR = pins->D;
        // instruction code follows
        regs->TR = ((regs->TR) + 1) & 0xFF;
        regs->P.Z = +((regs->TR) == 0);
        regs->P.N = ((regs->TR) & 0x80) >> 7;
        // instruction code ends
                break;
            case 6: // finish_rmw mem8
        pins->PDV = 1;
        pins->D = regs->TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break;
            case 7: // cleanup
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        pins->RW = 0;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_FF_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // SBC al,x
        switch(regs->TCU) {
        // SBC al,x E=1 M=0 X=0
            case 1: // 2
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 2: // 3
        regs->TA = pins->D;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 3: // 4
        regs->TA += pins->D << 8;
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
                break;
            case 4: // 5
        regs->TA += (pins->D << 16) + regs->X;
        pins->Addr = (regs->TA & 0xFFFF); pins->BA = ((regs->TA >> 16) & 0xFF);
                break;
            case 5: // cleanup_custom
        regs->TR = pins->D;
        // instruction code follows
        i32 A = regs->C & 0xFF; i32 data = (~regs->TR) & 0xFF;
        i32 result;
        if (!regs->P.D) result = data + A + regs->P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs->P.C);
            if (result <= 0x0F) result -= 0x06;
            regs->P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs->P.C << 4) + (result & 0x0F);
        }
        regs->P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs->P.D && result <= 0xFF) result -= 0x60;
        regs->P.C = +(result > 0xFF);
        regs->P.Z = +((result & 0xFF) == 0);
        regs->P.N = ((result) & 0x80) >> 7;
        regs->C = (regs->C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_100_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_RESET s
        switch(regs->TCU) {
        // S_RESET s E=1 M=0 X=0
            case 1: // 3
        pins->RW = 0; pins->PDV = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 2: // 4
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 3: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 4: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
                break;
            case 5: // 7
        pins->Addr = (0xFFFC); pins->BA = (0);
        regs->DBR = 0;
        regs->D = 0;
        regs->PBR = 0;
        regs->X &= 0xFF;
        regs->Y &= 0xFF;
        regs->E = 1;
        regs->P.M = regs->P.X = regs->P.I = 1; regs->P.C = 0;
        regs->P.D = 0;
        regs->STP = regs->WAI = 0;
        regs->S = 0x1FF;
                break;
            case 6: // 8
        regs->PC = pins->D;
        pins->Addr++; if (pins->Addr == 0x10000) { pins->Addr = 0; pins->BA = (pins->BA + 1) & 0xFF; };
                break;
            case 7: // cleanup_custom
        regs->PC += (pins->D << 8);
        pins->PDV = 1;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_101_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_ABORT s
        switch(regs->TCU) {
        // S_ABORT s E=1 M=0 X=0
            case 1: // 4
        regs->TR = regs->PC;
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 2: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 3: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v & 0xF7;
                break;
            case 4: // 7
        pins->Addr = (0xFFF8); pins->BA = (0);
        pins->RW = 0;
                break;
            case 5: // 8
        pins->Addr = (0xFFF9); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 6: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_102_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_IRQ s
        switch(regs->TCU) {
        // S_IRQ s E=1 M=0 X=0
            case 1: // 4
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 2: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 3: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v & 0xF7;
                break;
            case 4: // 7
        pins->Addr = (0xFFFE); pins->BA = (0);
        pins->RW = 0;
                break;
            case 5: // 8
        pins->Addr = (0xFFFF); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 6: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


static void WDC65816_opcode_103_E(struct WDC65816_regs *regs, struct WDC65816_pins *pins) { // S_NMI s
        switch(regs->TCU) {
        // S_NMI s E=1 M=0 X=0
            case 1: // 4
        regs->TR = (regs->PC - 1) & 0xFFFF;
        pins->RW = 1;
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = (regs->TR >> 8) & 0xFF;
                break;
            case 2: // 5
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->TR & 0xFF;
                break;
            case 3: // 6
        pins->Addr = regs->S; pins->BA = 0;
        regs->S = (regs->S - 1) & 0xFFFF;
        if (regs->E) regs->S = (regs->S & 0xFF) | 0x0100;
        pins->D = regs->P.v & 0xF7;
                break;
            case 4: // 7
        pins->Addr = (0xFFFA); pins->BA = (0);
        pins->RW = 0;
                break;
            case 5: // 8
        pins->Addr = (0xFFFB); pins->BA = (0);
        regs->TA = pins->D;
        regs->PBR = 0;
                break;
            case 6: // cleanup_custom
        regs->PC = (pins->D << 8) + regs->TA;
        regs->P.I = 1;
        regs->P.D = 0;
        // Following is auto-generated code for instruction finish
        pins->Addr = regs->PC; pins->BA = regs->PBR;
        regs->PC = (regs->PC + 1) & 0xFFFF;
        regs->TCU = 0;
        break;
        }

}


WDC65816_ins_func wdc65816_decoded_opcodes[5][0x104] = {
{    &WDC65816_opcode_00_mx, &WDC65816_opcode_01_mx, &WDC65816_opcode_02_mx, &WDC65816_opcode_03_mx, &WDC65816_opcode_04_mx, &WDC65816_opcode_05_mx, &WDC65816_opcode_06_mx, &WDC65816_opcode_07_mx, 
    &WDC65816_opcode_08_mx, &WDC65816_opcode_09_mx, &WDC65816_opcode_0A_mx, &WDC65816_opcode_0B_mx, &WDC65816_opcode_0C_mx, &WDC65816_opcode_0D_mx, &WDC65816_opcode_0E_mx, &WDC65816_opcode_0F_mx, 
    &WDC65816_opcode_10_mx, &WDC65816_opcode_11_mx, &WDC65816_opcode_12_mx, &WDC65816_opcode_13_mx, &WDC65816_opcode_14_mx, &WDC65816_opcode_15_mx, &WDC65816_opcode_16_mx, &WDC65816_opcode_17_mx, 
    &WDC65816_opcode_18_mx, &WDC65816_opcode_19_mx, &WDC65816_opcode_1A_mx, &WDC65816_opcode_1B_mx, &WDC65816_opcode_1C_mx, &WDC65816_opcode_1D_mx, &WDC65816_opcode_1E_mx, &WDC65816_opcode_1F_mx, 
    &WDC65816_opcode_20_mx, &WDC65816_opcode_21_mx, &WDC65816_opcode_22_mx, &WDC65816_opcode_23_mx, &WDC65816_opcode_24_mx, &WDC65816_opcode_25_mx, &WDC65816_opcode_26_mx, &WDC65816_opcode_27_mx, 
    &WDC65816_opcode_28_mx, &WDC65816_opcode_29_mx, &WDC65816_opcode_2A_mx, &WDC65816_opcode_2B_mx, &WDC65816_opcode_2C_mx, &WDC65816_opcode_2D_mx, &WDC65816_opcode_2E_mx, &WDC65816_opcode_2F_mx, 
    &WDC65816_opcode_30_mx, &WDC65816_opcode_31_mx, &WDC65816_opcode_32_mx, &WDC65816_opcode_33_mx, &WDC65816_opcode_34_mx, &WDC65816_opcode_35_mx, &WDC65816_opcode_36_mx, &WDC65816_opcode_37_mx, 
    &WDC65816_opcode_38_mx, &WDC65816_opcode_39_mx, &WDC65816_opcode_3A_mx, &WDC65816_opcode_3B_mx, &WDC65816_opcode_3C_mx, &WDC65816_opcode_3D_mx, &WDC65816_opcode_3E_mx, &WDC65816_opcode_3F_mx, 
    &WDC65816_opcode_40_mx, &WDC65816_opcode_41_mx, &WDC65816_opcode_42_mx, &WDC65816_opcode_43_mx, &WDC65816_opcode_44_mx, &WDC65816_opcode_45_mx, &WDC65816_opcode_46_mx, &WDC65816_opcode_47_mx, 
    &WDC65816_opcode_48_mx, &WDC65816_opcode_49_mx, &WDC65816_opcode_4A_mx, &WDC65816_opcode_4B_mx, &WDC65816_opcode_4C_mx, &WDC65816_opcode_4D_mx, &WDC65816_opcode_4E_mx, &WDC65816_opcode_4F_mx, 
    &WDC65816_opcode_50_mx, &WDC65816_opcode_51_mx, &WDC65816_opcode_52_mx, &WDC65816_opcode_53_mx, &WDC65816_opcode_54_mx, &WDC65816_opcode_55_mx, &WDC65816_opcode_56_mx, &WDC65816_opcode_57_mx, 
    &WDC65816_opcode_58_mx, &WDC65816_opcode_59_mx, &WDC65816_opcode_5A_mx, &WDC65816_opcode_5B_mx, &WDC65816_opcode_5C_mx, &WDC65816_opcode_5D_mx, &WDC65816_opcode_5E_mx, &WDC65816_opcode_5F_mx, 
    &WDC65816_opcode_60_mx, &WDC65816_opcode_61_mx, &WDC65816_opcode_62_mx, &WDC65816_opcode_63_mx, &WDC65816_opcode_64_mx, &WDC65816_opcode_65_mx, &WDC65816_opcode_66_mx, &WDC65816_opcode_67_mx, 
    &WDC65816_opcode_68_mx, &WDC65816_opcode_69_mx, &WDC65816_opcode_6A_mx, &WDC65816_opcode_6B_mx, &WDC65816_opcode_6C_mx, &WDC65816_opcode_6D_mx, &WDC65816_opcode_6E_mx, &WDC65816_opcode_6F_mx, 
    &WDC65816_opcode_70_mx, &WDC65816_opcode_71_mx, &WDC65816_opcode_72_mx, &WDC65816_opcode_73_mx, &WDC65816_opcode_74_mx, &WDC65816_opcode_75_mx, &WDC65816_opcode_76_mx, &WDC65816_opcode_77_mx, 
    &WDC65816_opcode_78_mx, &WDC65816_opcode_79_mx, &WDC65816_opcode_7A_mx, &WDC65816_opcode_7B_mx, &WDC65816_opcode_7C_mx, &WDC65816_opcode_7D_mx, &WDC65816_opcode_7E_mx, &WDC65816_opcode_7F_mx, 
    &WDC65816_opcode_80_mx, &WDC65816_opcode_81_mx, &WDC65816_opcode_82_mx, &WDC65816_opcode_83_mx, &WDC65816_opcode_84_mx, &WDC65816_opcode_85_mx, &WDC65816_opcode_86_mx, &WDC65816_opcode_87_mx, 
    &WDC65816_opcode_88_mx, &WDC65816_opcode_89_mx, &WDC65816_opcode_8A_mx, &WDC65816_opcode_8B_mx, &WDC65816_opcode_8C_mx, &WDC65816_opcode_8D_mx, &WDC65816_opcode_8E_mx, &WDC65816_opcode_8F_mx, 
    &WDC65816_opcode_90_mx, &WDC65816_opcode_91_mx, &WDC65816_opcode_92_mx, &WDC65816_opcode_93_mx, &WDC65816_opcode_94_mx, &WDC65816_opcode_95_mx, &WDC65816_opcode_96_mx, &WDC65816_opcode_97_mx, 
    &WDC65816_opcode_98_mx, &WDC65816_opcode_99_mx, &WDC65816_opcode_9A_mx, &WDC65816_opcode_9B_mx, &WDC65816_opcode_9C_mx, &WDC65816_opcode_9D_mx, &WDC65816_opcode_9E_mx, &WDC65816_opcode_9F_mx, 
    &WDC65816_opcode_A0_mx, &WDC65816_opcode_A1_mx, &WDC65816_opcode_A2_mx, &WDC65816_opcode_A3_mx, &WDC65816_opcode_A4_mx, &WDC65816_opcode_A5_mx, &WDC65816_opcode_A6_mx, &WDC65816_opcode_A7_mx, 
    &WDC65816_opcode_A8_mx, &WDC65816_opcode_A9_mx, &WDC65816_opcode_AA_mx, &WDC65816_opcode_AB_mx, &WDC65816_opcode_AC_mx, &WDC65816_opcode_AD_mx, &WDC65816_opcode_AE_mx, &WDC65816_opcode_AF_mx, 
    &WDC65816_opcode_B0_mx, &WDC65816_opcode_B1_mx, &WDC65816_opcode_B2_mx, &WDC65816_opcode_B3_mx, &WDC65816_opcode_B4_mx, &WDC65816_opcode_B5_mx, &WDC65816_opcode_B6_mx, &WDC65816_opcode_B7_mx, 
    &WDC65816_opcode_B8_mx, &WDC65816_opcode_B9_mx, &WDC65816_opcode_BA_mx, &WDC65816_opcode_BB_mx, &WDC65816_opcode_BC_mx, &WDC65816_opcode_BD_mx, &WDC65816_opcode_BE_mx, &WDC65816_opcode_BF_mx, 
    &WDC65816_opcode_C0_mx, &WDC65816_opcode_C1_mx, &WDC65816_opcode_C2_mx, &WDC65816_opcode_C3_mx, &WDC65816_opcode_C4_mx, &WDC65816_opcode_C5_mx, &WDC65816_opcode_C6_mx, &WDC65816_opcode_C7_mx, 
    &WDC65816_opcode_C8_mx, &WDC65816_opcode_C9_mx, &WDC65816_opcode_CA_mx, &WDC65816_opcode_CB_mx, &WDC65816_opcode_CC_mx, &WDC65816_opcode_CD_mx, &WDC65816_opcode_CE_mx, &WDC65816_opcode_CF_mx, 
    &WDC65816_opcode_D0_mx, &WDC65816_opcode_D1_mx, &WDC65816_opcode_D2_mx, &WDC65816_opcode_D3_mx, &WDC65816_opcode_D4_mx, &WDC65816_opcode_D5_mx, &WDC65816_opcode_D6_mx, &WDC65816_opcode_D7_mx, 
    &WDC65816_opcode_D8_mx, &WDC65816_opcode_D9_mx, &WDC65816_opcode_DA_mx, &WDC65816_opcode_DB_mx, &WDC65816_opcode_DC_mx, &WDC65816_opcode_DD_mx, &WDC65816_opcode_DE_mx, &WDC65816_opcode_DF_mx, 
    &WDC65816_opcode_E0_mx, &WDC65816_opcode_E1_mx, &WDC65816_opcode_E2_mx, &WDC65816_opcode_E3_mx, &WDC65816_opcode_E4_mx, &WDC65816_opcode_E5_mx, &WDC65816_opcode_E6_mx, &WDC65816_opcode_E7_mx, 
    &WDC65816_opcode_E8_mx, &WDC65816_opcode_E9_mx, &WDC65816_opcode_EA_mx, &WDC65816_opcode_EB_mx, &WDC65816_opcode_EC_mx, &WDC65816_opcode_ED_mx, &WDC65816_opcode_EE_mx, &WDC65816_opcode_EF_mx, 
    &WDC65816_opcode_F0_mx, &WDC65816_opcode_F1_mx, &WDC65816_opcode_F2_mx, &WDC65816_opcode_F3_mx, &WDC65816_opcode_F4_mx, &WDC65816_opcode_F5_mx, &WDC65816_opcode_F6_mx, &WDC65816_opcode_F7_mx, 
    &WDC65816_opcode_F8_mx, &WDC65816_opcode_F9_mx, &WDC65816_opcode_FA_mx, &WDC65816_opcode_FB_mx, &WDC65816_opcode_FC_mx, &WDC65816_opcode_FD_mx, &WDC65816_opcode_FE_mx, &WDC65816_opcode_FF_mx, 
    &WDC65816_opcode_100_mx, &WDC65816_opcode_101_mx, &WDC65816_opcode_102_mx, &WDC65816_opcode_103_mx, },
{    &WDC65816_opcode_00_Mx, &WDC65816_opcode_01_Mx, &WDC65816_opcode_02_Mx, &WDC65816_opcode_03_Mx, &WDC65816_opcode_04_Mx, &WDC65816_opcode_05_Mx, &WDC65816_opcode_06_Mx, &WDC65816_opcode_07_Mx, 
    &WDC65816_opcode_08_Mx, &WDC65816_opcode_09_Mx, &WDC65816_opcode_0A_Mx, &WDC65816_opcode_0B_Mx, &WDC65816_opcode_0C_Mx, &WDC65816_opcode_0D_Mx, &WDC65816_opcode_0E_Mx, &WDC65816_opcode_0F_Mx, 
    &WDC65816_opcode_10_Mx, &WDC65816_opcode_11_Mx, &WDC65816_opcode_12_Mx, &WDC65816_opcode_13_Mx, &WDC65816_opcode_14_Mx, &WDC65816_opcode_15_Mx, &WDC65816_opcode_16_Mx, &WDC65816_opcode_17_Mx, 
    &WDC65816_opcode_18_Mx, &WDC65816_opcode_19_Mx, &WDC65816_opcode_1A_Mx, &WDC65816_opcode_1B_Mx, &WDC65816_opcode_1C_Mx, &WDC65816_opcode_1D_Mx, &WDC65816_opcode_1E_Mx, &WDC65816_opcode_1F_Mx, 
    &WDC65816_opcode_20_Mx, &WDC65816_opcode_21_Mx, &WDC65816_opcode_22_Mx, &WDC65816_opcode_23_Mx, &WDC65816_opcode_24_Mx, &WDC65816_opcode_25_Mx, &WDC65816_opcode_26_Mx, &WDC65816_opcode_27_Mx, 
    &WDC65816_opcode_28_Mx, &WDC65816_opcode_29_Mx, &WDC65816_opcode_2A_Mx, &WDC65816_opcode_2B_Mx, &WDC65816_opcode_2C_Mx, &WDC65816_opcode_2D_Mx, &WDC65816_opcode_2E_Mx, &WDC65816_opcode_2F_Mx, 
    &WDC65816_opcode_30_Mx, &WDC65816_opcode_31_Mx, &WDC65816_opcode_32_Mx, &WDC65816_opcode_33_Mx, &WDC65816_opcode_34_Mx, &WDC65816_opcode_35_Mx, &WDC65816_opcode_36_Mx, &WDC65816_opcode_37_Mx, 
    &WDC65816_opcode_38_Mx, &WDC65816_opcode_39_Mx, &WDC65816_opcode_3A_Mx, &WDC65816_opcode_3B_Mx, &WDC65816_opcode_3C_Mx, &WDC65816_opcode_3D_Mx, &WDC65816_opcode_3E_Mx, &WDC65816_opcode_3F_Mx, 
    &WDC65816_opcode_40_Mx, &WDC65816_opcode_41_Mx, &WDC65816_opcode_42_Mx, &WDC65816_opcode_43_Mx, &WDC65816_opcode_44_Mx, &WDC65816_opcode_45_Mx, &WDC65816_opcode_46_Mx, &WDC65816_opcode_47_Mx, 
    &WDC65816_opcode_48_Mx, &WDC65816_opcode_49_Mx, &WDC65816_opcode_4A_Mx, &WDC65816_opcode_4B_Mx, &WDC65816_opcode_4C_Mx, &WDC65816_opcode_4D_Mx, &WDC65816_opcode_4E_Mx, &WDC65816_opcode_4F_Mx, 
    &WDC65816_opcode_50_Mx, &WDC65816_opcode_51_Mx, &WDC65816_opcode_52_Mx, &WDC65816_opcode_53_Mx, &WDC65816_opcode_54_Mx, &WDC65816_opcode_55_Mx, &WDC65816_opcode_56_Mx, &WDC65816_opcode_57_Mx, 
    &WDC65816_opcode_58_Mx, &WDC65816_opcode_59_Mx, &WDC65816_opcode_5A_Mx, &WDC65816_opcode_5B_Mx, &WDC65816_opcode_5C_Mx, &WDC65816_opcode_5D_Mx, &WDC65816_opcode_5E_Mx, &WDC65816_opcode_5F_Mx, 
    &WDC65816_opcode_60_Mx, &WDC65816_opcode_61_Mx, &WDC65816_opcode_62_Mx, &WDC65816_opcode_63_Mx, &WDC65816_opcode_64_Mx, &WDC65816_opcode_65_Mx, &WDC65816_opcode_66_Mx, &WDC65816_opcode_67_Mx, 
    &WDC65816_opcode_68_Mx, &WDC65816_opcode_69_Mx, &WDC65816_opcode_6A_Mx, &WDC65816_opcode_6B_Mx, &WDC65816_opcode_6C_Mx, &WDC65816_opcode_6D_Mx, &WDC65816_opcode_6E_Mx, &WDC65816_opcode_6F_Mx, 
    &WDC65816_opcode_70_Mx, &WDC65816_opcode_71_Mx, &WDC65816_opcode_72_Mx, &WDC65816_opcode_73_Mx, &WDC65816_opcode_74_Mx, &WDC65816_opcode_75_Mx, &WDC65816_opcode_76_Mx, &WDC65816_opcode_77_Mx, 
    &WDC65816_opcode_78_Mx, &WDC65816_opcode_79_Mx, &WDC65816_opcode_7A_Mx, &WDC65816_opcode_7B_Mx, &WDC65816_opcode_7C_Mx, &WDC65816_opcode_7D_Mx, &WDC65816_opcode_7E_Mx, &WDC65816_opcode_7F_Mx, 
    &WDC65816_opcode_80_Mx, &WDC65816_opcode_81_Mx, &WDC65816_opcode_82_Mx, &WDC65816_opcode_83_Mx, &WDC65816_opcode_84_Mx, &WDC65816_opcode_85_Mx, &WDC65816_opcode_86_Mx, &WDC65816_opcode_87_Mx, 
    &WDC65816_opcode_88_Mx, &WDC65816_opcode_89_Mx, &WDC65816_opcode_8A_Mx, &WDC65816_opcode_8B_Mx, &WDC65816_opcode_8C_Mx, &WDC65816_opcode_8D_Mx, &WDC65816_opcode_8E_Mx, &WDC65816_opcode_8F_Mx, 
    &WDC65816_opcode_90_Mx, &WDC65816_opcode_91_Mx, &WDC65816_opcode_92_Mx, &WDC65816_opcode_93_Mx, &WDC65816_opcode_94_Mx, &WDC65816_opcode_95_Mx, &WDC65816_opcode_96_Mx, &WDC65816_opcode_97_Mx, 
    &WDC65816_opcode_98_Mx, &WDC65816_opcode_99_Mx, &WDC65816_opcode_9A_Mx, &WDC65816_opcode_9B_Mx, &WDC65816_opcode_9C_Mx, &WDC65816_opcode_9D_Mx, &WDC65816_opcode_9E_Mx, &WDC65816_opcode_9F_Mx, 
    &WDC65816_opcode_A0_Mx, &WDC65816_opcode_A1_Mx, &WDC65816_opcode_A2_Mx, &WDC65816_opcode_A3_Mx, &WDC65816_opcode_A4_Mx, &WDC65816_opcode_A5_Mx, &WDC65816_opcode_A6_Mx, &WDC65816_opcode_A7_Mx, 
    &WDC65816_opcode_A8_Mx, &WDC65816_opcode_A9_Mx, &WDC65816_opcode_AA_Mx, &WDC65816_opcode_AB_Mx, &WDC65816_opcode_AC_Mx, &WDC65816_opcode_AD_Mx, &WDC65816_opcode_AE_Mx, &WDC65816_opcode_AF_Mx, 
    &WDC65816_opcode_B0_Mx, &WDC65816_opcode_B1_Mx, &WDC65816_opcode_B2_Mx, &WDC65816_opcode_B3_Mx, &WDC65816_opcode_B4_Mx, &WDC65816_opcode_B5_Mx, &WDC65816_opcode_B6_Mx, &WDC65816_opcode_B7_Mx, 
    &WDC65816_opcode_B8_Mx, &WDC65816_opcode_B9_Mx, &WDC65816_opcode_BA_Mx, &WDC65816_opcode_BB_Mx, &WDC65816_opcode_BC_Mx, &WDC65816_opcode_BD_Mx, &WDC65816_opcode_BE_Mx, &WDC65816_opcode_BF_Mx, 
    &WDC65816_opcode_C0_Mx, &WDC65816_opcode_C1_Mx, &WDC65816_opcode_C2_Mx, &WDC65816_opcode_C3_Mx, &WDC65816_opcode_C4_Mx, &WDC65816_opcode_C5_Mx, &WDC65816_opcode_C6_Mx, &WDC65816_opcode_C7_Mx, 
    &WDC65816_opcode_C8_Mx, &WDC65816_opcode_C9_Mx, &WDC65816_opcode_CA_Mx, &WDC65816_opcode_CB_Mx, &WDC65816_opcode_CC_Mx, &WDC65816_opcode_CD_Mx, &WDC65816_opcode_CE_Mx, &WDC65816_opcode_CF_Mx, 
    &WDC65816_opcode_D0_Mx, &WDC65816_opcode_D1_Mx, &WDC65816_opcode_D2_Mx, &WDC65816_opcode_D3_Mx, &WDC65816_opcode_D4_Mx, &WDC65816_opcode_D5_Mx, &WDC65816_opcode_D6_Mx, &WDC65816_opcode_D7_Mx, 
    &WDC65816_opcode_D8_Mx, &WDC65816_opcode_D9_Mx, &WDC65816_opcode_DA_Mx, &WDC65816_opcode_DB_Mx, &WDC65816_opcode_DC_Mx, &WDC65816_opcode_DD_Mx, &WDC65816_opcode_DE_Mx, &WDC65816_opcode_DF_Mx, 
    &WDC65816_opcode_E0_Mx, &WDC65816_opcode_E1_Mx, &WDC65816_opcode_E2_Mx, &WDC65816_opcode_E3_Mx, &WDC65816_opcode_E4_Mx, &WDC65816_opcode_E5_Mx, &WDC65816_opcode_E6_Mx, &WDC65816_opcode_E7_Mx, 
    &WDC65816_opcode_E8_Mx, &WDC65816_opcode_E9_Mx, &WDC65816_opcode_EA_Mx, &WDC65816_opcode_EB_Mx, &WDC65816_opcode_EC_Mx, &WDC65816_opcode_ED_Mx, &WDC65816_opcode_EE_Mx, &WDC65816_opcode_EF_Mx, 
    &WDC65816_opcode_F0_Mx, &WDC65816_opcode_F1_Mx, &WDC65816_opcode_F2_Mx, &WDC65816_opcode_F3_Mx, &WDC65816_opcode_F4_Mx, &WDC65816_opcode_F5_Mx, &WDC65816_opcode_F6_Mx, &WDC65816_opcode_F7_Mx, 
    &WDC65816_opcode_F8_Mx, &WDC65816_opcode_F9_Mx, &WDC65816_opcode_FA_Mx, &WDC65816_opcode_FB_Mx, &WDC65816_opcode_FC_Mx, &WDC65816_opcode_FD_Mx, &WDC65816_opcode_FE_Mx, &WDC65816_opcode_FF_Mx, 
    &WDC65816_opcode_100_Mx, &WDC65816_opcode_101_Mx, &WDC65816_opcode_102_Mx, &WDC65816_opcode_103_Mx, },
{    &WDC65816_opcode_00_mX, &WDC65816_opcode_01_mX, &WDC65816_opcode_02_mX, &WDC65816_opcode_03_mX, &WDC65816_opcode_04_mX, &WDC65816_opcode_05_mX, &WDC65816_opcode_06_mX, &WDC65816_opcode_07_mX, 
    &WDC65816_opcode_08_mX, &WDC65816_opcode_09_mX, &WDC65816_opcode_0A_mX, &WDC65816_opcode_0B_mX, &WDC65816_opcode_0C_mX, &WDC65816_opcode_0D_mX, &WDC65816_opcode_0E_mX, &WDC65816_opcode_0F_mX, 
    &WDC65816_opcode_10_mX, &WDC65816_opcode_11_mX, &WDC65816_opcode_12_mX, &WDC65816_opcode_13_mX, &WDC65816_opcode_14_mX, &WDC65816_opcode_15_mX, &WDC65816_opcode_16_mX, &WDC65816_opcode_17_mX, 
    &WDC65816_opcode_18_mX, &WDC65816_opcode_19_mX, &WDC65816_opcode_1A_mX, &WDC65816_opcode_1B_mX, &WDC65816_opcode_1C_mX, &WDC65816_opcode_1D_mX, &WDC65816_opcode_1E_mX, &WDC65816_opcode_1F_mX, 
    &WDC65816_opcode_20_mX, &WDC65816_opcode_21_mX, &WDC65816_opcode_22_mX, &WDC65816_opcode_23_mX, &WDC65816_opcode_24_mX, &WDC65816_opcode_25_mX, &WDC65816_opcode_26_mX, &WDC65816_opcode_27_mX, 
    &WDC65816_opcode_28_mX, &WDC65816_opcode_29_mX, &WDC65816_opcode_2A_mX, &WDC65816_opcode_2B_mX, &WDC65816_opcode_2C_mX, &WDC65816_opcode_2D_mX, &WDC65816_opcode_2E_mX, &WDC65816_opcode_2F_mX, 
    &WDC65816_opcode_30_mX, &WDC65816_opcode_31_mX, &WDC65816_opcode_32_mX, &WDC65816_opcode_33_mX, &WDC65816_opcode_34_mX, &WDC65816_opcode_35_mX, &WDC65816_opcode_36_mX, &WDC65816_opcode_37_mX, 
    &WDC65816_opcode_38_mX, &WDC65816_opcode_39_mX, &WDC65816_opcode_3A_mX, &WDC65816_opcode_3B_mX, &WDC65816_opcode_3C_mX, &WDC65816_opcode_3D_mX, &WDC65816_opcode_3E_mX, &WDC65816_opcode_3F_mX, 
    &WDC65816_opcode_40_mX, &WDC65816_opcode_41_mX, &WDC65816_opcode_42_mX, &WDC65816_opcode_43_mX, &WDC65816_opcode_44_mX, &WDC65816_opcode_45_mX, &WDC65816_opcode_46_mX, &WDC65816_opcode_47_mX, 
    &WDC65816_opcode_48_mX, &WDC65816_opcode_49_mX, &WDC65816_opcode_4A_mX, &WDC65816_opcode_4B_mX, &WDC65816_opcode_4C_mX, &WDC65816_opcode_4D_mX, &WDC65816_opcode_4E_mX, &WDC65816_opcode_4F_mX, 
    &WDC65816_opcode_50_mX, &WDC65816_opcode_51_mX, &WDC65816_opcode_52_mX, &WDC65816_opcode_53_mX, &WDC65816_opcode_54_mX, &WDC65816_opcode_55_mX, &WDC65816_opcode_56_mX, &WDC65816_opcode_57_mX, 
    &WDC65816_opcode_58_mX, &WDC65816_opcode_59_mX, &WDC65816_opcode_5A_mX, &WDC65816_opcode_5B_mX, &WDC65816_opcode_5C_mX, &WDC65816_opcode_5D_mX, &WDC65816_opcode_5E_mX, &WDC65816_opcode_5F_mX, 
    &WDC65816_opcode_60_mX, &WDC65816_opcode_61_mX, &WDC65816_opcode_62_mX, &WDC65816_opcode_63_mX, &WDC65816_opcode_64_mX, &WDC65816_opcode_65_mX, &WDC65816_opcode_66_mX, &WDC65816_opcode_67_mX, 
    &WDC65816_opcode_68_mX, &WDC65816_opcode_69_mX, &WDC65816_opcode_6A_mX, &WDC65816_opcode_6B_mX, &WDC65816_opcode_6C_mX, &WDC65816_opcode_6D_mX, &WDC65816_opcode_6E_mX, &WDC65816_opcode_6F_mX, 
    &WDC65816_opcode_70_mX, &WDC65816_opcode_71_mX, &WDC65816_opcode_72_mX, &WDC65816_opcode_73_mX, &WDC65816_opcode_74_mX, &WDC65816_opcode_75_mX, &WDC65816_opcode_76_mX, &WDC65816_opcode_77_mX, 
    &WDC65816_opcode_78_mX, &WDC65816_opcode_79_mX, &WDC65816_opcode_7A_mX, &WDC65816_opcode_7B_mX, &WDC65816_opcode_7C_mX, &WDC65816_opcode_7D_mX, &WDC65816_opcode_7E_mX, &WDC65816_opcode_7F_mX, 
    &WDC65816_opcode_80_mX, &WDC65816_opcode_81_mX, &WDC65816_opcode_82_mX, &WDC65816_opcode_83_mX, &WDC65816_opcode_84_mX, &WDC65816_opcode_85_mX, &WDC65816_opcode_86_mX, &WDC65816_opcode_87_mX, 
    &WDC65816_opcode_88_mX, &WDC65816_opcode_89_mX, &WDC65816_opcode_8A_mX, &WDC65816_opcode_8B_mX, &WDC65816_opcode_8C_mX, &WDC65816_opcode_8D_mX, &WDC65816_opcode_8E_mX, &WDC65816_opcode_8F_mX, 
    &WDC65816_opcode_90_mX, &WDC65816_opcode_91_mX, &WDC65816_opcode_92_mX, &WDC65816_opcode_93_mX, &WDC65816_opcode_94_mX, &WDC65816_opcode_95_mX, &WDC65816_opcode_96_mX, &WDC65816_opcode_97_mX, 
    &WDC65816_opcode_98_mX, &WDC65816_opcode_99_mX, &WDC65816_opcode_9A_mX, &WDC65816_opcode_9B_mX, &WDC65816_opcode_9C_mX, &WDC65816_opcode_9D_mX, &WDC65816_opcode_9E_mX, &WDC65816_opcode_9F_mX, 
    &WDC65816_opcode_A0_mX, &WDC65816_opcode_A1_mX, &WDC65816_opcode_A2_mX, &WDC65816_opcode_A3_mX, &WDC65816_opcode_A4_mX, &WDC65816_opcode_A5_mX, &WDC65816_opcode_A6_mX, &WDC65816_opcode_A7_mX, 
    &WDC65816_opcode_A8_mX, &WDC65816_opcode_A9_mX, &WDC65816_opcode_AA_mX, &WDC65816_opcode_AB_mX, &WDC65816_opcode_AC_mX, &WDC65816_opcode_AD_mX, &WDC65816_opcode_AE_mX, &WDC65816_opcode_AF_mX, 
    &WDC65816_opcode_B0_mX, &WDC65816_opcode_B1_mX, &WDC65816_opcode_B2_mX, &WDC65816_opcode_B3_mX, &WDC65816_opcode_B4_mX, &WDC65816_opcode_B5_mX, &WDC65816_opcode_B6_mX, &WDC65816_opcode_B7_mX, 
    &WDC65816_opcode_B8_mX, &WDC65816_opcode_B9_mX, &WDC65816_opcode_BA_mX, &WDC65816_opcode_BB_mX, &WDC65816_opcode_BC_mX, &WDC65816_opcode_BD_mX, &WDC65816_opcode_BE_mX, &WDC65816_opcode_BF_mX, 
    &WDC65816_opcode_C0_mX, &WDC65816_opcode_C1_mX, &WDC65816_opcode_C2_mX, &WDC65816_opcode_C3_mX, &WDC65816_opcode_C4_mX, &WDC65816_opcode_C5_mX, &WDC65816_opcode_C6_mX, &WDC65816_opcode_C7_mX, 
    &WDC65816_opcode_C8_mX, &WDC65816_opcode_C9_mX, &WDC65816_opcode_CA_mX, &WDC65816_opcode_CB_mX, &WDC65816_opcode_CC_mX, &WDC65816_opcode_CD_mX, &WDC65816_opcode_CE_mX, &WDC65816_opcode_CF_mX, 
    &WDC65816_opcode_D0_mX, &WDC65816_opcode_D1_mX, &WDC65816_opcode_D2_mX, &WDC65816_opcode_D3_mX, &WDC65816_opcode_D4_mX, &WDC65816_opcode_D5_mX, &WDC65816_opcode_D6_mX, &WDC65816_opcode_D7_mX, 
    &WDC65816_opcode_D8_mX, &WDC65816_opcode_D9_mX, &WDC65816_opcode_DA_mX, &WDC65816_opcode_DB_mX, &WDC65816_opcode_DC_mX, &WDC65816_opcode_DD_mX, &WDC65816_opcode_DE_mX, &WDC65816_opcode_DF_mX, 
    &WDC65816_opcode_E0_mX, &WDC65816_opcode_E1_mX, &WDC65816_opcode_E2_mX, &WDC65816_opcode_E3_mX, &WDC65816_opcode_E4_mX, &WDC65816_opcode_E5_mX, &WDC65816_opcode_E6_mX, &WDC65816_opcode_E7_mX, 
    &WDC65816_opcode_E8_mX, &WDC65816_opcode_E9_mX, &WDC65816_opcode_EA_mX, &WDC65816_opcode_EB_mX, &WDC65816_opcode_EC_mX, &WDC65816_opcode_ED_mX, &WDC65816_opcode_EE_mX, &WDC65816_opcode_EF_mX, 
    &WDC65816_opcode_F0_mX, &WDC65816_opcode_F1_mX, &WDC65816_opcode_F2_mX, &WDC65816_opcode_F3_mX, &WDC65816_opcode_F4_mX, &WDC65816_opcode_F5_mX, &WDC65816_opcode_F6_mX, &WDC65816_opcode_F7_mX, 
    &WDC65816_opcode_F8_mX, &WDC65816_opcode_F9_mX, &WDC65816_opcode_FA_mX, &WDC65816_opcode_FB_mX, &WDC65816_opcode_FC_mX, &WDC65816_opcode_FD_mX, &WDC65816_opcode_FE_mX, &WDC65816_opcode_FF_mX, 
    &WDC65816_opcode_100_mX, &WDC65816_opcode_101_mX, &WDC65816_opcode_102_mX, &WDC65816_opcode_103_mX, },
{    &WDC65816_opcode_00_MX, &WDC65816_opcode_01_MX, &WDC65816_opcode_02_MX, &WDC65816_opcode_03_MX, &WDC65816_opcode_04_MX, &WDC65816_opcode_05_MX, &WDC65816_opcode_06_MX, &WDC65816_opcode_07_MX, 
    &WDC65816_opcode_08_MX, &WDC65816_opcode_09_MX, &WDC65816_opcode_0A_MX, &WDC65816_opcode_0B_MX, &WDC65816_opcode_0C_MX, &WDC65816_opcode_0D_MX, &WDC65816_opcode_0E_MX, &WDC65816_opcode_0F_MX, 
    &WDC65816_opcode_10_MX, &WDC65816_opcode_11_MX, &WDC65816_opcode_12_MX, &WDC65816_opcode_13_MX, &WDC65816_opcode_14_MX, &WDC65816_opcode_15_MX, &WDC65816_opcode_16_MX, &WDC65816_opcode_17_MX, 
    &WDC65816_opcode_18_MX, &WDC65816_opcode_19_MX, &WDC65816_opcode_1A_MX, &WDC65816_opcode_1B_MX, &WDC65816_opcode_1C_MX, &WDC65816_opcode_1D_MX, &WDC65816_opcode_1E_MX, &WDC65816_opcode_1F_MX, 
    &WDC65816_opcode_20_MX, &WDC65816_opcode_21_MX, &WDC65816_opcode_22_MX, &WDC65816_opcode_23_MX, &WDC65816_opcode_24_MX, &WDC65816_opcode_25_MX, &WDC65816_opcode_26_MX, &WDC65816_opcode_27_MX, 
    &WDC65816_opcode_28_MX, &WDC65816_opcode_29_MX, &WDC65816_opcode_2A_MX, &WDC65816_opcode_2B_MX, &WDC65816_opcode_2C_MX, &WDC65816_opcode_2D_MX, &WDC65816_opcode_2E_MX, &WDC65816_opcode_2F_MX, 
    &WDC65816_opcode_30_MX, &WDC65816_opcode_31_MX, &WDC65816_opcode_32_MX, &WDC65816_opcode_33_MX, &WDC65816_opcode_34_MX, &WDC65816_opcode_35_MX, &WDC65816_opcode_36_MX, &WDC65816_opcode_37_MX, 
    &WDC65816_opcode_38_MX, &WDC65816_opcode_39_MX, &WDC65816_opcode_3A_MX, &WDC65816_opcode_3B_MX, &WDC65816_opcode_3C_MX, &WDC65816_opcode_3D_MX, &WDC65816_opcode_3E_MX, &WDC65816_opcode_3F_MX, 
    &WDC65816_opcode_40_MX, &WDC65816_opcode_41_MX, &WDC65816_opcode_42_MX, &WDC65816_opcode_43_MX, &WDC65816_opcode_44_MX, &WDC65816_opcode_45_MX, &WDC65816_opcode_46_MX, &WDC65816_opcode_47_MX, 
    &WDC65816_opcode_48_MX, &WDC65816_opcode_49_MX, &WDC65816_opcode_4A_MX, &WDC65816_opcode_4B_MX, &WDC65816_opcode_4C_MX, &WDC65816_opcode_4D_MX, &WDC65816_opcode_4E_MX, &WDC65816_opcode_4F_MX, 
    &WDC65816_opcode_50_MX, &WDC65816_opcode_51_MX, &WDC65816_opcode_52_MX, &WDC65816_opcode_53_MX, &WDC65816_opcode_54_MX, &WDC65816_opcode_55_MX, &WDC65816_opcode_56_MX, &WDC65816_opcode_57_MX, 
    &WDC65816_opcode_58_MX, &WDC65816_opcode_59_MX, &WDC65816_opcode_5A_MX, &WDC65816_opcode_5B_MX, &WDC65816_opcode_5C_MX, &WDC65816_opcode_5D_MX, &WDC65816_opcode_5E_MX, &WDC65816_opcode_5F_MX, 
    &WDC65816_opcode_60_MX, &WDC65816_opcode_61_MX, &WDC65816_opcode_62_MX, &WDC65816_opcode_63_MX, &WDC65816_opcode_64_MX, &WDC65816_opcode_65_MX, &WDC65816_opcode_66_MX, &WDC65816_opcode_67_MX, 
    &WDC65816_opcode_68_MX, &WDC65816_opcode_69_MX, &WDC65816_opcode_6A_MX, &WDC65816_opcode_6B_MX, &WDC65816_opcode_6C_MX, &WDC65816_opcode_6D_MX, &WDC65816_opcode_6E_MX, &WDC65816_opcode_6F_MX, 
    &WDC65816_opcode_70_MX, &WDC65816_opcode_71_MX, &WDC65816_opcode_72_MX, &WDC65816_opcode_73_MX, &WDC65816_opcode_74_MX, &WDC65816_opcode_75_MX, &WDC65816_opcode_76_MX, &WDC65816_opcode_77_MX, 
    &WDC65816_opcode_78_MX, &WDC65816_opcode_79_MX, &WDC65816_opcode_7A_MX, &WDC65816_opcode_7B_MX, &WDC65816_opcode_7C_MX, &WDC65816_opcode_7D_MX, &WDC65816_opcode_7E_MX, &WDC65816_opcode_7F_MX, 
    &WDC65816_opcode_80_MX, &WDC65816_opcode_81_MX, &WDC65816_opcode_82_MX, &WDC65816_opcode_83_MX, &WDC65816_opcode_84_MX, &WDC65816_opcode_85_MX, &WDC65816_opcode_86_MX, &WDC65816_opcode_87_MX, 
    &WDC65816_opcode_88_MX, &WDC65816_opcode_89_MX, &WDC65816_opcode_8A_MX, &WDC65816_opcode_8B_MX, &WDC65816_opcode_8C_MX, &WDC65816_opcode_8D_MX, &WDC65816_opcode_8E_MX, &WDC65816_opcode_8F_MX, 
    &WDC65816_opcode_90_MX, &WDC65816_opcode_91_MX, &WDC65816_opcode_92_MX, &WDC65816_opcode_93_MX, &WDC65816_opcode_94_MX, &WDC65816_opcode_95_MX, &WDC65816_opcode_96_MX, &WDC65816_opcode_97_MX, 
    &WDC65816_opcode_98_MX, &WDC65816_opcode_99_MX, &WDC65816_opcode_9A_MX, &WDC65816_opcode_9B_MX, &WDC65816_opcode_9C_MX, &WDC65816_opcode_9D_MX, &WDC65816_opcode_9E_MX, &WDC65816_opcode_9F_MX, 
    &WDC65816_opcode_A0_MX, &WDC65816_opcode_A1_MX, &WDC65816_opcode_A2_MX, &WDC65816_opcode_A3_MX, &WDC65816_opcode_A4_MX, &WDC65816_opcode_A5_MX, &WDC65816_opcode_A6_MX, &WDC65816_opcode_A7_MX, 
    &WDC65816_opcode_A8_MX, &WDC65816_opcode_A9_MX, &WDC65816_opcode_AA_MX, &WDC65816_opcode_AB_MX, &WDC65816_opcode_AC_MX, &WDC65816_opcode_AD_MX, &WDC65816_opcode_AE_MX, &WDC65816_opcode_AF_MX, 
    &WDC65816_opcode_B0_MX, &WDC65816_opcode_B1_MX, &WDC65816_opcode_B2_MX, &WDC65816_opcode_B3_MX, &WDC65816_opcode_B4_MX, &WDC65816_opcode_B5_MX, &WDC65816_opcode_B6_MX, &WDC65816_opcode_B7_MX, 
    &WDC65816_opcode_B8_MX, &WDC65816_opcode_B9_MX, &WDC65816_opcode_BA_MX, &WDC65816_opcode_BB_MX, &WDC65816_opcode_BC_MX, &WDC65816_opcode_BD_MX, &WDC65816_opcode_BE_MX, &WDC65816_opcode_BF_MX, 
    &WDC65816_opcode_C0_MX, &WDC65816_opcode_C1_MX, &WDC65816_opcode_C2_MX, &WDC65816_opcode_C3_MX, &WDC65816_opcode_C4_MX, &WDC65816_opcode_C5_MX, &WDC65816_opcode_C6_MX, &WDC65816_opcode_C7_MX, 
    &WDC65816_opcode_C8_MX, &WDC65816_opcode_C9_MX, &WDC65816_opcode_CA_MX, &WDC65816_opcode_CB_MX, &WDC65816_opcode_CC_MX, &WDC65816_opcode_CD_MX, &WDC65816_opcode_CE_MX, &WDC65816_opcode_CF_MX, 
    &WDC65816_opcode_D0_MX, &WDC65816_opcode_D1_MX, &WDC65816_opcode_D2_MX, &WDC65816_opcode_D3_MX, &WDC65816_opcode_D4_MX, &WDC65816_opcode_D5_MX, &WDC65816_opcode_D6_MX, &WDC65816_opcode_D7_MX, 
    &WDC65816_opcode_D8_MX, &WDC65816_opcode_D9_MX, &WDC65816_opcode_DA_MX, &WDC65816_opcode_DB_MX, &WDC65816_opcode_DC_MX, &WDC65816_opcode_DD_MX, &WDC65816_opcode_DE_MX, &WDC65816_opcode_DF_MX, 
    &WDC65816_opcode_E0_MX, &WDC65816_opcode_E1_MX, &WDC65816_opcode_E2_MX, &WDC65816_opcode_E3_MX, &WDC65816_opcode_E4_MX, &WDC65816_opcode_E5_MX, &WDC65816_opcode_E6_MX, &WDC65816_opcode_E7_MX, 
    &WDC65816_opcode_E8_MX, &WDC65816_opcode_E9_MX, &WDC65816_opcode_EA_MX, &WDC65816_opcode_EB_MX, &WDC65816_opcode_EC_MX, &WDC65816_opcode_ED_MX, &WDC65816_opcode_EE_MX, &WDC65816_opcode_EF_MX, 
    &WDC65816_opcode_F0_MX, &WDC65816_opcode_F1_MX, &WDC65816_opcode_F2_MX, &WDC65816_opcode_F3_MX, &WDC65816_opcode_F4_MX, &WDC65816_opcode_F5_MX, &WDC65816_opcode_F6_MX, &WDC65816_opcode_F7_MX, 
    &WDC65816_opcode_F8_MX, &WDC65816_opcode_F9_MX, &WDC65816_opcode_FA_MX, &WDC65816_opcode_FB_MX, &WDC65816_opcode_FC_MX, &WDC65816_opcode_FD_MX, &WDC65816_opcode_FE_MX, &WDC65816_opcode_FF_MX, 
    &WDC65816_opcode_100_MX, &WDC65816_opcode_101_MX, &WDC65816_opcode_102_MX, &WDC65816_opcode_103_MX, },
{    &WDC65816_opcode_00_E, &WDC65816_opcode_01_E, &WDC65816_opcode_02_E, &WDC65816_opcode_03_E, &WDC65816_opcode_04_E, &WDC65816_opcode_05_E, &WDC65816_opcode_06_E, &WDC65816_opcode_07_E, 
    &WDC65816_opcode_08_E, &WDC65816_opcode_09_E, &WDC65816_opcode_0A_E, &WDC65816_opcode_0B_E, &WDC65816_opcode_0C_E, &WDC65816_opcode_0D_E, &WDC65816_opcode_0E_E, &WDC65816_opcode_0F_E, 
    &WDC65816_opcode_10_E, &WDC65816_opcode_11_E, &WDC65816_opcode_12_E, &WDC65816_opcode_13_E, &WDC65816_opcode_14_E, &WDC65816_opcode_15_E, &WDC65816_opcode_16_E, &WDC65816_opcode_17_E, 
    &WDC65816_opcode_18_E, &WDC65816_opcode_19_E, &WDC65816_opcode_1A_E, &WDC65816_opcode_1B_E, &WDC65816_opcode_1C_E, &WDC65816_opcode_1D_E, &WDC65816_opcode_1E_E, &WDC65816_opcode_1F_E, 
    &WDC65816_opcode_20_E, &WDC65816_opcode_21_E, &WDC65816_opcode_22_E, &WDC65816_opcode_23_E, &WDC65816_opcode_24_E, &WDC65816_opcode_25_E, &WDC65816_opcode_26_E, &WDC65816_opcode_27_E, 
    &WDC65816_opcode_28_E, &WDC65816_opcode_29_E, &WDC65816_opcode_2A_E, &WDC65816_opcode_2B_E, &WDC65816_opcode_2C_E, &WDC65816_opcode_2D_E, &WDC65816_opcode_2E_E, &WDC65816_opcode_2F_E, 
    &WDC65816_opcode_30_E, &WDC65816_opcode_31_E, &WDC65816_opcode_32_E, &WDC65816_opcode_33_E, &WDC65816_opcode_34_E, &WDC65816_opcode_35_E, &WDC65816_opcode_36_E, &WDC65816_opcode_37_E, 
    &WDC65816_opcode_38_E, &WDC65816_opcode_39_E, &WDC65816_opcode_3A_E, &WDC65816_opcode_3B_E, &WDC65816_opcode_3C_E, &WDC65816_opcode_3D_E, &WDC65816_opcode_3E_E, &WDC65816_opcode_3F_E, 
    &WDC65816_opcode_40_E, &WDC65816_opcode_41_E, &WDC65816_opcode_42_E, &WDC65816_opcode_43_E, &WDC65816_opcode_44_E, &WDC65816_opcode_45_E, &WDC65816_opcode_46_E, &WDC65816_opcode_47_E, 
    &WDC65816_opcode_48_E, &WDC65816_opcode_49_E, &WDC65816_opcode_4A_E, &WDC65816_opcode_4B_E, &WDC65816_opcode_4C_E, &WDC65816_opcode_4D_E, &WDC65816_opcode_4E_E, &WDC65816_opcode_4F_E, 
    &WDC65816_opcode_50_E, &WDC65816_opcode_51_E, &WDC65816_opcode_52_E, &WDC65816_opcode_53_E, &WDC65816_opcode_54_E, &WDC65816_opcode_55_E, &WDC65816_opcode_56_E, &WDC65816_opcode_57_E, 
    &WDC65816_opcode_58_E, &WDC65816_opcode_59_E, &WDC65816_opcode_5A_E, &WDC65816_opcode_5B_E, &WDC65816_opcode_5C_E, &WDC65816_opcode_5D_E, &WDC65816_opcode_5E_E, &WDC65816_opcode_5F_E, 
    &WDC65816_opcode_60_E, &WDC65816_opcode_61_E, &WDC65816_opcode_62_E, &WDC65816_opcode_63_E, &WDC65816_opcode_64_E, &WDC65816_opcode_65_E, &WDC65816_opcode_66_E, &WDC65816_opcode_67_E, 
    &WDC65816_opcode_68_E, &WDC65816_opcode_69_E, &WDC65816_opcode_6A_E, &WDC65816_opcode_6B_E, &WDC65816_opcode_6C_E, &WDC65816_opcode_6D_E, &WDC65816_opcode_6E_E, &WDC65816_opcode_6F_E, 
    &WDC65816_opcode_70_E, &WDC65816_opcode_71_E, &WDC65816_opcode_72_E, &WDC65816_opcode_73_E, &WDC65816_opcode_74_E, &WDC65816_opcode_75_E, &WDC65816_opcode_76_E, &WDC65816_opcode_77_E, 
    &WDC65816_opcode_78_E, &WDC65816_opcode_79_E, &WDC65816_opcode_7A_E, &WDC65816_opcode_7B_E, &WDC65816_opcode_7C_E, &WDC65816_opcode_7D_E, &WDC65816_opcode_7E_E, &WDC65816_opcode_7F_E, 
    &WDC65816_opcode_80_E, &WDC65816_opcode_81_E, &WDC65816_opcode_82_E, &WDC65816_opcode_83_E, &WDC65816_opcode_84_E, &WDC65816_opcode_85_E, &WDC65816_opcode_86_E, &WDC65816_opcode_87_E, 
    &WDC65816_opcode_88_E, &WDC65816_opcode_89_E, &WDC65816_opcode_8A_E, &WDC65816_opcode_8B_E, &WDC65816_opcode_8C_E, &WDC65816_opcode_8D_E, &WDC65816_opcode_8E_E, &WDC65816_opcode_8F_E, 
    &WDC65816_opcode_90_E, &WDC65816_opcode_91_E, &WDC65816_opcode_92_E, &WDC65816_opcode_93_E, &WDC65816_opcode_94_E, &WDC65816_opcode_95_E, &WDC65816_opcode_96_E, &WDC65816_opcode_97_E, 
    &WDC65816_opcode_98_E, &WDC65816_opcode_99_E, &WDC65816_opcode_9A_E, &WDC65816_opcode_9B_E, &WDC65816_opcode_9C_E, &WDC65816_opcode_9D_E, &WDC65816_opcode_9E_E, &WDC65816_opcode_9F_E, 
    &WDC65816_opcode_A0_E, &WDC65816_opcode_A1_E, &WDC65816_opcode_A2_E, &WDC65816_opcode_A3_E, &WDC65816_opcode_A4_E, &WDC65816_opcode_A5_E, &WDC65816_opcode_A6_E, &WDC65816_opcode_A7_E, 
    &WDC65816_opcode_A8_E, &WDC65816_opcode_A9_E, &WDC65816_opcode_AA_E, &WDC65816_opcode_AB_E, &WDC65816_opcode_AC_E, &WDC65816_opcode_AD_E, &WDC65816_opcode_AE_E, &WDC65816_opcode_AF_E, 
    &WDC65816_opcode_B0_E, &WDC65816_opcode_B1_E, &WDC65816_opcode_B2_E, &WDC65816_opcode_B3_E, &WDC65816_opcode_B4_E, &WDC65816_opcode_B5_E, &WDC65816_opcode_B6_E, &WDC65816_opcode_B7_E, 
    &WDC65816_opcode_B8_E, &WDC65816_opcode_B9_E, &WDC65816_opcode_BA_E, &WDC65816_opcode_BB_E, &WDC65816_opcode_BC_E, &WDC65816_opcode_BD_E, &WDC65816_opcode_BE_E, &WDC65816_opcode_BF_E, 
    &WDC65816_opcode_C0_E, &WDC65816_opcode_C1_E, &WDC65816_opcode_C2_E, &WDC65816_opcode_C3_E, &WDC65816_opcode_C4_E, &WDC65816_opcode_C5_E, &WDC65816_opcode_C6_E, &WDC65816_opcode_C7_E, 
    &WDC65816_opcode_C8_E, &WDC65816_opcode_C9_E, &WDC65816_opcode_CA_E, &WDC65816_opcode_CB_E, &WDC65816_opcode_CC_E, &WDC65816_opcode_CD_E, &WDC65816_opcode_CE_E, &WDC65816_opcode_CF_E, 
    &WDC65816_opcode_D0_E, &WDC65816_opcode_D1_E, &WDC65816_opcode_D2_E, &WDC65816_opcode_D3_E, &WDC65816_opcode_D4_E, &WDC65816_opcode_D5_E, &WDC65816_opcode_D6_E, &WDC65816_opcode_D7_E, 
    &WDC65816_opcode_D8_E, &WDC65816_opcode_D9_E, &WDC65816_opcode_DA_E, &WDC65816_opcode_DB_E, &WDC65816_opcode_DC_E, &WDC65816_opcode_DD_E, &WDC65816_opcode_DE_E, &WDC65816_opcode_DF_E, 
    &WDC65816_opcode_E0_E, &WDC65816_opcode_E1_E, &WDC65816_opcode_E2_E, &WDC65816_opcode_E3_E, &WDC65816_opcode_E4_E, &WDC65816_opcode_E5_E, &WDC65816_opcode_E6_E, &WDC65816_opcode_E7_E, 
    &WDC65816_opcode_E8_E, &WDC65816_opcode_E9_E, &WDC65816_opcode_EA_E, &WDC65816_opcode_EB_E, &WDC65816_opcode_EC_E, &WDC65816_opcode_ED_E, &WDC65816_opcode_EE_E, &WDC65816_opcode_EF_E, 
    &WDC65816_opcode_F0_E, &WDC65816_opcode_F1_E, &WDC65816_opcode_F2_E, &WDC65816_opcode_F3_E, &WDC65816_opcode_F4_E, &WDC65816_opcode_F5_E, &WDC65816_opcode_F6_E, &WDC65816_opcode_F7_E, 
    &WDC65816_opcode_F8_E, &WDC65816_opcode_F9_E, &WDC65816_opcode_FA_E, &WDC65816_opcode_FB_E, &WDC65816_opcode_FC_E, &WDC65816_opcode_FD_E, &WDC65816_opcode_FE_E, &WDC65816_opcode_FF_E, 
    &WDC65816_opcode_100_E, &WDC65816_opcode_101_E, &WDC65816_opcode_102_E, &WDC65816_opcode_103_E, }
};