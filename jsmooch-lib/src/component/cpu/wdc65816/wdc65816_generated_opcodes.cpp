
// Auto-generated by wdc65816_core_generator.js decode_opcodes_c()
#include "wdc65816.h"


namespace WDC65816 {


static void opcode_00_mx(regs &regs, pins &pins) { // BRK s
        switch(regs.TCU) {
        // BRK s E=0 M=0 X=0
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE6); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE7); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_01_mx(regs &regs, pins &pins) { // ORA (d,x)
        switch(regs.TCU) {
        // ORA (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_02_mx(regs &regs, pins &pins) { // COP s
        switch(regs.TCU) {
        // COP s E=0 M=0 X=0
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE4); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE5); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_03_mx(regs &regs, pins &pins) { // ORA d,s
        switch(regs.TCU) {
        // ORA d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_04_mx(regs &regs, pins &pins) { // TSB d
        switch(regs.TCU) {
        // TSB d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_05_mx(regs &regs, pins &pins) { // ORA d
        switch(regs.TCU) {
        // ORA d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_06_mx(regs &regs, pins &pins) { // ASL d
        switch(regs.TCU) {
        // ASL d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_07_mx(regs &regs, pins &pins) { // ORA [d]
        switch(regs.TCU) {
        // ORA [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_08_mx(regs &regs, pins &pins) { // PHP s
        switch(regs.TCU) {
        // PHP s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.P.v;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_09_mx(regs &regs, pins &pins) { // ORA #
        switch(regs.TCU) {
        // ORA # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0A_mx(regs &regs, pins &pins) { // ASL A
        switch(regs.TCU) {
        // ASL A E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0B_mx(regs &regs, pins &pins) { // PHD s
        switch(regs.TCU) {
        // PHD s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.D);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0C_mx(regs &regs, pins &pins) { // TSB a
        switch(regs.TCU) {
        // TSB a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0D_mx(regs &regs, pins &pins) { // ORA a
        switch(regs.TCU) {
        // ORA a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0E_mx(regs &regs, pins &pins) { // ASL a
        switch(regs.TCU) {
        // ASL a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0F_mx(regs &regs, pins &pins) { // ORA al
        switch(regs.TCU) {
        // ORA al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_10_mx(regs &regs, pins &pins) { // BPL r
        switch(regs.TCU) {
        // BPL r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_11_mx(regs &regs, pins &pins) { // ORA (d),y
        switch(regs.TCU) {
        // ORA (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_12_mx(regs &regs, pins &pins) { // ORA (d)
        switch(regs.TCU) {
        // ORA (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_13_mx(regs &regs, pins &pins) { // ORA (d,s),y
        switch(regs.TCU) {
        // ORA (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_14_mx(regs &regs, pins &pins) { // TRB d
        switch(regs.TCU) {
        // TRB d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_15_mx(regs &regs, pins &pins) { // ORA d,x
        switch(regs.TCU) {
        // ORA d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_16_mx(regs &regs, pins &pins) { // ASL d,x
        switch(regs.TCU) {
        // ASL d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_17_mx(regs &regs, pins &pins) { // ORA [d],y
        switch(regs.TCU) {
        // ORA [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_18_mx(regs &regs, pins &pins) { // CLC i
        switch(regs.TCU) {
        // CLC i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_19_mx(regs &regs, pins &pins) { // ORA a,y
        switch(regs.TCU) {
        // ORA a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1A_mx(regs &regs, pins &pins) { // INC A
        switch(regs.TCU) {
        // INC A E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1B_mx(regs &regs, pins &pins) { // TCS i
        switch(regs.TCU) {
        // TCS i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.C;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1C_mx(regs &regs, pins &pins) { // TRB a
        switch(regs.TCU) {
        // TRB a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1D_mx(regs &regs, pins &pins) { // ORA a,x
        switch(regs.TCU) {
        // ORA a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1E_mx(regs &regs, pins &pins) { // ASL a,x
        switch(regs.TCU) {
        // ASL a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1F_mx(regs &regs, pins &pins) { // ORA al,x
        switch(regs.TCU) {
        // ORA al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_20_mx(regs &regs, pins &pins) { // JSR a
        switch(regs.TCU) {
        // JSR a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.PDV = 0;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 6
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_21_mx(regs &regs, pins &pins) { // AND (d,x)
        switch(regs.TCU) {
        // AND (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_22_mx(regs &regs, pins &pins) { // JSL al
        switch(regs.TCU) {
        // JSL al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        regs.TA += pins.D << 8;
        pins.D = (regs.PBR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 5: {// 6
        pins.PDV = 1;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 6: {// 7
        regs.PBR = pins.D;
        pins.RW = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 7: {// 8
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_23_mx(regs &regs, pins &pins) { // AND d,s
        switch(regs.TCU) {
        // AND d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_24_mx(regs &regs, pins &pins) { // BIT d
        switch(regs.TCU) {
        // BIT d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_25_mx(regs &regs, pins &pins) { // AND d
        switch(regs.TCU) {
        // AND d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_26_mx(regs &regs, pins &pins) { // ROL d
        switch(regs.TCU) {
        // ROL d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_27_mx(regs &regs, pins &pins) { // AND [d]
        switch(regs.TCU) {
        // AND [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_28_mx(regs &regs, pins &pins) { // PLP s
        switch(regs.TCU) {
        // PLP s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.v = regs.TR;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_29_mx(regs &regs, pins &pins) { // AND #
        switch(regs.TCU) {
        // AND # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2A_mx(regs &regs, pins &pins) { // ROL A
        switch(regs.TCU) {
        // ROL A E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2B_mx(regs &regs, pins &pins) { // PLD s
        switch(regs.TCU) {
        // PLD s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.D = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2C_mx(regs &regs, pins &pins) { // BIT a
        switch(regs.TCU) {
        // BIT a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2D_mx(regs &regs, pins &pins) { // AND a
        switch(regs.TCU) {
        // AND a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2E_mx(regs &regs, pins &pins) { // ROL a
        switch(regs.TCU) {
        // ROL a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2F_mx(regs &regs, pins &pins) { // AND al
        switch(regs.TCU) {
        // AND al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_30_mx(regs &regs, pins &pins) { // BMI r
        switch(regs.TCU) {
        // BMI r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_31_mx(regs &regs, pins &pins) { // AND (d),y
        switch(regs.TCU) {
        // AND (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_32_mx(regs &regs, pins &pins) { // AND (d)
        switch(regs.TCU) {
        // AND (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_33_mx(regs &regs, pins &pins) { // AND (d,s),y
        switch(regs.TCU) {
        // AND (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_34_mx(regs &regs, pins &pins) { // BIT d,x
        switch(regs.TCU) {
        // BIT d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_35_mx(regs &regs, pins &pins) { // AND d,x
        switch(regs.TCU) {
        // AND d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_36_mx(regs &regs, pins &pins) { // ROL d,x
        switch(regs.TCU) {
        // ROL d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_37_mx(regs &regs, pins &pins) { // AND [d],y
        switch(regs.TCU) {
        // AND [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_38_mx(regs &regs, pins &pins) { // SEC i
        switch(regs.TCU) {
        // SEC i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_39_mx(regs &regs, pins &pins) { // AND a,y
        switch(regs.TCU) {
        // AND a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3A_mx(regs &regs, pins &pins) { // DEC A
        switch(regs.TCU) {
        // DEC A E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3B_mx(regs &regs, pins &pins) { // TSC i
        switch(regs.TCU) {
        // TSC i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.S);
        regs.P.Z = +((regs.S) == 0);
        regs.P.N = ((regs.S) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3C_mx(regs &regs, pins &pins) { // BIT a,x
        switch(regs.TCU) {
        // BIT a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3D_mx(regs &regs, pins &pins) { // AND a,x
        switch(regs.TCU) {
        // AND a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3E_mx(regs &regs, pins &pins) { // ROL a,x
        switch(regs.TCU) {
        // ROL a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3F_mx(regs &regs, pins &pins) { // AND al,x
        switch(regs.TCU) {
        // AND al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_40_mx(regs &regs, pins &pins) { // RTI s
        switch(regs.TCU) {
        // RTI s E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        pins.PDV = 1;
                break; }
            case 4: {// 5
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.P.v = pins.D;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x100;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA = pins.D;
                break; }
            case 6: {// 7
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA += pins.D << 8;
                break; }
            case 7: {// cleanup_custom
        regs.PC = regs.TA;
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_41_mx(regs &regs, pins &pins) { // EOR (d,x)
        switch(regs.TCU) {
        // EOR (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_42_mx(regs &regs, pins &pins) { // WDM i
        switch(regs.TCU) {
        // WDM i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_43_mx(regs &regs, pins &pins) { // EOR d,s
        switch(regs.TCU) {
        // EOR d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_44_mx(regs &regs, pins &pins) { // MVP xyc
        switch(regs.TCU) {
        // MVP xyc E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = (regs.X); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
                break; }
            case 7: {// cleanup_custom
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X - 1) & 0xFFFF;
        regs.Y = (regs.Y - 1) & 0xFFFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_45_mx(regs &regs, pins &pins) { // EOR d
        switch(regs.TCU) {
        // EOR d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_46_mx(regs &regs, pins &pins) { // LSR d
        switch(regs.TCU) {
        // LSR d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_47_mx(regs &regs, pins &pins) { // EOR [d]
        switch(regs.TCU) {
        // EOR [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_48_mx(regs &regs, pins &pins) { // PHA s
        switch(regs.TCU) {
        // PHA s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.C);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_49_mx(regs &regs, pins &pins) { // EOR #
        switch(regs.TCU) {
        // EOR # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4A_mx(regs &regs, pins &pins) { // LSR A
        switch(regs.TCU) {
        // LSR A E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4B_mx(regs &regs, pins &pins) { // PHK s
        switch(regs.TCU) {
        // PHK s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.PBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4C_mx(regs &regs, pins &pins) { // JMP a
        switch(regs.TCU) {
        // JMP a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4D_mx(regs &regs, pins &pins) { // EOR a
        switch(regs.TCU) {
        // EOR a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4E_mx(regs &regs, pins &pins) { // LSR a
        switch(regs.TCU) {
        // LSR a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4F_mx(regs &regs, pins &pins) { // EOR al
        switch(regs.TCU) {
        // EOR al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_50_mx(regs &regs, pins &pins) { // BVC r
        switch(regs.TCU) {
        // BVC r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_51_mx(regs &regs, pins &pins) { // EOR (d),y
        switch(regs.TCU) {
        // EOR (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_52_mx(regs &regs, pins &pins) { // EOR (d)
        switch(regs.TCU) {
        // EOR (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_53_mx(regs &regs, pins &pins) { // EOR (d,s),y
        switch(regs.TCU) {
        // EOR (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_54_mx(regs &regs, pins &pins) { // MVN xyc
        switch(regs.TCU) {
        // MVN xyc E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X + 1) & 0xFFFF;
        regs.Y = (regs.Y + 1) & 0xFFFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_55_mx(regs &regs, pins &pins) { // EOR d,x
        switch(regs.TCU) {
        // EOR d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_56_mx(regs &regs, pins &pins) { // LSR d,x
        switch(regs.TCU) {
        // LSR d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_57_mx(regs &regs, pins &pins) { // EOR [d],y
        switch(regs.TCU) {
        // EOR [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_58_mx(regs &regs, pins &pins) { // CLI i
        switch(regs.TCU) {
        // CLI i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_59_mx(regs &regs, pins &pins) { // EOR a,y
        switch(regs.TCU) {
        // EOR a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5A_mx(regs &regs, pins &pins) { // PHY s
        switch(regs.TCU) {
        // PHY s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.Y);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5B_mx(regs &regs, pins &pins) { // TCD i
        switch(regs.TCU) {
        // TCD i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.D = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5C_mx(regs &regs, pins &pins) { // JMP al
        switch(regs.TCU) {
        // JMP al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = regs.TA + (pins.D << 8);
                break; }
            case 4: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5D_mx(regs &regs, pins &pins) { // EOR a,x
        switch(regs.TCU) {
        // EOR a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5E_mx(regs &regs, pins &pins) { // LSR a,x
        switch(regs.TCU) {
        // LSR a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5F_mx(regs &regs, pins &pins) { // EOR al,x
        switch(regs.TCU) {
        // EOR al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_60_mx(regs &regs, pins &pins) { // RTS s
        switch(regs.TCU) {
        // RTS s E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_61_mx(regs &regs, pins &pins) { // ADC (d,x)
        switch(regs.TCU) {
        // ADC (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_62_mx(regs &regs, pins &pins) { // PER s
        switch(regs.TCU) {
        // PER s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
                break; }
            case 6: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_63_mx(regs &regs, pins &pins) { // ADC d,s
        switch(regs.TCU) {
        // ADC d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_64_mx(regs &regs, pins &pins) { // STZ d
        switch(regs.TCU) {
        // STZ d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_65_mx(regs &regs, pins &pins) { // ADC d
        switch(regs.TCU) {
        // ADC d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_66_mx(regs &regs, pins &pins) { // ROR d
        switch(regs.TCU) {
        // ROR d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_67_mx(regs &regs, pins &pins) { // ADC [d]
        switch(regs.TCU) {
        // ADC [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_68_mx(regs &regs, pins &pins) { // PLA s
        switch(regs.TCU) {
        // PLA s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.C = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_69_mx(regs &regs, pins &pins) { // ADC #
        switch(regs.TCU) {
        // ADC # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6A_mx(regs &regs, pins &pins) { // ROR A
        switch(regs.TCU) {
        // ROR A E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6B_mx(regs &regs, pins &pins) { // RTL s
        switch(regs.TCU) {
        // RTL s E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6C_mx(regs &regs, pins &pins) { // JMP (a)
        switch(regs.TCU) {
        // JMP (a) E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6D_mx(regs &regs, pins &pins) { // ADC a
        switch(regs.TCU) {
        // ADC a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6E_mx(regs &regs, pins &pins) { // ROR a
        switch(regs.TCU) {
        // ROR a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6F_mx(regs &regs, pins &pins) { // ADC al
        switch(regs.TCU) {
        // ADC al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_70_mx(regs &regs, pins &pins) { // BVS r
        switch(regs.TCU) {
        // BVS r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_71_mx(regs &regs, pins &pins) { // ADC (d),y
        switch(regs.TCU) {
        // ADC (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_72_mx(regs &regs, pins &pins) { // ADC (d)
        switch(regs.TCU) {
        // ADC (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_73_mx(regs &regs, pins &pins) { // ADC (d,s),y
        switch(regs.TCU) {
        // ADC (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_74_mx(regs &regs, pins &pins) { // STZ d,x
        switch(regs.TCU) {
        // STZ d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_75_mx(regs &regs, pins &pins) { // ADC d,x
        switch(regs.TCU) {
        // ADC d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_76_mx(regs &regs, pins &pins) { // ROR d,x
        switch(regs.TCU) {
        // ROR d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_77_mx(regs &regs, pins &pins) { // ADC [d],y
        switch(regs.TCU) {
        // ADC [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_78_mx(regs &regs, pins &pins) { // SEI i
        switch(regs.TCU) {
        // SEI i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_79_mx(regs &regs, pins &pins) { // ADC a,y
        switch(regs.TCU) {
        // ADC a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7A_mx(regs &regs, pins &pins) { // PLY s
        switch(regs.TCU) {
        // PLY s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7B_mx(regs &regs, pins &pins) { // TDC i
        switch(regs.TCU) {
        // TDC i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.D);
        regs.P.Z = +((regs.D) == 0);
        regs.P.N = ((regs.D) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7C_mx(regs &regs, pins &pins) { // JMP (a,x)
        switch(regs.TCU) {
        // JMP (a,x) E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        regs.TA = (regs.X + regs.TA) & 0xFFFF;
        pins.PDV = 0;
                break; }
            case 4:{
        pins.PDV = 1;
        pins.Addr = regs.TA; pins.BA = regs.PBR;
                break; }
            case 5:{
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7D_mx(regs &regs, pins &pins) { // ADC a,x
        switch(regs.TCU) {
        // ADC a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7E_mx(regs &regs, pins &pins) { // ROR a,x
        switch(regs.TCU) {
        // ROR a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7F_mx(regs &regs, pins &pins) { // ADC al,x
        switch(regs.TCU) {
        // ADC al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_80_mx(regs &regs, pins &pins) { // BRA r
        switch(regs.TCU) {
        // BRA r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_81_mx(regs &regs, pins &pins) { // STA (d,x)
        switch(regs.TCU) {
        // STA (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_82_mx(regs &regs, pins &pins) { // BRL rl
        switch(regs.TCU) {
        // BRL rl E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TA = (u32)(i16)(regs.TA + (pins.D << 8));
        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_83_mx(regs &regs, pins &pins) { // STA d,s
        switch(regs.TCU) {
        // STA d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_84_mx(regs &regs, pins &pins) { // STY d
        switch(regs.TCU) {
        // STY d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_85_mx(regs &regs, pins &pins) { // STA d
        switch(regs.TCU) {
        // STA d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_86_mx(regs &regs, pins &pins) { // STX d
        switch(regs.TCU) {
        // STX d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_87_mx(regs &regs, pins &pins) { // STA [d]
        switch(regs.TCU) {
        // STA [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_88_mx(regs &regs, pins &pins) { // DEY i
        switch(regs.TCU) {
        // DEY i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) - 1) & 0xFFFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_89_mx(regs &regs, pins &pins) { // BIT #
        switch(regs.TCU) {
        // BIT # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8A_mx(regs &regs, pins &pins) { // TXA i
        switch(regs.TCU) {
        // TXA i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.X);
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8B_mx(regs &regs, pins &pins) { // PHB s
        switch(regs.TCU) {
        // PHB s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.DBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8C_mx(regs &regs, pins &pins) { // STY a
        switch(regs.TCU) {
        // STY a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.Y;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8D_mx(regs &regs, pins &pins) { // STA a
        switch(regs.TCU) {
        // STA a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8E_mx(regs &regs, pins &pins) { // STX a
        switch(regs.TCU) {
        // STX a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.X;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8F_mx(regs &regs, pins &pins) { // STA al
        switch(regs.TCU) {
        // STA al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 5a
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_90_mx(regs &regs, pins &pins) { // BCC r
        switch(regs.TCU) {
        // BCC r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_91_mx(regs &regs, pins &pins) { // STA (d),y
        switch(regs.TCU) {
        // STA (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_92_mx(regs &regs, pins &pins) { // STA (d)
        switch(regs.TCU) {
        // STA (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 6: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_93_mx(regs &regs, pins &pins) { // STA (d,s),y
        switch(regs.TCU) {
        // STA (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_94_mx(regs &regs, pins &pins) { // STY d,x
        switch(regs.TCU) {
        // STY d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_95_mx(regs &regs, pins &pins) { // STA d,x
        switch(regs.TCU) {
        // STA d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_96_mx(regs &regs, pins &pins) { // STX d,y
        switch(regs.TCU) {
        // STX d,y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_97_mx(regs &regs, pins &pins) { // STA [d],y
        switch(regs.TCU) {
        // STA [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_98_mx(regs &regs, pins &pins) { // TYA i
        switch(regs.TCU) {
        // TYA i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.Y);
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_99_mx(regs &regs, pins &pins) { // STA a,y
        switch(regs.TCU) {
        // STA a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9A_mx(regs &regs, pins &pins) { // TXS i
        switch(regs.TCU) {
        // TXS i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.X;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9B_mx(regs &regs, pins &pins) { // TXY i
        switch(regs.TCU) {
        // TXY i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = (regs.X);
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9C_mx(regs &regs, pins &pins) { // STZ a
        switch(regs.TCU) {
        // STZ a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9D_mx(regs &regs, pins &pins) { // STA a,x
        switch(regs.TCU) {
        // STA a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9E_mx(regs &regs, pins &pins) { // STZ a,x
        switch(regs.TCU) {
        // STZ a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9F_mx(regs &regs, pins &pins) { // STA al,x
        switch(regs.TCU) {
        // STA al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A0_mx(regs &regs, pins &pins) { // LDY #
        switch(regs.TCU) {
        // LDY # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A1_mx(regs &regs, pins &pins) { // LDA (d,x)
        switch(regs.TCU) {
        // LDA (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A2_mx(regs &regs, pins &pins) { // LDX #
        switch(regs.TCU) {
        // LDX # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A3_mx(regs &regs, pins &pins) { // LDA d,s
        switch(regs.TCU) {
        // LDA d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A4_mx(regs &regs, pins &pins) { // LDY d
        switch(regs.TCU) {
        // LDY d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A5_mx(regs &regs, pins &pins) { // LDA d
        switch(regs.TCU) {
        // LDA d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A6_mx(regs &regs, pins &pins) { // LDX d
        switch(regs.TCU) {
        // LDX d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A7_mx(regs &regs, pins &pins) { // LDA [d]
        switch(regs.TCU) {
        // LDA [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A8_mx(regs &regs, pins &pins) { // TAY i
        switch(regs.TCU) {
        // TAY i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A9_mx(regs &regs, pins &pins) { // LDA #
        switch(regs.TCU) {
        // LDA # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AA_mx(regs &regs, pins &pins) { // TAX i
        switch(regs.TCU) {
        // TAX i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AB_mx(regs &regs, pins &pins) { // PLB s
        switch(regs.TCU) {
        // PLB s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AC_mx(regs &regs, pins &pins) { // LDY a
        switch(regs.TCU) {
        // LDY a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AD_mx(regs &regs, pins &pins) { // LDA a
        switch(regs.TCU) {
        // LDA a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AE_mx(regs &regs, pins &pins) { // LDX a
        switch(regs.TCU) {
        // LDX a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AF_mx(regs &regs, pins &pins) { // LDA al
        switch(regs.TCU) {
        // LDA al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B0_mx(regs &regs, pins &pins) { // BCS r
        switch(regs.TCU) {
        // BCS r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B1_mx(regs &regs, pins &pins) { // LDA (d),y
        switch(regs.TCU) {
        // LDA (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B2_mx(regs &regs, pins &pins) { // LDA (d)
        switch(regs.TCU) {
        // LDA (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B3_mx(regs &regs, pins &pins) { // LDA (d,s),y
        switch(regs.TCU) {
        // LDA (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B4_mx(regs &regs, pins &pins) { // LDY d,x
        switch(regs.TCU) {
        // LDY d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B5_mx(regs &regs, pins &pins) { // LDA d,x
        switch(regs.TCU) {
        // LDA d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B6_mx(regs &regs, pins &pins) { // LDX d,y
        switch(regs.TCU) {
        // LDX d,y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B7_mx(regs &regs, pins &pins) { // LDA [d],y
        switch(regs.TCU) {
        // LDA [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B8_mx(regs &regs, pins &pins) { // CLV i
        switch(regs.TCU) {
        // CLV i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.V = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B9_mx(regs &regs, pins &pins) { // LDA a,y
        switch(regs.TCU) {
        // LDA a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BA_mx(regs &regs, pins &pins) { // TSX i
        switch(regs.TCU) {
        // TSX i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = (regs.S);
        regs.P.Z = +((regs.S) == 0);
        regs.P.N = ((regs.S) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BB_mx(regs &regs, pins &pins) { // TYX i
        switch(regs.TCU) {
        // TYX i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = (regs.Y);
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BC_mx(regs &regs, pins &pins) { // LDY a,x
        switch(regs.TCU) {
        // LDY a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BD_mx(regs &regs, pins &pins) { // LDA a,x
        switch(regs.TCU) {
        // LDA a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BE_mx(regs &regs, pins &pins) { // LDX a,y
        switch(regs.TCU) {
        // LDX a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BF_mx(regs &regs, pins &pins) { // LDA al,x
        switch(regs.TCU) {
        // LDA al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C0_mx(regs &regs, pins &pins) { // CPY #
        switch(regs.TCU) {
        // CPY # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.Y) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C1_mx(regs &regs, pins &pins) { // CMP (d,x)
        switch(regs.TCU) {
        // CMP (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C2_mx(regs &regs, pins &pins) { // REP #
        switch(regs.TCU) {
        // REP # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v &= (~regs.TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C3_mx(regs &regs, pins &pins) { // CMP d,s
        switch(regs.TCU) {
        // CMP d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C4_mx(regs &regs, pins &pins) { // CPY d
        switch(regs.TCU) {
        // CPY d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.Y) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C5_mx(regs &regs, pins &pins) { // CMP d
        switch(regs.TCU) {
        // CMP d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C6_mx(regs &regs, pins &pins) { // DEC d
        switch(regs.TCU) {
        // DEC d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C7_mx(regs &regs, pins &pins) { // CMP [d]
        switch(regs.TCU) {
        // CMP [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C8_mx(regs &regs, pins &pins) { // INY i
        switch(regs.TCU) {
        // INY i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) + 1) & 0xFFFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C9_mx(regs &regs, pins &pins) { // CMP #
        switch(regs.TCU) {
        // CMP # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CA_mx(regs &regs, pins &pins) { // DEX i
        switch(regs.TCU) {
        // DEX i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) - 1) & 0xFFFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CB_mx(regs &regs, pins &pins) { // WAI i
        switch(regs.TCU) {
        // WAI i E=0 M=0 X=0
            case 1: {// 1
        regs.WAI = 1;
                break; }
            case 2: {// 2
        if (regs.WAI) {
            regs.TCU--;
            break;
        }
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 3: {// 3
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CC_mx(regs &regs, pins &pins) { // CPY a
        switch(regs.TCU) {
        // CPY a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.Y) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CD_mx(regs &regs, pins &pins) { // CMP a
        switch(regs.TCU) {
        // CMP a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CE_mx(regs &regs, pins &pins) { // DEC a
        switch(regs.TCU) {
        // DEC a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CF_mx(regs &regs, pins &pins) { // CMP al
        switch(regs.TCU) {
        // CMP al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D0_mx(regs &regs, pins &pins) { // BNE r
        switch(regs.TCU) {
        // BNE r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D1_mx(regs &regs, pins &pins) { // CMP (d),y
        switch(regs.TCU) {
        // CMP (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D2_mx(regs &regs, pins &pins) { // CMP (d)
        switch(regs.TCU) {
        // CMP (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D3_mx(regs &regs, pins &pins) { // CMP (d,s),y
        switch(regs.TCU) {
        // CMP (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D4_mx(regs &regs, pins &pins) { // PEI s
        switch(regs.TCU) {
        // PEI s E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.D = regs.TR;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 7: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D5_mx(regs &regs, pins &pins) { // CMP d,x
        switch(regs.TCU) {
        // CMP d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D6_mx(regs &regs, pins &pins) { // DEC d,x
        switch(regs.TCU) {
        // DEC d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D7_mx(regs &regs, pins &pins) { // CMP [d],y
        switch(regs.TCU) {
        // CMP [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D8_mx(regs &regs, pins &pins) { // CLD i
        switch(regs.TCU) {
        // CLD i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D9_mx(regs &regs, pins &pins) { // CMP a,y
        switch(regs.TCU) {
        // CMP a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DA_mx(regs &regs, pins &pins) { // PHX s
        switch(regs.TCU) {
        // PHX s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.X);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DB_mx(regs &regs, pins &pins) { // STP i
        switch(regs.TCU) {
        // STP i E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// cleanup_custom
        regs.STP = 1;
        // Following is auto-generated code for instruction finish
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DC_mx(regs &regs, pins &pins) { // JML (a)
        switch(regs.TCU) {
        // JML (a) E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.PC = regs.TR + (pins.D << 8);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DD_mx(regs &regs, pins &pins) { // CMP a,x
        switch(regs.TCU) {
        // CMP a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DE_mx(regs &regs, pins &pins) { // DEC a,x
        switch(regs.TCU) {
        // DEC a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DF_mx(regs &regs, pins &pins) { // CMP al,x
        switch(regs.TCU) {
        // CMP al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E0_mx(regs &regs, pins &pins) { // CPX #
        switch(regs.TCU) {
        // CPX # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.X) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E1_mx(regs &regs, pins &pins) { // SBC (d,x)
        switch(regs.TCU) {
        // SBC (d,x) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E2_mx(regs &regs, pins &pins) { // SEP #
        switch(regs.TCU) {
        // SEP # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v |= regs.TR;
        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E3_mx(regs &regs, pins &pins) { // SBC d,s
        switch(regs.TCU) {
        // SBC d,s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E4_mx(regs &regs, pins &pins) { // CPX d
        switch(regs.TCU) {
        // CPX d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.X) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E5_mx(regs &regs, pins &pins) { // SBC d
        switch(regs.TCU) {
        // SBC d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E6_mx(regs &regs, pins &pins) { // INC d
        switch(regs.TCU) {
        // INC d E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E7_mx(regs &regs, pins &pins) { // SBC [d]
        switch(regs.TCU) {
        // SBC [d] E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E8_mx(regs &regs, pins &pins) { // INX i
        switch(regs.TCU) {
        // INX i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) + 1) & 0xFFFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E9_mx(regs &regs, pins &pins) { // SBC #
        switch(regs.TCU) {
        // SBC # E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EA_mx(regs &regs, pins &pins) { // NOP i
        switch(regs.TCU) {
        // NOP i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EB_mx(regs &regs, pins &pins) { // XBA i
        switch(regs.TCU) {
        // XBA i E=0 M=0 X=0
            case 1:{
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2:{
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >> 8) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EC_mx(regs &regs, pins &pins) { // CPX a
        switch(regs.TCU) {
        // CPX a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.X) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_ED_mx(regs &regs, pins &pins) { // SBC a
        switch(regs.TCU) {
        // SBC a E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EE_mx(regs &regs, pins &pins) { // INC a
        switch(regs.TCU) {
        // INC a E=0 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EF_mx(regs &regs, pins &pins) { // SBC al
        switch(regs.TCU) {
        // SBC al E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F0_mx(regs &regs, pins &pins) { // BEQ r
        switch(regs.TCU) {
        // BEQ r E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F1_mx(regs &regs, pins &pins) { // SBC (d),y
        switch(regs.TCU) {
        // SBC (d),y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F2_mx(regs &regs, pins &pins) { // SBC (d)
        switch(regs.TCU) {
        // SBC (d) E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F3_mx(regs &regs, pins &pins) { // SBC (d,s),y
        switch(regs.TCU) {
        // SBC (d,s),y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F4_mx(regs &regs, pins &pins) { // PEA s
        switch(regs.TCU) {
        // PEA s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR;
                break; }
            case 5: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F5_mx(regs &regs, pins &pins) { // SBC d,x
        switch(regs.TCU) {
        // SBC d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F6_mx(regs &regs, pins &pins) { // INC d,x
        switch(regs.TCU) {
        // INC d,x E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F7_mx(regs &regs, pins &pins) { // SBC [d],y
        switch(regs.TCU) {
        // SBC [d],y E=0 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F8_mx(regs &regs, pins &pins) { // SED i
        switch(regs.TCU) {
        // SED i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F9_mx(regs &regs, pins &pins) { // SBC a,y
        switch(regs.TCU) {
        // SBC a,y E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FA_mx(regs &regs, pins &pins) { // PLX s
        switch(regs.TCU) {
        // PLX s E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FB_mx(regs &regs, pins &pins) { // XCE i
        switch(regs.TCU) {
        // XCE i E=0 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        u32 TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
        if (regs.E) {
            regs.P.X = regs.P.M = 1;
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
            regs.S = (regs.S & 0xFF) | 0x100;
        }
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FC_mx(regs &regs, pins &pins) { // JSR (a,x)
        switch(regs.TCU) {
        // JSR (a,x) E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.RW = 1;
        regs.TA = pins.D;
        pins.D = ((regs.PC) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 4
        pins.D = (regs.PC) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                break; }
            case 6: {// 7
        pins.PDV = 1;
        pins.Addr = regs.TA;
                break; }
            case 7: {// 8
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.PC = pins.D;
                break; }
            case 8: {// cleanup_custom
        regs.PC += (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FD_mx(regs &regs, pins &pins) { // SBC a,x
        switch(regs.TCU) {
        // SBC a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FE_mx(regs &regs, pins &pins) { // INC a,x
        switch(regs.TCU) {
        // INC a,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FF_mx(regs &regs, pins &pins) { // SBC al,x
        switch(regs.TCU) {
        // SBC al,x E=0 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_100_mx(regs &regs, pins &pins) { // S_RESET s
        switch(regs.TCU) {
        // S_RESET s E=0 M=0 X=0
            case 1: {// 3
        pins.RW = 0; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFFC); pins.BA = (0);
        regs.DBR = 0;
        regs.D = 0;
        regs.PBR = 0;
        regs.X &= 0xFF;
        regs.Y &= 0xFF;
        regs.E = 1;
        regs.P.M = regs.P.X = regs.P.I = 1; regs.P.C = 0;
        regs.P.D = 0;
        regs.STP = regs.WAI = 0;
        regs.S = 0x1FF;
                break; }
            case 6: {// 8
        regs.PC = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.PC += (pins.D << 8);
        pins.PDV = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_101_mx(regs &regs, pins &pins) { // S_ABORT s
        switch(regs.TCU) {
        // S_ABORT s E=0 M=0 X=0
            case 1: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFE8); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFE9); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_102_mx(regs &regs, pins &pins) { // S_IRQ s
        switch(regs.TCU) {
        // S_IRQ s E=0 M=0 X=0
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEE); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEF); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_103_mx(regs &regs, pins &pins) { // S_NMI s
        switch(regs.TCU) {
        // S_NMI s E=0 M=0 X=0
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEA); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEB); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_00_Mx(regs &regs, pins &pins) { // BRK s
        switch(regs.TCU) {
        // BRK s E=0 M=1 X=0
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE6); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE7); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_01_Mx(regs &regs, pins &pins) { // ORA (d,x)
        switch(regs.TCU) {
        // ORA (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_02_Mx(regs &regs, pins &pins) { // COP s
        switch(regs.TCU) {
        // COP s E=0 M=1 X=0
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE4); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE5); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_03_Mx(regs &regs, pins &pins) { // ORA d,s
        switch(regs.TCU) {
        // ORA d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_04_Mx(regs &regs, pins &pins) { // TSB d
        switch(regs.TCU) {
        // TSB d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_05_Mx(regs &regs, pins &pins) { // ORA d
        switch(regs.TCU) {
        // ORA d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_06_Mx(regs &regs, pins &pins) { // ASL d
        switch(regs.TCU) {
        // ASL d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_07_Mx(regs &regs, pins &pins) { // ORA [d]
        switch(regs.TCU) {
        // ORA [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_08_Mx(regs &regs, pins &pins) { // PHP s
        switch(regs.TCU) {
        // PHP s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.P.v;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_09_Mx(regs &regs, pins &pins) { // ORA #
        switch(regs.TCU) {
        // ORA # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0A_Mx(regs &regs, pins &pins) { // ASL A
        switch(regs.TCU) {
        // ASL A E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0B_Mx(regs &regs, pins &pins) { // PHD s
        switch(regs.TCU) {
        // PHD s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.D);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0C_Mx(regs &regs, pins &pins) { // TSB a
        switch(regs.TCU) {
        // TSB a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0D_Mx(regs &regs, pins &pins) { // ORA a
        switch(regs.TCU) {
        // ORA a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0E_Mx(regs &regs, pins &pins) { // ASL a
        switch(regs.TCU) {
        // ASL a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0F_Mx(regs &regs, pins &pins) { // ORA al
        switch(regs.TCU) {
        // ORA al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_10_Mx(regs &regs, pins &pins) { // BPL r
        switch(regs.TCU) {
        // BPL r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_11_Mx(regs &regs, pins &pins) { // ORA (d),y
        switch(regs.TCU) {
        // ORA (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_12_Mx(regs &regs, pins &pins) { // ORA (d)
        switch(regs.TCU) {
        // ORA (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_13_Mx(regs &regs, pins &pins) { // ORA (d,s),y
        switch(regs.TCU) {
        // ORA (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_14_Mx(regs &regs, pins &pins) { // TRB d
        switch(regs.TCU) {
        // TRB d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_15_Mx(regs &regs, pins &pins) { // ORA d,x
        switch(regs.TCU) {
        // ORA d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_16_Mx(regs &regs, pins &pins) { // ASL d,x
        switch(regs.TCU) {
        // ASL d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_17_Mx(regs &regs, pins &pins) { // ORA [d],y
        switch(regs.TCU) {
        // ORA [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_18_Mx(regs &regs, pins &pins) { // CLC i
        switch(regs.TCU) {
        // CLC i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_19_Mx(regs &regs, pins &pins) { // ORA a,y
        switch(regs.TCU) {
        // ORA a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1A_Mx(regs &regs, pins &pins) { // INC A
        switch(regs.TCU) {
        // INC A E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1B_Mx(regs &regs, pins &pins) { // TCS i
        switch(regs.TCU) {
        // TCS i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.C;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1C_Mx(regs &regs, pins &pins) { // TRB a
        switch(regs.TCU) {
        // TRB a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1D_Mx(regs &regs, pins &pins) { // ORA a,x
        switch(regs.TCU) {
        // ORA a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1E_Mx(regs &regs, pins &pins) { // ASL a,x
        switch(regs.TCU) {
        // ASL a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1F_Mx(regs &regs, pins &pins) { // ORA al,x
        switch(regs.TCU) {
        // ORA al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_20_Mx(regs &regs, pins &pins) { // JSR a
        switch(regs.TCU) {
        // JSR a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.PDV = 0;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 6
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_21_Mx(regs &regs, pins &pins) { // AND (d,x)
        switch(regs.TCU) {
        // AND (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_22_Mx(regs &regs, pins &pins) { // JSL al
        switch(regs.TCU) {
        // JSL al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        regs.TA += pins.D << 8;
        pins.D = (regs.PBR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 5: {// 6
        pins.PDV = 1;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 6: {// 7
        regs.PBR = pins.D;
        pins.RW = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 7: {// 8
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_23_Mx(regs &regs, pins &pins) { // AND d,s
        switch(regs.TCU) {
        // AND d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_24_Mx(regs &regs, pins &pins) { // BIT d
        switch(regs.TCU) {
        // BIT d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_25_Mx(regs &regs, pins &pins) { // AND d
        switch(regs.TCU) {
        // AND d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_26_Mx(regs &regs, pins &pins) { // ROL d
        switch(regs.TCU) {
        // ROL d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_27_Mx(regs &regs, pins &pins) { // AND [d]
        switch(regs.TCU) {
        // AND [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_28_Mx(regs &regs, pins &pins) { // PLP s
        switch(regs.TCU) {
        // PLP s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.v = regs.TR;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_29_Mx(regs &regs, pins &pins) { // AND #
        switch(regs.TCU) {
        // AND # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2A_Mx(regs &regs, pins &pins) { // ROL A
        switch(regs.TCU) {
        // ROL A E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2B_Mx(regs &regs, pins &pins) { // PLD s
        switch(regs.TCU) {
        // PLD s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.D = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2C_Mx(regs &regs, pins &pins) { // BIT a
        switch(regs.TCU) {
        // BIT a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2D_Mx(regs &regs, pins &pins) { // AND a
        switch(regs.TCU) {
        // AND a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2E_Mx(regs &regs, pins &pins) { // ROL a
        switch(regs.TCU) {
        // ROL a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2F_Mx(regs &regs, pins &pins) { // AND al
        switch(regs.TCU) {
        // AND al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_30_Mx(regs &regs, pins &pins) { // BMI r
        switch(regs.TCU) {
        // BMI r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_31_Mx(regs &regs, pins &pins) { // AND (d),y
        switch(regs.TCU) {
        // AND (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_32_Mx(regs &regs, pins &pins) { // AND (d)
        switch(regs.TCU) {
        // AND (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_33_Mx(regs &regs, pins &pins) { // AND (d,s),y
        switch(regs.TCU) {
        // AND (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_34_Mx(regs &regs, pins &pins) { // BIT d,x
        switch(regs.TCU) {
        // BIT d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_35_Mx(regs &regs, pins &pins) { // AND d,x
        switch(regs.TCU) {
        // AND d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_36_Mx(regs &regs, pins &pins) { // ROL d,x
        switch(regs.TCU) {
        // ROL d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_37_Mx(regs &regs, pins &pins) { // AND [d],y
        switch(regs.TCU) {
        // AND [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_38_Mx(regs &regs, pins &pins) { // SEC i
        switch(regs.TCU) {
        // SEC i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_39_Mx(regs &regs, pins &pins) { // AND a,y
        switch(regs.TCU) {
        // AND a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3A_Mx(regs &regs, pins &pins) { // DEC A
        switch(regs.TCU) {
        // DEC A E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3B_Mx(regs &regs, pins &pins) { // TSC i
        switch(regs.TCU) {
        // TSC i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.S);
        regs.P.Z = +((regs.S) == 0);
        regs.P.N = ((regs.S) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3C_Mx(regs &regs, pins &pins) { // BIT a,x
        switch(regs.TCU) {
        // BIT a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3D_Mx(regs &regs, pins &pins) { // AND a,x
        switch(regs.TCU) {
        // AND a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3E_Mx(regs &regs, pins &pins) { // ROL a,x
        switch(regs.TCU) {
        // ROL a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3F_Mx(regs &regs, pins &pins) { // AND al,x
        switch(regs.TCU) {
        // AND al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_40_Mx(regs &regs, pins &pins) { // RTI s
        switch(regs.TCU) {
        // RTI s E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        pins.PDV = 1;
                break; }
            case 4: {// 5
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.P.v = pins.D;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x100;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA = pins.D;
                break; }
            case 6: {// 7
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA += pins.D << 8;
                break; }
            case 7: {// cleanup_custom
        regs.PC = regs.TA;
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_41_Mx(regs &regs, pins &pins) { // EOR (d,x)
        switch(regs.TCU) {
        // EOR (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_42_Mx(regs &regs, pins &pins) { // WDM i
        switch(regs.TCU) {
        // WDM i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_43_Mx(regs &regs, pins &pins) { // EOR d,s
        switch(regs.TCU) {
        // EOR d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_44_Mx(regs &regs, pins &pins) { // MVP xyc
        switch(regs.TCU) {
        // MVP xyc E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = (regs.X); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
                break; }
            case 7: {// cleanup_custom
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X - 1) & 0xFFFF;
        regs.Y = (regs.Y - 1) & 0xFFFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_45_Mx(regs &regs, pins &pins) { // EOR d
        switch(regs.TCU) {
        // EOR d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_46_Mx(regs &regs, pins &pins) { // LSR d
        switch(regs.TCU) {
        // LSR d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_47_Mx(regs &regs, pins &pins) { // EOR [d]
        switch(regs.TCU) {
        // EOR [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_48_Mx(regs &regs, pins &pins) { // PHA s
        switch(regs.TCU) {
        // PHA s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.C) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_49_Mx(regs &regs, pins &pins) { // EOR #
        switch(regs.TCU) {
        // EOR # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4A_Mx(regs &regs, pins &pins) { // LSR A
        switch(regs.TCU) {
        // LSR A E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4B_Mx(regs &regs, pins &pins) { // PHK s
        switch(regs.TCU) {
        // PHK s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.PBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4C_Mx(regs &regs, pins &pins) { // JMP a
        switch(regs.TCU) {
        // JMP a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4D_Mx(regs &regs, pins &pins) { // EOR a
        switch(regs.TCU) {
        // EOR a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4E_Mx(regs &regs, pins &pins) { // LSR a
        switch(regs.TCU) {
        // LSR a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4F_Mx(regs &regs, pins &pins) { // EOR al
        switch(regs.TCU) {
        // EOR al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_50_Mx(regs &regs, pins &pins) { // BVC r
        switch(regs.TCU) {
        // BVC r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_51_Mx(regs &regs, pins &pins) { // EOR (d),y
        switch(regs.TCU) {
        // EOR (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_52_Mx(regs &regs, pins &pins) { // EOR (d)
        switch(regs.TCU) {
        // EOR (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_53_Mx(regs &regs, pins &pins) { // EOR (d,s),y
        switch(regs.TCU) {
        // EOR (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_54_Mx(regs &regs, pins &pins) { // MVN xyc
        switch(regs.TCU) {
        // MVN xyc E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X + 1) & 0xFFFF;
        regs.Y = (regs.Y + 1) & 0xFFFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_55_Mx(regs &regs, pins &pins) { // EOR d,x
        switch(regs.TCU) {
        // EOR d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_56_Mx(regs &regs, pins &pins) { // LSR d,x
        switch(regs.TCU) {
        // LSR d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_57_Mx(regs &regs, pins &pins) { // EOR [d],y
        switch(regs.TCU) {
        // EOR [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_58_Mx(regs &regs, pins &pins) { // CLI i
        switch(regs.TCU) {
        // CLI i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_59_Mx(regs &regs, pins &pins) { // EOR a,y
        switch(regs.TCU) {
        // EOR a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5A_Mx(regs &regs, pins &pins) { // PHY s
        switch(regs.TCU) {
        // PHY s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.Y);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5B_Mx(regs &regs, pins &pins) { // TCD i
        switch(regs.TCU) {
        // TCD i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.D = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5C_Mx(regs &regs, pins &pins) { // JMP al
        switch(regs.TCU) {
        // JMP al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = regs.TA + (pins.D << 8);
                break; }
            case 4: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5D_Mx(regs &regs, pins &pins) { // EOR a,x
        switch(regs.TCU) {
        // EOR a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5E_Mx(regs &regs, pins &pins) { // LSR a,x
        switch(regs.TCU) {
        // LSR a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5F_Mx(regs &regs, pins &pins) { // EOR al,x
        switch(regs.TCU) {
        // EOR al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_60_Mx(regs &regs, pins &pins) { // RTS s
        switch(regs.TCU) {
        // RTS s E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_61_Mx(regs &regs, pins &pins) { // ADC (d,x)
        switch(regs.TCU) {
        // ADC (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_62_Mx(regs &regs, pins &pins) { // PER s
        switch(regs.TCU) {
        // PER s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
                break; }
            case 6: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_63_Mx(regs &regs, pins &pins) { // ADC d,s
        switch(regs.TCU) {
        // ADC d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_64_Mx(regs &regs, pins &pins) { // STZ d
        switch(regs.TCU) {
        // STZ d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_65_Mx(regs &regs, pins &pins) { // ADC d
        switch(regs.TCU) {
        // ADC d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_66_Mx(regs &regs, pins &pins) { // ROR d
        switch(regs.TCU) {
        // ROR d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_67_Mx(regs &regs, pins &pins) { // ADC [d]
        switch(regs.TCU) {
        // ADC [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_68_Mx(regs &regs, pins &pins) { // PLA s
        switch(regs.TCU) {
        // PLA s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_69_Mx(regs &regs, pins &pins) { // ADC #
        switch(regs.TCU) {
        // ADC # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6A_Mx(regs &regs, pins &pins) { // ROR A
        switch(regs.TCU) {
        // ROR A E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6B_Mx(regs &regs, pins &pins) { // RTL s
        switch(regs.TCU) {
        // RTL s E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6C_Mx(regs &regs, pins &pins) { // JMP (a)
        switch(regs.TCU) {
        // JMP (a) E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6D_Mx(regs &regs, pins &pins) { // ADC a
        switch(regs.TCU) {
        // ADC a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6E_Mx(regs &regs, pins &pins) { // ROR a
        switch(regs.TCU) {
        // ROR a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6F_Mx(regs &regs, pins &pins) { // ADC al
        switch(regs.TCU) {
        // ADC al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_70_Mx(regs &regs, pins &pins) { // BVS r
        switch(regs.TCU) {
        // BVS r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_71_Mx(regs &regs, pins &pins) { // ADC (d),y
        switch(regs.TCU) {
        // ADC (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_72_Mx(regs &regs, pins &pins) { // ADC (d)
        switch(regs.TCU) {
        // ADC (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_73_Mx(regs &regs, pins &pins) { // ADC (d,s),y
        switch(regs.TCU) {
        // ADC (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_74_Mx(regs &regs, pins &pins) { // STZ d,x
        switch(regs.TCU) {
        // STZ d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_75_Mx(regs &regs, pins &pins) { // ADC d,x
        switch(regs.TCU) {
        // ADC d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_76_Mx(regs &regs, pins &pins) { // ROR d,x
        switch(regs.TCU) {
        // ROR d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_77_Mx(regs &regs, pins &pins) { // ADC [d],y
        switch(regs.TCU) {
        // ADC [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_78_Mx(regs &regs, pins &pins) { // SEI i
        switch(regs.TCU) {
        // SEI i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_79_Mx(regs &regs, pins &pins) { // ADC a,y
        switch(regs.TCU) {
        // ADC a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7A_Mx(regs &regs, pins &pins) { // PLY s
        switch(regs.TCU) {
        // PLY s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7B_Mx(regs &regs, pins &pins) { // TDC i
        switch(regs.TCU) {
        // TDC i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.D);
        regs.P.Z = +((regs.D) == 0);
        regs.P.N = ((regs.D) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7C_Mx(regs &regs, pins &pins) { // JMP (a,x)
        switch(regs.TCU) {
        // JMP (a,x) E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        regs.TA = (regs.X + regs.TA) & 0xFFFF;
        pins.PDV = 0;
                break; }
            case 4:{
        pins.PDV = 1;
        pins.Addr = regs.TA; pins.BA = regs.PBR;
                break; }
            case 5:{
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7D_Mx(regs &regs, pins &pins) { // ADC a,x
        switch(regs.TCU) {
        // ADC a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7E_Mx(regs &regs, pins &pins) { // ROR a,x
        switch(regs.TCU) {
        // ROR a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7F_Mx(regs &regs, pins &pins) { // ADC al,x
        switch(regs.TCU) {
        // ADC al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_80_Mx(regs &regs, pins &pins) { // BRA r
        switch(regs.TCU) {
        // BRA r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_81_Mx(regs &regs, pins &pins) { // STA (d,x)
        switch(regs.TCU) {
        // STA (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_82_Mx(regs &regs, pins &pins) { // BRL rl
        switch(regs.TCU) {
        // BRL rl E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TA = (u32)(i16)(regs.TA + (pins.D << 8));
        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_83_Mx(regs &regs, pins &pins) { // STA d,s
        switch(regs.TCU) {
        // STA d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_84_Mx(regs &regs, pins &pins) { // STY d
        switch(regs.TCU) {
        // STY d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_85_Mx(regs &regs, pins &pins) { // STA d
        switch(regs.TCU) {
        // STA d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_86_Mx(regs &regs, pins &pins) { // STX d
        switch(regs.TCU) {
        // STX d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_87_Mx(regs &regs, pins &pins) { // STA [d]
        switch(regs.TCU) {
        // STA [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_88_Mx(regs &regs, pins &pins) { // DEY i
        switch(regs.TCU) {
        // DEY i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) - 1) & 0xFFFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_89_Mx(regs &regs, pins &pins) { // BIT #
        switch(regs.TCU) {
        // BIT # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8A_Mx(regs &regs, pins &pins) { // TXA i
        switch(regs.TCU) {
        // TXA i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.X) & 0xFF);
        regs.P.Z = +((regs.X & 0xFF) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8B_Mx(regs &regs, pins &pins) { // PHB s
        switch(regs.TCU) {
        // PHB s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.DBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8C_Mx(regs &regs, pins &pins) { // STY a
        switch(regs.TCU) {
        // STY a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.Y;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8D_Mx(regs &regs, pins &pins) { // STA a
        switch(regs.TCU) {
        // STA a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8E_Mx(regs &regs, pins &pins) { // STX a
        switch(regs.TCU) {
        // STX a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.X;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8F_Mx(regs &regs, pins &pins) { // STA al
        switch(regs.TCU) {
        // STA al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_90_Mx(regs &regs, pins &pins) { // BCC r
        switch(regs.TCU) {
        // BCC r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_91_Mx(regs &regs, pins &pins) { // STA (d),y
        switch(regs.TCU) {
        // STA (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_92_Mx(regs &regs, pins &pins) { // STA (d)
        switch(regs.TCU) {
        // STA (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_93_Mx(regs &regs, pins &pins) { // STA (d,s),y
        switch(regs.TCU) {
        // STA (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_94_Mx(regs &regs, pins &pins) { // STY d,x
        switch(regs.TCU) {
        // STY d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_95_Mx(regs &regs, pins &pins) { // STA d,x
        switch(regs.TCU) {
        // STA d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_96_Mx(regs &regs, pins &pins) { // STX d,y
        switch(regs.TCU) {
        // STX d,y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_97_Mx(regs &regs, pins &pins) { // STA [d],y
        switch(regs.TCU) {
        // STA [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_98_Mx(regs &regs, pins &pins) { // TYA i
        switch(regs.TCU) {
        // TYA i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.Y) & 0xFF);
        regs.P.Z = +((regs.Y & 0xFF) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_99_Mx(regs &regs, pins &pins) { // STA a,y
        switch(regs.TCU) {
        // STA a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9A_Mx(regs &regs, pins &pins) { // TXS i
        switch(regs.TCU) {
        // TXS i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.X;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9B_Mx(regs &regs, pins &pins) { // TXY i
        switch(regs.TCU) {
        // TXY i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = (regs.X);
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9C_Mx(regs &regs, pins &pins) { // STZ a
        switch(regs.TCU) {
        // STZ a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9D_Mx(regs &regs, pins &pins) { // STA a,x
        switch(regs.TCU) {
        // STA a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9E_Mx(regs &regs, pins &pins) { // STZ a,x
        switch(regs.TCU) {
        // STZ a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9F_Mx(regs &regs, pins &pins) { // STA al,x
        switch(regs.TCU) {
        // STA al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A0_Mx(regs &regs, pins &pins) { // LDY #
        switch(regs.TCU) {
        // LDY # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A1_Mx(regs &regs, pins &pins) { // LDA (d,x)
        switch(regs.TCU) {
        // LDA (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A2_Mx(regs &regs, pins &pins) { // LDX #
        switch(regs.TCU) {
        // LDX # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A3_Mx(regs &regs, pins &pins) { // LDA d,s
        switch(regs.TCU) {
        // LDA d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A4_Mx(regs &regs, pins &pins) { // LDY d
        switch(regs.TCU) {
        // LDY d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A5_Mx(regs &regs, pins &pins) { // LDA d
        switch(regs.TCU) {
        // LDA d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A6_Mx(regs &regs, pins &pins) { // LDX d
        switch(regs.TCU) {
        // LDX d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A7_Mx(regs &regs, pins &pins) { // LDA [d]
        switch(regs.TCU) {
        // LDA [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A8_Mx(regs &regs, pins &pins) { // TAY i
        switch(regs.TCU) {
        // TAY i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A9_Mx(regs &regs, pins &pins) { // LDA #
        switch(regs.TCU) {
        // LDA # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AA_Mx(regs &regs, pins &pins) { // TAX i
        switch(regs.TCU) {
        // TAX i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AB_Mx(regs &regs, pins &pins) { // PLB s
        switch(regs.TCU) {
        // PLB s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AC_Mx(regs &regs, pins &pins) { // LDY a
        switch(regs.TCU) {
        // LDY a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AD_Mx(regs &regs, pins &pins) { // LDA a
        switch(regs.TCU) {
        // LDA a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AE_Mx(regs &regs, pins &pins) { // LDX a
        switch(regs.TCU) {
        // LDX a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AF_Mx(regs &regs, pins &pins) { // LDA al
        switch(regs.TCU) {
        // LDA al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B0_Mx(regs &regs, pins &pins) { // BCS r
        switch(regs.TCU) {
        // BCS r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B1_Mx(regs &regs, pins &pins) { // LDA (d),y
        switch(regs.TCU) {
        // LDA (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B2_Mx(regs &regs, pins &pins) { // LDA (d)
        switch(regs.TCU) {
        // LDA (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B3_Mx(regs &regs, pins &pins) { // LDA (d,s),y
        switch(regs.TCU) {
        // LDA (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B4_Mx(regs &regs, pins &pins) { // LDY d,x
        switch(regs.TCU) {
        // LDY d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B5_Mx(regs &regs, pins &pins) { // LDA d,x
        switch(regs.TCU) {
        // LDA d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B6_Mx(regs &regs, pins &pins) { // LDX d,y
        switch(regs.TCU) {
        // LDX d,y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B7_Mx(regs &regs, pins &pins) { // LDA [d],y
        switch(regs.TCU) {
        // LDA [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B8_Mx(regs &regs, pins &pins) { // CLV i
        switch(regs.TCU) {
        // CLV i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.V = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B9_Mx(regs &regs, pins &pins) { // LDA a,y
        switch(regs.TCU) {
        // LDA a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BA_Mx(regs &regs, pins &pins) { // TSX i
        switch(regs.TCU) {
        // TSX i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = (regs.S);
        regs.P.Z = +((regs.S) == 0);
        regs.P.N = ((regs.S) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BB_Mx(regs &regs, pins &pins) { // TYX i
        switch(regs.TCU) {
        // TYX i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = (regs.Y);
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BC_Mx(regs &regs, pins &pins) { // LDY a,x
        switch(regs.TCU) {
        // LDY a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.Y = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BD_Mx(regs &regs, pins &pins) { // LDA a,x
        switch(regs.TCU) {
        // LDA a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BE_Mx(regs &regs, pins &pins) { // LDX a,y
        switch(regs.TCU) {
        // LDX a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BF_Mx(regs &regs, pins &pins) { // LDA al,x
        switch(regs.TCU) {
        // LDA al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C0_Mx(regs &regs, pins &pins) { // CPY #
        switch(regs.TCU) {
        // CPY # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.Y) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C1_Mx(regs &regs, pins &pins) { // CMP (d,x)
        switch(regs.TCU) {
        // CMP (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C2_Mx(regs &regs, pins &pins) { // REP #
        switch(regs.TCU) {
        // REP # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v &= (~regs.TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C3_Mx(regs &regs, pins &pins) { // CMP d,s
        switch(regs.TCU) {
        // CMP d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C4_Mx(regs &regs, pins &pins) { // CPY d
        switch(regs.TCU) {
        // CPY d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.Y) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C5_Mx(regs &regs, pins &pins) { // CMP d
        switch(regs.TCU) {
        // CMP d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C6_Mx(regs &regs, pins &pins) { // DEC d
        switch(regs.TCU) {
        // DEC d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C7_Mx(regs &regs, pins &pins) { // CMP [d]
        switch(regs.TCU) {
        // CMP [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C8_Mx(regs &regs, pins &pins) { // INY i
        switch(regs.TCU) {
        // INY i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) + 1) & 0xFFFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C9_Mx(regs &regs, pins &pins) { // CMP #
        switch(regs.TCU) {
        // CMP # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CA_Mx(regs &regs, pins &pins) { // DEX i
        switch(regs.TCU) {
        // DEX i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) - 1) & 0xFFFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CB_Mx(regs &regs, pins &pins) { // WAI i
        switch(regs.TCU) {
        // WAI i E=0 M=1 X=0
            case 1: {// 1
        regs.WAI = 1;
                break; }
            case 2: {// 2
        if (regs.WAI) {
            regs.TCU--;
            break;
        }
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 3: {// 3
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CC_Mx(regs &regs, pins &pins) { // CPY a
        switch(regs.TCU) {
        // CPY a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.Y) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CD_Mx(regs &regs, pins &pins) { // CMP a
        switch(regs.TCU) {
        // CMP a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CE_Mx(regs &regs, pins &pins) { // DEC a
        switch(regs.TCU) {
        // DEC a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CF_Mx(regs &regs, pins &pins) { // CMP al
        switch(regs.TCU) {
        // CMP al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D0_Mx(regs &regs, pins &pins) { // BNE r
        switch(regs.TCU) {
        // BNE r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D1_Mx(regs &regs, pins &pins) { // CMP (d),y
        switch(regs.TCU) {
        // CMP (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D2_Mx(regs &regs, pins &pins) { // CMP (d)
        switch(regs.TCU) {
        // CMP (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D3_Mx(regs &regs, pins &pins) { // CMP (d,s),y
        switch(regs.TCU) {
        // CMP (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D4_Mx(regs &regs, pins &pins) { // PEI s
        switch(regs.TCU) {
        // PEI s E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.D = regs.TR;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 7: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D5_Mx(regs &regs, pins &pins) { // CMP d,x
        switch(regs.TCU) {
        // CMP d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D6_Mx(regs &regs, pins &pins) { // DEC d,x
        switch(regs.TCU) {
        // DEC d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D7_Mx(regs &regs, pins &pins) { // CMP [d],y
        switch(regs.TCU) {
        // CMP [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D8_Mx(regs &regs, pins &pins) { // CLD i
        switch(regs.TCU) {
        // CLD i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D9_Mx(regs &regs, pins &pins) { // CMP a,y
        switch(regs.TCU) {
        // CMP a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DA_Mx(regs &regs, pins &pins) { // PHX s
        switch(regs.TCU) {
        // PHX s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.X);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DB_Mx(regs &regs, pins &pins) { // STP i
        switch(regs.TCU) {
        // STP i E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// cleanup_custom
        regs.STP = 1;
        // Following is auto-generated code for instruction finish
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DC_Mx(regs &regs, pins &pins) { // JML (a)
        switch(regs.TCU) {
        // JML (a) E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.PC = regs.TR + (pins.D << 8);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DD_Mx(regs &regs, pins &pins) { // CMP a,x
        switch(regs.TCU) {
        // CMP a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DE_Mx(regs &regs, pins &pins) { // DEC a,x
        switch(regs.TCU) {
        // DEC a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DF_Mx(regs &regs, pins &pins) { // CMP al,x
        switch(regs.TCU) {
        // CMP al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E0_Mx(regs &regs, pins &pins) { // CPX #
        switch(regs.TCU) {
        // CPX # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.X) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E1_Mx(regs &regs, pins &pins) { // SBC (d,x)
        switch(regs.TCU) {
        // SBC (d,x) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E2_Mx(regs &regs, pins &pins) { // SEP #
        switch(regs.TCU) {
        // SEP # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v |= regs.TR;
        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E3_Mx(regs &regs, pins &pins) { // SBC d,s
        switch(regs.TCU) {
        // SBC d,s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E4_Mx(regs &regs, pins &pins) { // CPX d
        switch(regs.TCU) {
        // CPX d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.X) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E5_Mx(regs &regs, pins &pins) { // SBC d
        switch(regs.TCU) {
        // SBC d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E6_Mx(regs &regs, pins &pins) { // INC d
        switch(regs.TCU) {
        // INC d E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E7_Mx(regs &regs, pins &pins) { // SBC [d]
        switch(regs.TCU) {
        // SBC [d] E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E8_Mx(regs &regs, pins &pins) { // INX i
        switch(regs.TCU) {
        // INX i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) + 1) & 0xFFFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E9_Mx(regs &regs, pins &pins) { // SBC #
        switch(regs.TCU) {
        // SBC # E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EA_Mx(regs &regs, pins &pins) { // NOP i
        switch(regs.TCU) {
        // NOP i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EB_Mx(regs &regs, pins &pins) { // XBA i
        switch(regs.TCU) {
        // XBA i E=0 M=1 X=0
            case 1:{
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2:{
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >> 8) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EC_Mx(regs &regs, pins &pins) { // CPX a
        switch(regs.TCU) {
        // CPX a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.X) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_ED_Mx(regs &regs, pins &pins) { // SBC a
        switch(regs.TCU) {
        // SBC a E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EE_Mx(regs &regs, pins &pins) { // INC a
        switch(regs.TCU) {
        // INC a E=0 M=1 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EF_Mx(regs &regs, pins &pins) { // SBC al
        switch(regs.TCU) {
        // SBC al E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F0_Mx(regs &regs, pins &pins) { // BEQ r
        switch(regs.TCU) {
        // BEQ r E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F1_Mx(regs &regs, pins &pins) { // SBC (d),y
        switch(regs.TCU) {
        // SBC (d),y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F2_Mx(regs &regs, pins &pins) { // SBC (d)
        switch(regs.TCU) {
        // SBC (d) E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F3_Mx(regs &regs, pins &pins) { // SBC (d,s),y
        switch(regs.TCU) {
        // SBC (d,s),y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F4_Mx(regs &regs, pins &pins) { // PEA s
        switch(regs.TCU) {
        // PEA s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR;
                break; }
            case 5: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F5_Mx(regs &regs, pins &pins) { // SBC d,x
        switch(regs.TCU) {
        // SBC d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F6_Mx(regs &regs, pins &pins) { // INC d,x
        switch(regs.TCU) {
        // INC d,x E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F7_Mx(regs &regs, pins &pins) { // SBC [d],y
        switch(regs.TCU) {
        // SBC [d],y E=0 M=1 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F8_Mx(regs &regs, pins &pins) { // SED i
        switch(regs.TCU) {
        // SED i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F9_Mx(regs &regs, pins &pins) { // SBC a,y
        switch(regs.TCU) {
        // SBC a,y E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FA_Mx(regs &regs, pins &pins) { // PLX s
        switch(regs.TCU) {
        // PLX s E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.X = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FB_Mx(regs &regs, pins &pins) { // XCE i
        switch(regs.TCU) {
        // XCE i E=0 M=1 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        u32 TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
        if (regs.E) {
            regs.P.X = regs.P.M = 1;
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
            regs.S = (regs.S & 0xFF) | 0x100;
        }
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FC_Mx(regs &regs, pins &pins) { // JSR (a,x)
        switch(regs.TCU) {
        // JSR (a,x) E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.RW = 1;
        regs.TA = pins.D;
        pins.D = ((regs.PC) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 4
        pins.D = (regs.PC) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                break; }
            case 6: {// 7
        pins.PDV = 1;
        pins.Addr = regs.TA;
                break; }
            case 7: {// 8
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.PC = pins.D;
                break; }
            case 8: {// cleanup_custom
        regs.PC += (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FD_Mx(regs &regs, pins &pins) { // SBC a,x
        switch(regs.TCU) {
        // SBC a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FE_Mx(regs &regs, pins &pins) { // INC a,x
        switch(regs.TCU) {
        // INC a,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FF_Mx(regs &regs, pins &pins) { // SBC al,x
        switch(regs.TCU) {
        // SBC al,x E=0 M=1 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_100_Mx(regs &regs, pins &pins) { // S_RESET s
        switch(regs.TCU) {
        // S_RESET s E=0 M=1 X=0
            case 1: {// 3
        pins.RW = 0; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFFC); pins.BA = (0);
        regs.DBR = 0;
        regs.D = 0;
        regs.PBR = 0;
        regs.X &= 0xFF;
        regs.Y &= 0xFF;
        regs.E = 1;
        regs.P.M = regs.P.X = regs.P.I = 1; regs.P.C = 0;
        regs.P.D = 0;
        regs.STP = regs.WAI = 0;
        regs.S = 0x1FF;
                break; }
            case 6: {// 8
        regs.PC = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.PC += (pins.D << 8);
        pins.PDV = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_101_Mx(regs &regs, pins &pins) { // S_ABORT s
        switch(regs.TCU) {
        // S_ABORT s E=0 M=1 X=0
            case 1: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFE8); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFE9); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_102_Mx(regs &regs, pins &pins) { // S_IRQ s
        switch(regs.TCU) {
        // S_IRQ s E=0 M=1 X=0
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEE); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEF); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_103_Mx(regs &regs, pins &pins) { // S_NMI s
        switch(regs.TCU) {
        // S_NMI s E=0 M=1 X=0
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEA); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEB); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_00_mX(regs &regs, pins &pins) { // BRK s
        switch(regs.TCU) {
        // BRK s E=0 M=0 X=1
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE6); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE7); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_01_mX(regs &regs, pins &pins) { // ORA (d,x)
        switch(regs.TCU) {
        // ORA (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_02_mX(regs &regs, pins &pins) { // COP s
        switch(regs.TCU) {
        // COP s E=0 M=0 X=1
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE4); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE5); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_03_mX(regs &regs, pins &pins) { // ORA d,s
        switch(regs.TCU) {
        // ORA d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_04_mX(regs &regs, pins &pins) { // TSB d
        switch(regs.TCU) {
        // TSB d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_05_mX(regs &regs, pins &pins) { // ORA d
        switch(regs.TCU) {
        // ORA d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_06_mX(regs &regs, pins &pins) { // ASL d
        switch(regs.TCU) {
        // ASL d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_07_mX(regs &regs, pins &pins) { // ORA [d]
        switch(regs.TCU) {
        // ORA [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_08_mX(regs &regs, pins &pins) { // PHP s
        switch(regs.TCU) {
        // PHP s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.P.v;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_09_mX(regs &regs, pins &pins) { // ORA #
        switch(regs.TCU) {
        // ORA # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0A_mX(regs &regs, pins &pins) { // ASL A
        switch(regs.TCU) {
        // ASL A E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0B_mX(regs &regs, pins &pins) { // PHD s
        switch(regs.TCU) {
        // PHD s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.D);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0C_mX(regs &regs, pins &pins) { // TSB a
        switch(regs.TCU) {
        // TSB a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0D_mX(regs &regs, pins &pins) { // ORA a
        switch(regs.TCU) {
        // ORA a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0E_mX(regs &regs, pins &pins) { // ASL a
        switch(regs.TCU) {
        // ASL a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0F_mX(regs &regs, pins &pins) { // ORA al
        switch(regs.TCU) {
        // ORA al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_10_mX(regs &regs, pins &pins) { // BPL r
        switch(regs.TCU) {
        // BPL r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_11_mX(regs &regs, pins &pins) { // ORA (d),y
        switch(regs.TCU) {
        // ORA (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_12_mX(regs &regs, pins &pins) { // ORA (d)
        switch(regs.TCU) {
        // ORA (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_13_mX(regs &regs, pins &pins) { // ORA (d,s),y
        switch(regs.TCU) {
        // ORA (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_14_mX(regs &regs, pins &pins) { // TRB d
        switch(regs.TCU) {
        // TRB d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_15_mX(regs &regs, pins &pins) { // ORA d,x
        switch(regs.TCU) {
        // ORA d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_16_mX(regs &regs, pins &pins) { // ASL d,x
        switch(regs.TCU) {
        // ASL d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_17_mX(regs &regs, pins &pins) { // ORA [d],y
        switch(regs.TCU) {
        // ORA [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_18_mX(regs &regs, pins &pins) { // CLC i
        switch(regs.TCU) {
        // CLC i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_19_mX(regs &regs, pins &pins) { // ORA a,y
        switch(regs.TCU) {
        // ORA a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1A_mX(regs &regs, pins &pins) { // INC A
        switch(regs.TCU) {
        // INC A E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1B_mX(regs &regs, pins &pins) { // TCS i
        switch(regs.TCU) {
        // TCS i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.C;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1C_mX(regs &regs, pins &pins) { // TRB a
        switch(regs.TCU) {
        // TRB a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFFFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFFFF;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1D_mX(regs &regs, pins &pins) { // ORA a,x
        switch(regs.TCU) {
        // ORA a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1E_mX(regs &regs, pins &pins) { // ASL a,x
        switch(regs.TCU) {
        // ASL a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = (regs.TR & 0x7FFF) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1F_mX(regs &regs, pins &pins) { // ORA al,x
        switch(regs.TCU) {
        // ORA al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C |= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_20_mX(regs &regs, pins &pins) { // JSR a
        switch(regs.TCU) {
        // JSR a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.PDV = 0;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 6
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_21_mX(regs &regs, pins &pins) { // AND (d,x)
        switch(regs.TCU) {
        // AND (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_22_mX(regs &regs, pins &pins) { // JSL al
        switch(regs.TCU) {
        // JSL al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        regs.TA += pins.D << 8;
        pins.D = (regs.PBR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 5: {// 6
        pins.PDV = 1;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 6: {// 7
        regs.PBR = pins.D;
        pins.RW = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 7: {// 8
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_23_mX(regs &regs, pins &pins) { // AND d,s
        switch(regs.TCU) {
        // AND d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_24_mX(regs &regs, pins &pins) { // BIT d
        switch(regs.TCU) {
        // BIT d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_25_mX(regs &regs, pins &pins) { // AND d
        switch(regs.TCU) {
        // AND d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_26_mX(regs &regs, pins &pins) { // ROL d
        switch(regs.TCU) {
        // ROL d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_27_mX(regs &regs, pins &pins) { // AND [d]
        switch(regs.TCU) {
        // AND [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_28_mX(regs &regs, pins &pins) { // PLP s
        switch(regs.TCU) {
        // PLP s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.v = regs.TR;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_29_mX(regs &regs, pins &pins) { // AND #
        switch(regs.TCU) {
        // AND # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2A_mX(regs &regs, pins &pins) { // ROL A
        switch(regs.TCU) {
        // ROL A E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2B_mX(regs &regs, pins &pins) { // PLD s
        switch(regs.TCU) {
        // PLD s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.D = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2C_mX(regs &regs, pins &pins) { // BIT a
        switch(regs.TCU) {
        // BIT a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2D_mX(regs &regs, pins &pins) { // AND a
        switch(regs.TCU) {
        // AND a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2E_mX(regs &regs, pins &pins) { // ROL a
        switch(regs.TCU) {
        // ROL a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2F_mX(regs &regs, pins &pins) { // AND al
        switch(regs.TCU) {
        // AND al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_30_mX(regs &regs, pins &pins) { // BMI r
        switch(regs.TCU) {
        // BMI r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_31_mX(regs &regs, pins &pins) { // AND (d),y
        switch(regs.TCU) {
        // AND (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_32_mX(regs &regs, pins &pins) { // AND (d)
        switch(regs.TCU) {
        // AND (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_33_mX(regs &regs, pins &pins) { // AND (d,s),y
        switch(regs.TCU) {
        // AND (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_34_mX(regs &regs, pins &pins) { // BIT d,x
        switch(regs.TCU) {
        // BIT d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_35_mX(regs &regs, pins &pins) { // AND d,x
        switch(regs.TCU) {
        // AND d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_36_mX(regs &regs, pins &pins) { // ROL d,x
        switch(regs.TCU) {
        // ROL d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_37_mX(regs &regs, pins &pins) { // AND [d],y
        switch(regs.TCU) {
        // AND [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_38_mX(regs &regs, pins &pins) { // SEC i
        switch(regs.TCU) {
        // SEC i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_39_mX(regs &regs, pins &pins) { // AND a,y
        switch(regs.TCU) {
        // AND a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3A_mX(regs &regs, pins &pins) { // DEC A
        switch(regs.TCU) {
        // DEC A E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3B_mX(regs &regs, pins &pins) { // TSC i
        switch(regs.TCU) {
        // TSC i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.S);
        regs.P.Z = +((regs.S) == 0);
        regs.P.N = ((regs.S) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3C_mX(regs &regs, pins &pins) { // BIT a,x
        switch(regs.TCU) {
        // BIT a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        regs.P.V = (regs.TR & 0x4000) >> 14;
        regs.P.N = (regs.TR & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3D_mX(regs &regs, pins &pins) { // AND a,x
        switch(regs.TCU) {
        // AND a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3E_mX(regs &regs, pins &pins) { // ROL a,x
        switch(regs.TCU) {
        // ROL a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x8000) >> 15;
        regs.TR = ((regs.TR & 0x7FFF) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3F_mX(regs &regs, pins &pins) { // AND al,x
        switch(regs.TCU) {
        // AND al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C &= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_40_mX(regs &regs, pins &pins) { // RTI s
        switch(regs.TCU) {
        // RTI s E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        pins.PDV = 1;
                break; }
            case 4: {// 5
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.P.v = pins.D;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x100;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA = pins.D;
                break; }
            case 6: {// 7
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA += pins.D << 8;
                break; }
            case 7: {// cleanup_custom
        regs.PC = regs.TA;
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_41_mX(regs &regs, pins &pins) { // EOR (d,x)
        switch(regs.TCU) {
        // EOR (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_42_mX(regs &regs, pins &pins) { // WDM i
        switch(regs.TCU) {
        // WDM i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_43_mX(regs &regs, pins &pins) { // EOR d,s
        switch(regs.TCU) {
        // EOR d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_44_mX(regs &regs, pins &pins) { // MVP xyc
        switch(regs.TCU) {
        // MVP xyc E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = (regs.X); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
                break; }
            case 7: {// cleanup_custom
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X - 1) & 0xFF;
        regs.Y = (regs.Y - 1) & 0xFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_45_mX(regs &regs, pins &pins) { // EOR d
        switch(regs.TCU) {
        // EOR d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_46_mX(regs &regs, pins &pins) { // LSR d
        switch(regs.TCU) {
        // LSR d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_47_mX(regs &regs, pins &pins) { // EOR [d]
        switch(regs.TCU) {
        // EOR [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_48_mX(regs &regs, pins &pins) { // PHA s
        switch(regs.TCU) {
        // PHA s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.C);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_49_mX(regs &regs, pins &pins) { // EOR #
        switch(regs.TCU) {
        // EOR # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4A_mX(regs &regs, pins &pins) { // LSR A
        switch(regs.TCU) {
        // LSR A E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4B_mX(regs &regs, pins &pins) { // PHK s
        switch(regs.TCU) {
        // PHK s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.PBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4C_mX(regs &regs, pins &pins) { // JMP a
        switch(regs.TCU) {
        // JMP a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4D_mX(regs &regs, pins &pins) { // EOR a
        switch(regs.TCU) {
        // EOR a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4E_mX(regs &regs, pins &pins) { // LSR a
        switch(regs.TCU) {
        // LSR a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4F_mX(regs &regs, pins &pins) { // EOR al
        switch(regs.TCU) {
        // EOR al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_50_mX(regs &regs, pins &pins) { // BVC r
        switch(regs.TCU) {
        // BVC r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_51_mX(regs &regs, pins &pins) { // EOR (d),y
        switch(regs.TCU) {
        // EOR (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_52_mX(regs &regs, pins &pins) { // EOR (d)
        switch(regs.TCU) {
        // EOR (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_53_mX(regs &regs, pins &pins) { // EOR (d,s),y
        switch(regs.TCU) {
        // EOR (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_54_mX(regs &regs, pins &pins) { // MVN xyc
        switch(regs.TCU) {
        // MVN xyc E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X + 1) & 0xFF;
        regs.Y = (regs.Y + 1) & 0xFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_55_mX(regs &regs, pins &pins) { // EOR d,x
        switch(regs.TCU) {
        // EOR d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_56_mX(regs &regs, pins &pins) { // LSR d,x
        switch(regs.TCU) {
        // LSR d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_57_mX(regs &regs, pins &pins) { // EOR [d],y
        switch(regs.TCU) {
        // EOR [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_58_mX(regs &regs, pins &pins) { // CLI i
        switch(regs.TCU) {
        // CLI i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_59_mX(regs &regs, pins &pins) { // EOR a,y
        switch(regs.TCU) {
        // EOR a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5A_mX(regs &regs, pins &pins) { // PHY s
        switch(regs.TCU) {
        // PHY s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.Y) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5B_mX(regs &regs, pins &pins) { // TCD i
        switch(regs.TCU) {
        // TCD i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.D = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5C_mX(regs &regs, pins &pins) { // JMP al
        switch(regs.TCU) {
        // JMP al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = regs.TA + (pins.D << 8);
                break; }
            case 4: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5D_mX(regs &regs, pins &pins) { // EOR a,x
        switch(regs.TCU) {
        // EOR a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5E_mX(regs &regs, pins &pins) { // LSR a,x
        switch(regs.TCU) {
        // LSR a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5F_mX(regs &regs, pins &pins) { // EOR al,x
        switch(regs.TCU) {
        // EOR al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C ^= regs.TR;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_60_mX(regs &regs, pins &pins) { // RTS s
        switch(regs.TCU) {
        // RTS s E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_61_mX(regs &regs, pins &pins) { // ADC (d,x)
        switch(regs.TCU) {
        // ADC (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_62_mX(regs &regs, pins &pins) { // PER s
        switch(regs.TCU) {
        // PER s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
                break; }
            case 6: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_63_mX(regs &regs, pins &pins) { // ADC d,s
        switch(regs.TCU) {
        // ADC d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_64_mX(regs &regs, pins &pins) { // STZ d
        switch(regs.TCU) {
        // STZ d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_65_mX(regs &regs, pins &pins) { // ADC d
        switch(regs.TCU) {
        // ADC d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_66_mX(regs &regs, pins &pins) { // ROR d
        switch(regs.TCU) {
        // ROR d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_67_mX(regs &regs, pins &pins) { // ADC [d]
        switch(regs.TCU) {
        // ADC [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_68_mX(regs &regs, pins &pins) { // PLA s
        switch(regs.TCU) {
        // PLA s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.C = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_69_mX(regs &regs, pins &pins) { // ADC #
        switch(regs.TCU) {
        // ADC # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6A_mX(regs &regs, pins &pins) { // ROR A
        switch(regs.TCU) {
        // ROR A E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        regs.C = regs.TR & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6B_mX(regs &regs, pins &pins) { // RTL s
        switch(regs.TCU) {
        // RTL s E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6C_mX(regs &regs, pins &pins) { // JMP (a)
        switch(regs.TCU) {
        // JMP (a) E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6D_mX(regs &regs, pins &pins) { // ADC a
        switch(regs.TCU) {
        // ADC a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6E_mX(regs &regs, pins &pins) { // ROR a
        switch(regs.TCU) {
        // ROR a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6F_mX(regs &regs, pins &pins) { // ADC al
        switch(regs.TCU) {
        // ADC al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_70_mX(regs &regs, pins &pins) { // BVS r
        switch(regs.TCU) {
        // BVS r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_71_mX(regs &regs, pins &pins) { // ADC (d),y
        switch(regs.TCU) {
        // ADC (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_72_mX(regs &regs, pins &pins) { // ADC (d)
        switch(regs.TCU) {
        // ADC (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_73_mX(regs &regs, pins &pins) { // ADC (d,s),y
        switch(regs.TCU) {
        // ADC (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_74_mX(regs &regs, pins &pins) { // STZ d,x
        switch(regs.TCU) {
        // STZ d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_75_mX(regs &regs, pins &pins) { // ADC d,x
        switch(regs.TCU) {
        // ADC d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_76_mX(regs &regs, pins &pins) { // ROR d,x
        switch(regs.TCU) {
        // ROR d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_77_mX(regs &regs, pins &pins) { // ADC [d],y
        switch(regs.TCU) {
        // ADC [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_78_mX(regs &regs, pins &pins) { // SEI i
        switch(regs.TCU) {
        // SEI i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_79_mX(regs &regs, pins &pins) { // ADC a,y
        switch(regs.TCU) {
        // ADC a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7A_mX(regs &regs, pins &pins) { // PLY s
        switch(regs.TCU) {
        // PLY s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7B_mX(regs &regs, pins &pins) { // TDC i
        switch(regs.TCU) {
        // TDC i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.D);
        regs.P.Z = +((regs.D) == 0);
        regs.P.N = ((regs.D) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7C_mX(regs &regs, pins &pins) { // JMP (a,x)
        switch(regs.TCU) {
        // JMP (a,x) E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        regs.TA = (regs.X + regs.TA) & 0xFFFF;
        pins.PDV = 0;
                break; }
            case 4:{
        pins.PDV = 1;
        pins.Addr = regs.TA; pins.BA = regs.PBR;
                break; }
            case 5:{
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7D_mX(regs &regs, pins &pins) { // ADC a,x
        switch(regs.TCU) {
        // ADC a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7E_mX(regs &regs, pins &pins) { // ROR a,x
        switch(regs.TCU) {
        // ROR a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 carry = regs.P.C << 15;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFFFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7F_mX(regs &regs, pins &pins) { // ADC al,x
        switch(regs.TCU) {
        // ADC al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        u32 result;
        if (!regs.P.D) result = regs.C + regs.TR + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (regs.TR & 0x000F) + (regs.P.C << 0);
            if (result > 0x0009) result += 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (regs.TR & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result > 0x009F) result += 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (regs.TR & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result > 0x09FF) result += 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (regs.TR & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ regs.TR)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result > 0x9FFF) result += 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +(((result & 0xFFFF)) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_80_mX(regs &regs, pins &pins) { // BRA r
        switch(regs.TCU) {
        // BRA r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_81_mX(regs &regs, pins &pins) { // STA (d,x)
        switch(regs.TCU) {
        // STA (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_82_mX(regs &regs, pins &pins) { // BRL rl
        switch(regs.TCU) {
        // BRL rl E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TA = (u32)(i16)(regs.TA + (pins.D << 8));
        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_83_mX(regs &regs, pins &pins) { // STA d,s
        switch(regs.TCU) {
        // STA d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_84_mX(regs &regs, pins &pins) { // STY d
        switch(regs.TCU) {
        // STY d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_85_mX(regs &regs, pins &pins) { // STA d
        switch(regs.TCU) {
        // STA d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_86_mX(regs &regs, pins &pins) { // STX d
        switch(regs.TCU) {
        // STX d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_87_mX(regs &regs, pins &pins) { // STA [d]
        switch(regs.TCU) {
        // STA [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_88_mX(regs &regs, pins &pins) { // DEY i
        switch(regs.TCU) {
        // DEY i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) - 1) & 0xFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_89_mX(regs &regs, pins &pins) { // BIT #
        switch(regs.TCU) {
        // BIT # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFFFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8A_mX(regs &regs, pins &pins) { // TXA i
        switch(regs.TCU) {
        // TXA i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.X);
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8B_mX(regs &regs, pins &pins) { // PHB s
        switch(regs.TCU) {
        // PHB s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.DBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8C_mX(regs &regs, pins &pins) { // STY a
        switch(regs.TCU) {
        // STY a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8D_mX(regs &regs, pins &pins) { // STA a
        switch(regs.TCU) {
        // STA a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8E_mX(regs &regs, pins &pins) { // STX a
        switch(regs.TCU) {
        // STX a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8F_mX(regs &regs, pins &pins) { // STA al
        switch(regs.TCU) {
        // STA al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 5a
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_90_mX(regs &regs, pins &pins) { // BCC r
        switch(regs.TCU) {
        // BCC r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_91_mX(regs &regs, pins &pins) { // STA (d),y
        switch(regs.TCU) {
        // STA (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_92_mX(regs &regs, pins &pins) { // STA (d)
        switch(regs.TCU) {
        // STA (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 6: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_93_mX(regs &regs, pins &pins) { // STA (d,s),y
        switch(regs.TCU) {
        // STA (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_94_mX(regs &regs, pins &pins) { // STY d,x
        switch(regs.TCU) {
        // STY d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_95_mX(regs &regs, pins &pins) { // STA d,x
        switch(regs.TCU) {
        // STA d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_96_mX(regs &regs, pins &pins) { // STX d,y
        switch(regs.TCU) {
        // STX d,y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_97_mX(regs &regs, pins &pins) { // STA [d],y
        switch(regs.TCU) {
        // STA [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 7: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_98_mX(regs &regs, pins &pins) { // TYA i
        switch(regs.TCU) {
        // TYA i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.Y);
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_99_mX(regs &regs, pins &pins) { // STA a,y
        switch(regs.TCU) {
        // STA a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9A_mX(regs &regs, pins &pins) { // TXS i
        switch(regs.TCU) {
        // TXS i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.X;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9B_mX(regs &regs, pins &pins) { // TXY i
        switch(regs.TCU) {
        // TXY i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.X) & 0xFF);
        regs.P.Z = +((regs.X & 0xFF) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9C_mX(regs &regs, pins &pins) { // STZ a
        switch(regs.TCU) {
        // STZ a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9D_mX(regs &regs, pins &pins) { // STA a,x
        switch(regs.TCU) {
        // STA a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9E_mX(regs &regs, pins &pins) { // STZ a,x
        switch(regs.TCU) {
        // STZ a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9F_mX(regs &regs, pins &pins) { // STA al,x
        switch(regs.TCU) {
        // STA al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// finish_RW8or16p W16H
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
        pins.D = (regs.TR >> 8) & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A0_mX(regs &regs, pins &pins) { // LDY #
        switch(regs.TCU) {
        // LDY # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A1_mX(regs &regs, pins &pins) { // LDA (d,x)
        switch(regs.TCU) {
        // LDA (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A2_mX(regs &regs, pins &pins) { // LDX #
        switch(regs.TCU) {
        // LDX # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A3_mX(regs &regs, pins &pins) { // LDA d,s
        switch(regs.TCU) {
        // LDA d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A4_mX(regs &regs, pins &pins) { // LDY d
        switch(regs.TCU) {
        // LDY d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A5_mX(regs &regs, pins &pins) { // LDA d
        switch(regs.TCU) {
        // LDA d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A6_mX(regs &regs, pins &pins) { // LDX d
        switch(regs.TCU) {
        // LDX d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A7_mX(regs &regs, pins &pins) { // LDA [d]
        switch(regs.TCU) {
        // LDA [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A8_mX(regs &regs, pins &pins) { // TAY i
        switch(regs.TCU) {
        // TAY i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.C) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A9_mX(regs &regs, pins &pins) { // LDA #
        switch(regs.TCU) {
        // LDA # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AA_mX(regs &regs, pins &pins) { // TAX i
        switch(regs.TCU) {
        // TAX i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.C) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AB_mX(regs &regs, pins &pins) { // PLB s
        switch(regs.TCU) {
        // PLB s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AC_mX(regs &regs, pins &pins) { // LDY a
        switch(regs.TCU) {
        // LDY a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AD_mX(regs &regs, pins &pins) { // LDA a
        switch(regs.TCU) {
        // LDA a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AE_mX(regs &regs, pins &pins) { // LDX a
        switch(regs.TCU) {
        // LDX a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AF_mX(regs &regs, pins &pins) { // LDA al
        switch(regs.TCU) {
        // LDA al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B0_mX(regs &regs, pins &pins) { // BCS r
        switch(regs.TCU) {
        // BCS r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B1_mX(regs &regs, pins &pins) { // LDA (d),y
        switch(regs.TCU) {
        // LDA (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B2_mX(regs &regs, pins &pins) { // LDA (d)
        switch(regs.TCU) {
        // LDA (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B3_mX(regs &regs, pins &pins) { // LDA (d,s),y
        switch(regs.TCU) {
        // LDA (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B4_mX(regs &regs, pins &pins) { // LDY d,x
        switch(regs.TCU) {
        // LDY d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B5_mX(regs &regs, pins &pins) { // LDA d,x
        switch(regs.TCU) {
        // LDA d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B6_mX(regs &regs, pins &pins) { // LDX d,y
        switch(regs.TCU) {
        // LDX d,y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B7_mX(regs &regs, pins &pins) { // LDA [d],y
        switch(regs.TCU) {
        // LDA [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B8_mX(regs &regs, pins &pins) { // CLV i
        switch(regs.TCU) {
        // CLV i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.V = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B9_mX(regs &regs, pins &pins) { // LDA a,y
        switch(regs.TCU) {
        // LDA a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BA_mX(regs &regs, pins &pins) { // TSX i
        switch(regs.TCU) {
        // TSX i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X  = regs.S & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BB_mX(regs &regs, pins &pins) { // TYX i
        switch(regs.TCU) {
        // TYX i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.Y) & 0xFF);
        regs.P.Z = +((regs.Y & 0xFF) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BC_mX(regs &regs, pins &pins) { // LDY a,x
        switch(regs.TCU) {
        // LDY a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BD_mX(regs &regs, pins &pins) { // LDA a,x
        switch(regs.TCU) {
        // LDA a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BE_mX(regs &regs, pins &pins) { // LDX a,y
        switch(regs.TCU) {
        // LDX a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BF_mX(regs &regs, pins &pins) { // LDA al,x
        switch(regs.TCU) {
        // LDA al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.C = regs.TR & 0xFFFF;
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C0_mX(regs &regs, pins &pins) { // CPY #
        switch(regs.TCU) {
        // CPY # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C1_mX(regs &regs, pins &pins) { // CMP (d,x)
        switch(regs.TCU) {
        // CMP (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C2_mX(regs &regs, pins &pins) { // REP #
        switch(regs.TCU) {
        // REP # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v &= (~regs.TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C3_mX(regs &regs, pins &pins) { // CMP d,s
        switch(regs.TCU) {
        // CMP d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C4_mX(regs &regs, pins &pins) { // CPY d
        switch(regs.TCU) {
        // CPY d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C5_mX(regs &regs, pins &pins) { // CMP d
        switch(regs.TCU) {
        // CMP d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C6_mX(regs &regs, pins &pins) { // DEC d
        switch(regs.TCU) {
        // DEC d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C7_mX(regs &regs, pins &pins) { // CMP [d]
        switch(regs.TCU) {
        // CMP [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C8_mX(regs &regs, pins &pins) { // INY i
        switch(regs.TCU) {
        // INY i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) + 1) & 0xFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C9_mX(regs &regs, pins &pins) { // CMP #
        switch(regs.TCU) {
        // CMP # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CA_mX(regs &regs, pins &pins) { // DEX i
        switch(regs.TCU) {
        // DEX i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) - 1) & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CB_mX(regs &regs, pins &pins) { // WAI i
        switch(regs.TCU) {
        // WAI i E=0 M=0 X=1
            case 1: {// 1
        regs.WAI = 1;
                break; }
            case 2: {// 2
        if (regs.WAI) {
            regs.TCU--;
            break;
        }
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 3: {// 3
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CC_mX(regs &regs, pins &pins) { // CPY a
        switch(regs.TCU) {
        // CPY a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CD_mX(regs &regs, pins &pins) { // CMP a
        switch(regs.TCU) {
        // CMP a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CE_mX(regs &regs, pins &pins) { // DEC a
        switch(regs.TCU) {
        // DEC a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CF_mX(regs &regs, pins &pins) { // CMP al
        switch(regs.TCU) {
        // CMP al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D0_mX(regs &regs, pins &pins) { // BNE r
        switch(regs.TCU) {
        // BNE r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D1_mX(regs &regs, pins &pins) { // CMP (d),y
        switch(regs.TCU) {
        // CMP (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D2_mX(regs &regs, pins &pins) { // CMP (d)
        switch(regs.TCU) {
        // CMP (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D3_mX(regs &regs, pins &pins) { // CMP (d,s),y
        switch(regs.TCU) {
        // CMP (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D4_mX(regs &regs, pins &pins) { // PEI s
        switch(regs.TCU) {
        // PEI s E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.D = regs.TR;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 7: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D5_mX(regs &regs, pins &pins) { // CMP d,x
        switch(regs.TCU) {
        // CMP d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D6_mX(regs &regs, pins &pins) { // DEC d,x
        switch(regs.TCU) {
        // DEC d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D7_mX(regs &regs, pins &pins) { // CMP [d],y
        switch(regs.TCU) {
        // CMP [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D8_mX(regs &regs, pins &pins) { // CLD i
        switch(regs.TCU) {
        // CLD i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D9_mX(regs &regs, pins &pins) { // CMP a,y
        switch(regs.TCU) {
        // CMP a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DA_mX(regs &regs, pins &pins) { // PHX s
        switch(regs.TCU) {
        // PHX s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.X) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DB_mX(regs &regs, pins &pins) { // STP i
        switch(regs.TCU) {
        // STP i E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// cleanup_custom
        regs.STP = 1;
        // Following is auto-generated code for instruction finish
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DC_mX(regs &regs, pins &pins) { // JML (a)
        switch(regs.TCU) {
        // JML (a) E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.PC = regs.TR + (pins.D << 8);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DD_mX(regs &regs, pins &pins) { // CMP a,x
        switch(regs.TCU) {
        // CMP a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DE_mX(regs &regs, pins &pins) { // DEC a,x
        switch(regs.TCU) {
        // DEC a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DF_mX(regs &regs, pins &pins) { // CMP al,x
        switch(regs.TCU) {
        // CMP al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = (regs.C) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E0_mX(regs &regs, pins &pins) { // CPX #
        switch(regs.TCU) {
        // CPX # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E1_mX(regs &regs, pins &pins) { // SBC (d,x)
        switch(regs.TCU) {
        // SBC (d,x) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E2_mX(regs &regs, pins &pins) { // SEP #
        switch(regs.TCU) {
        // SEP # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v |= regs.TR;
        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E3_mX(regs &regs, pins &pins) { // SBC d,s
        switch(regs.TCU) {
        // SBC d,s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E4_mX(regs &regs, pins &pins) { // CPX d
        switch(regs.TCU) {
        // CPX d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E5_mX(regs &regs, pins &pins) { // SBC d
        switch(regs.TCU) {
        // SBC d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E6_mX(regs &regs, pins &pins) { // INC d
        switch(regs.TCU) {
        // INC d E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E7_mX(regs &regs, pins &pins) { // SBC [d]
        switch(regs.TCU) {
        // SBC [d] E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E8_mX(regs &regs, pins &pins) { // INX i
        switch(regs.TCU) {
        // INX i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) + 1) & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E9_mX(regs &regs, pins &pins) { // SBC #
        switch(regs.TCU) {
        // SBC # E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EA_mX(regs &regs, pins &pins) { // NOP i
        switch(regs.TCU) {
        // NOP i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EB_mX(regs &regs, pins &pins) { // XBA i
        switch(regs.TCU) {
        // XBA i E=0 M=0 X=1
            case 1:{
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2:{
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >> 8) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EC_mX(regs &regs, pins &pins) { // CPX a
        switch(regs.TCU) {
        // CPX a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_ED_mX(regs &regs, pins &pins) { // SBC a
        switch(regs.TCU) {
        // SBC a E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EE_mX(regs &regs, pins &pins) { // INC a
        switch(regs.TCU) {
        // INC a E=0 M=0 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 7: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EF_mX(regs &regs, pins &pins) { // SBC al
        switch(regs.TCU) {
        // SBC al E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += (pins. D & 0xFF) << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F0_mX(regs &regs, pins &pins) { // BEQ r
        switch(regs.TCU) {
        // BEQ r E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F1_mX(regs &regs, pins &pins) { // SBC (d),y
        switch(regs.TCU) {
        // SBC (d),y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F2_mX(regs &regs, pins &pins) { // SBC (d)
        switch(regs.TCU) {
        // SBC (d) E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F3_mX(regs &regs, pins &pins) { // SBC (d,s),y
        switch(regs.TCU) {
        // SBC (d,s),y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F4_mX(regs &regs, pins &pins) { // PEA s
        switch(regs.TCU) {
        // PEA s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR;
                break; }
            case 5: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F5_mX(regs &regs, pins &pins) { // SBC d,x
        switch(regs.TCU) {
        // SBC d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F6_mX(regs &regs, pins &pins) { // INC d,x
        switch(regs.TCU) {
        // INC d,x E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 16L
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// fetch_rmw_8or16 16H
        regs.TR += pins.D << 8;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr = (pins.Addr - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F7_mX(regs &regs, pins &pins) { // SBC [d],y
        switch(regs.TCU) {
        // SBC [d],y E=0 M=0 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 8: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F8_mX(regs &regs, pins &pins) { // SED i
        switch(regs.TCU) {
        // SED i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F9_mX(regs &regs, pins &pins) { // SBC a,y
        switch(regs.TCU) {
        // SBC a,y E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FA_mX(regs &regs, pins &pins) { // PLX s
        switch(regs.TCU) {
        // PLX s E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FB_mX(regs &regs, pins &pins) { // XCE i
        switch(regs.TCU) {
        // XCE i E=0 M=0 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        u32 TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
        if (regs.E) {
            regs.P.X = regs.P.M = 1;
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
            regs.S = (regs.S & 0xFF) | 0x100;
        }
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FC_mX(regs &regs, pins &pins) { // JSR (a,x)
        switch(regs.TCU) {
        // JSR (a,x) E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.RW = 1;
        regs.TA = pins.D;
        pins.D = ((regs.PC) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 4
        pins.D = (regs.PC) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                break; }
            case 6: {// 7
        pins.PDV = 1;
        pins.Addr = regs.TA;
                break; }
            case 7: {// 8
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.PC = pins.D;
                break; }
            case 8: {// cleanup_custom
        regs.PC += (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FD_mX(regs &regs, pins &pins) { // SBC a,x
        switch(regs.TCU) {
        // SBC a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FE_mX(regs &regs, pins &pins) { // INC a,x
        switch(regs.TCU) {
        // INC a,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 5a
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        pins.PDV = 0;
        regs.TR += pins.D << 8;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFFFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 7: {// finish_rmw mem16 H
        pins.RW = 1; pins.PDV = 1;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 8: {// finish_rmw mem16 L
        pins.Addr--; if (pins.Addr < 0) { pins.Addr = 0xFFFF; pins.BA = (pins.BA - 1) & 0xFF; };
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 9: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FF_mX(regs &regs, pins &pins) { // SBC al,x
        switch(regs.TCU) {
        // SBC al,x E=0 M=0 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// finish_R16p
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.TR += pins.D << 8;
        // instruction code follows
        i32 data = (~regs.TR) & 0xFFFF;
        i32 result;
        if (!regs.P.D) result = regs.C + data + regs.P.C;
        else {
            result = (regs.C & 0x000F) + (data & 0x000F) + (regs.P.C);
            if (result <= 0x000F) result -= 0x0006;
            regs.P.C = +(result > 0x000F);
            result = (regs.C & 0x00F0) + (data & 0x00F0) + (regs.P.C << 4) + (result & 0x000F);
            if (result <= 0x00FF) result -= 0x0060;
            regs.P.C = +(result > 0x00FF);
            result = (regs.C & 0x0F00) + (data & 0x0F00) + (regs.P.C << 8) + (result & 0x00FF);
            if (result <= 0x0FFF) result -= 0x0600;
            regs.P.C = +(result > 0x0FFF);
            result = (regs.C & 0xF000) + (data & 0xF000) + (regs.P.C << 12) + (result & 0x0FFF);
        }
        regs.P.V = ((~(regs.C ^ data)) & (regs.C ^ result) & 0x8000) >> 15;
        if (regs.P.D && result <= 0xFFFF) result -= 0x6000;
        regs.P.C = +(result > 0xFFFF);
        regs.P.Z = +((result & 0xFFFF) == 0);
        regs.P.N = ((result) & 0x8000) >> 15;
        regs.C = (result & 0xFFFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_100_mX(regs &regs, pins &pins) { // S_RESET s
        switch(regs.TCU) {
        // S_RESET s E=0 M=0 X=1
            case 1: {// 3
        pins.RW = 0; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFFC); pins.BA = (0);
        regs.DBR = 0;
        regs.D = 0;
        regs.PBR = 0;
        regs.X &= 0xFF;
        regs.Y &= 0xFF;
        regs.E = 1;
        regs.P.M = regs.P.X = regs.P.I = 1; regs.P.C = 0;
        regs.P.D = 0;
        regs.STP = regs.WAI = 0;
        regs.S = 0x1FF;
                break; }
            case 6: {// 8
        regs.PC = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.PC += (pins.D << 8);
        pins.PDV = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_101_mX(regs &regs, pins &pins) { // S_ABORT s
        switch(regs.TCU) {
        // S_ABORT s E=0 M=0 X=1
            case 1: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFE8); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFE9); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_102_mX(regs &regs, pins &pins) { // S_IRQ s
        switch(regs.TCU) {
        // S_IRQ s E=0 M=0 X=1
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEE); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEF); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_103_mX(regs &regs, pins &pins) { // S_NMI s
        switch(regs.TCU) {
        // S_NMI s E=0 M=0 X=1
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEA); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEB); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_00_MX(regs &regs, pins &pins) { // BRK s
        switch(regs.TCU) {
        // BRK s E=0 M=1 X=1
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE6); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE7); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_01_MX(regs &regs, pins &pins) { // ORA (d,x)
        switch(regs.TCU) {
        // ORA (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_02_MX(regs &regs, pins &pins) { // COP s
        switch(regs.TCU) {
        // COP s E=0 M=1 X=1
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 3: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 6: {// 7
        pins.Addr = (0xFFE4); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 7: {// 8
        pins.Addr = (0xFFE5); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 8: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_03_MX(regs &regs, pins &pins) { // ORA d,s
        switch(regs.TCU) {
        // ORA d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_04_MX(regs &regs, pins &pins) { // TSB d
        switch(regs.TCU) {
        // TSB d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_05_MX(regs &regs, pins &pins) { // ORA d
        switch(regs.TCU) {
        // ORA d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_06_MX(regs &regs, pins &pins) { // ASL d
        switch(regs.TCU) {
        // ASL d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_07_MX(regs &regs, pins &pins) { // ORA [d]
        switch(regs.TCU) {
        // ORA [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_08_MX(regs &regs, pins &pins) { // PHP s
        switch(regs.TCU) {
        // PHP s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.P.v;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_09_MX(regs &regs, pins &pins) { // ORA #
        switch(regs.TCU) {
        // ORA # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0A_MX(regs &regs, pins &pins) { // ASL A
        switch(regs.TCU) {
        // ASL A E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0B_MX(regs &regs, pins &pins) { // PHD s
        switch(regs.TCU) {
        // PHD s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.D);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0C_MX(regs &regs, pins &pins) { // TSB a
        switch(regs.TCU) {
        // TSB a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0D_MX(regs &regs, pins &pins) { // ORA a
        switch(regs.TCU) {
        // ORA a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0E_MX(regs &regs, pins &pins) { // ASL a
        switch(regs.TCU) {
        // ASL a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0F_MX(regs &regs, pins &pins) { // ORA al
        switch(regs.TCU) {
        // ORA al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_10_MX(regs &regs, pins &pins) { // BPL r
        switch(regs.TCU) {
        // BPL r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_11_MX(regs &regs, pins &pins) { // ORA (d),y
        switch(regs.TCU) {
        // ORA (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_12_MX(regs &regs, pins &pins) { // ORA (d)
        switch(regs.TCU) {
        // ORA (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_13_MX(regs &regs, pins &pins) { // ORA (d,s),y
        switch(regs.TCU) {
        // ORA (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_14_MX(regs &regs, pins &pins) { // TRB d
        switch(regs.TCU) {
        // TRB d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_15_MX(regs &regs, pins &pins) { // ORA d,x
        switch(regs.TCU) {
        // ORA d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_16_MX(regs &regs, pins &pins) { // ASL d,x
        switch(regs.TCU) {
        // ASL d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_17_MX(regs &regs, pins &pins) { // ORA [d],y
        switch(regs.TCU) {
        // ORA [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_18_MX(regs &regs, pins &pins) { // CLC i
        switch(regs.TCU) {
        // CLC i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_19_MX(regs &regs, pins &pins) { // ORA a,y
        switch(regs.TCU) {
        // ORA a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1A_MX(regs &regs, pins &pins) { // INC A
        switch(regs.TCU) {
        // INC A E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1B_MX(regs &regs, pins &pins) { // TCS i
        switch(regs.TCU) {
        // TCS i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.C;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1C_MX(regs &regs, pins &pins) { // TRB a
        switch(regs.TCU) {
        // TRB a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1D_MX(regs &regs, pins &pins) { // ORA a,x
        switch(regs.TCU) {
        // ORA a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1E_MX(regs &regs, pins &pins) { // ASL a,x
        switch(regs.TCU) {
        // ASL a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1F_MX(regs &regs, pins &pins) { // ORA al,x
        switch(regs.TCU) {
        // ORA al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_20_MX(regs &regs, pins &pins) { // JSR a
        switch(regs.TCU) {
        // JSR a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.PDV = 0;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 6
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_21_MX(regs &regs, pins &pins) { // AND (d,x)
        switch(regs.TCU) {
        // AND (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_22_MX(regs &regs, pins &pins) { // JSL al
        switch(regs.TCU) {
        // JSL al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        regs.TA += pins.D << 8;
        pins.D = (regs.PBR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 5: {// 6
        pins.PDV = 1;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 6: {// 7
        regs.PBR = pins.D;
        pins.RW = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 7: {// 8
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_23_MX(regs &regs, pins &pins) { // AND d,s
        switch(regs.TCU) {
        // AND d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_24_MX(regs &regs, pins &pins) { // BIT d
        switch(regs.TCU) {
        // BIT d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_25_MX(regs &regs, pins &pins) { // AND d
        switch(regs.TCU) {
        // AND d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_26_MX(regs &regs, pins &pins) { // ROL d
        switch(regs.TCU) {
        // ROL d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_27_MX(regs &regs, pins &pins) { // AND [d]
        switch(regs.TCU) {
        // AND [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_28_MX(regs &regs, pins &pins) { // PLP s
        switch(regs.TCU) {
        // PLP s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.v = regs.TR;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_29_MX(regs &regs, pins &pins) { // AND #
        switch(regs.TCU) {
        // AND # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2A_MX(regs &regs, pins &pins) { // ROL A
        switch(regs.TCU) {
        // ROL A E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2B_MX(regs &regs, pins &pins) { // PLD s
        switch(regs.TCU) {
        // PLD s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.D = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2C_MX(regs &regs, pins &pins) { // BIT a
        switch(regs.TCU) {
        // BIT a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2D_MX(regs &regs, pins &pins) { // AND a
        switch(regs.TCU) {
        // AND a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2E_MX(regs &regs, pins &pins) { // ROL a
        switch(regs.TCU) {
        // ROL a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2F_MX(regs &regs, pins &pins) { // AND al
        switch(regs.TCU) {
        // AND al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_30_MX(regs &regs, pins &pins) { // BMI r
        switch(regs.TCU) {
        // BMI r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_31_MX(regs &regs, pins &pins) { // AND (d),y
        switch(regs.TCU) {
        // AND (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_32_MX(regs &regs, pins &pins) { // AND (d)
        switch(regs.TCU) {
        // AND (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_33_MX(regs &regs, pins &pins) { // AND (d,s),y
        switch(regs.TCU) {
        // AND (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_34_MX(regs &regs, pins &pins) { // BIT d,x
        switch(regs.TCU) {
        // BIT d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_35_MX(regs &regs, pins &pins) { // AND d,x
        switch(regs.TCU) {
        // AND d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_36_MX(regs &regs, pins &pins) { // ROL d,x
        switch(regs.TCU) {
        // ROL d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_37_MX(regs &regs, pins &pins) { // AND [d],y
        switch(regs.TCU) {
        // AND [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_38_MX(regs &regs, pins &pins) { // SEC i
        switch(regs.TCU) {
        // SEC i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_39_MX(regs &regs, pins &pins) { // AND a,y
        switch(regs.TCU) {
        // AND a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3A_MX(regs &regs, pins &pins) { // DEC A
        switch(regs.TCU) {
        // DEC A E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3B_MX(regs &regs, pins &pins) { // TSC i
        switch(regs.TCU) {
        // TSC i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.S);
        regs.P.Z = +((regs.S) == 0);
        regs.P.N = ((regs.S) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3C_MX(regs &regs, pins &pins) { // BIT a,x
        switch(regs.TCU) {
        // BIT a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3D_MX(regs &regs, pins &pins) { // AND a,x
        switch(regs.TCU) {
        // AND a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3E_MX(regs &regs, pins &pins) { // ROL a,x
        switch(regs.TCU) {
        // ROL a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3F_MX(regs &regs, pins &pins) { // AND al,x
        switch(regs.TCU) {
        // AND al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_40_MX(regs &regs, pins &pins) { // RTI s
        switch(regs.TCU) {
        // RTI s E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        pins.PDV = 1;
                break; }
            case 4: {// 5
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.P.v = pins.D;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x100;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA = pins.D;
                break; }
            case 6: {// 7
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA += pins.D << 8;
                break; }
            case 7: {// cleanup_custom
        regs.PC = regs.TA;
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_41_MX(regs &regs, pins &pins) { // EOR (d,x)
        switch(regs.TCU) {
        // EOR (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_42_MX(regs &regs, pins &pins) { // WDM i
        switch(regs.TCU) {
        // WDM i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_43_MX(regs &regs, pins &pins) { // EOR d,s
        switch(regs.TCU) {
        // EOR d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_44_MX(regs &regs, pins &pins) { // MVP xyc
        switch(regs.TCU) {
        // MVP xyc E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = (regs.X); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
                break; }
            case 7: {// cleanup_custom
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X - 1) & 0xFF;
        regs.Y = (regs.Y - 1) & 0xFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_45_MX(regs &regs, pins &pins) { // EOR d
        switch(regs.TCU) {
        // EOR d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_46_MX(regs &regs, pins &pins) { // LSR d
        switch(regs.TCU) {
        // LSR d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_47_MX(regs &regs, pins &pins) { // EOR [d]
        switch(regs.TCU) {
        // EOR [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_48_MX(regs &regs, pins &pins) { // PHA s
        switch(regs.TCU) {
        // PHA s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.C) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_49_MX(regs &regs, pins &pins) { // EOR #
        switch(regs.TCU) {
        // EOR # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4A_MX(regs &regs, pins &pins) { // LSR A
        switch(regs.TCU) {
        // LSR A E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4B_MX(regs &regs, pins &pins) { // PHK s
        switch(regs.TCU) {
        // PHK s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.PBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4C_MX(regs &regs, pins &pins) { // JMP a
        switch(regs.TCU) {
        // JMP a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4D_MX(regs &regs, pins &pins) { // EOR a
        switch(regs.TCU) {
        // EOR a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4E_MX(regs &regs, pins &pins) { // LSR a
        switch(regs.TCU) {
        // LSR a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4F_MX(regs &regs, pins &pins) { // EOR al
        switch(regs.TCU) {
        // EOR al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_50_MX(regs &regs, pins &pins) { // BVC r
        switch(regs.TCU) {
        // BVC r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_51_MX(regs &regs, pins &pins) { // EOR (d),y
        switch(regs.TCU) {
        // EOR (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_52_MX(regs &regs, pins &pins) { // EOR (d)
        switch(regs.TCU) {
        // EOR (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_53_MX(regs &regs, pins &pins) { // EOR (d,s),y
        switch(regs.TCU) {
        // EOR (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_54_MX(regs &regs, pins &pins) { // MVN xyc
        switch(regs.TCU) {
        // MVN xyc E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X + 1) & 0xFF;
        regs.Y = (regs.Y + 1) & 0xFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_55_MX(regs &regs, pins &pins) { // EOR d,x
        switch(regs.TCU) {
        // EOR d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_56_MX(regs &regs, pins &pins) { // LSR d,x
        switch(regs.TCU) {
        // LSR d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_57_MX(regs &regs, pins &pins) { // EOR [d],y
        switch(regs.TCU) {
        // EOR [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_58_MX(regs &regs, pins &pins) { // CLI i
        switch(regs.TCU) {
        // CLI i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_59_MX(regs &regs, pins &pins) { // EOR a,y
        switch(regs.TCU) {
        // EOR a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5A_MX(regs &regs, pins &pins) { // PHY s
        switch(regs.TCU) {
        // PHY s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.Y) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5B_MX(regs &regs, pins &pins) { // TCD i
        switch(regs.TCU) {
        // TCD i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.D = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5C_MX(regs &regs, pins &pins) { // JMP al
        switch(regs.TCU) {
        // JMP al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = regs.TA + (pins.D << 8);
                break; }
            case 4: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5D_MX(regs &regs, pins &pins) { // EOR a,x
        switch(regs.TCU) {
        // EOR a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5E_MX(regs &regs, pins &pins) { // LSR a,x
        switch(regs.TCU) {
        // LSR a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5F_MX(regs &regs, pins &pins) { // EOR al,x
        switch(regs.TCU) {
        // EOR al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_60_MX(regs &regs, pins &pins) { // RTS s
        switch(regs.TCU) {
        // RTS s E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_61_MX(regs &regs, pins &pins) { // ADC (d,x)
        switch(regs.TCU) {
        // ADC (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_62_MX(regs &regs, pins &pins) { // PER s
        switch(regs.TCU) {
        // PER s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
                break; }
            case 6: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_63_MX(regs &regs, pins &pins) { // ADC d,s
        switch(regs.TCU) {
        // ADC d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_64_MX(regs &regs, pins &pins) { // STZ d
        switch(regs.TCU) {
        // STZ d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_65_MX(regs &regs, pins &pins) { // ADC d
        switch(regs.TCU) {
        // ADC d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_66_MX(regs &regs, pins &pins) { // ROR d
        switch(regs.TCU) {
        // ROR d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_67_MX(regs &regs, pins &pins) { // ADC [d]
        switch(regs.TCU) {
        // ADC [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_68_MX(regs &regs, pins &pins) { // PLA s
        switch(regs.TCU) {
        // PLA s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_69_MX(regs &regs, pins &pins) { // ADC #
        switch(regs.TCU) {
        // ADC # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6A_MX(regs &regs, pins &pins) { // ROR A
        switch(regs.TCU) {
        // ROR A E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6B_MX(regs &regs, pins &pins) { // RTL s
        switch(regs.TCU) {
        // RTL s E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6C_MX(regs &regs, pins &pins) { // JMP (a)
        switch(regs.TCU) {
        // JMP (a) E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6D_MX(regs &regs, pins &pins) { // ADC a
        switch(regs.TCU) {
        // ADC a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6E_MX(regs &regs, pins &pins) { // ROR a
        switch(regs.TCU) {
        // ROR a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6F_MX(regs &regs, pins &pins) { // ADC al
        switch(regs.TCU) {
        // ADC al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_70_MX(regs &regs, pins &pins) { // BVS r
        switch(regs.TCU) {
        // BVS r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_71_MX(regs &regs, pins &pins) { // ADC (d),y
        switch(regs.TCU) {
        // ADC (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_72_MX(regs &regs, pins &pins) { // ADC (d)
        switch(regs.TCU) {
        // ADC (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_73_MX(regs &regs, pins &pins) { // ADC (d,s),y
        switch(regs.TCU) {
        // ADC (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_74_MX(regs &regs, pins &pins) { // STZ d,x
        switch(regs.TCU) {
        // STZ d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_75_MX(regs &regs, pins &pins) { // ADC d,x
        switch(regs.TCU) {
        // ADC d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_76_MX(regs &regs, pins &pins) { // ROR d,x
        switch(regs.TCU) {
        // ROR d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_77_MX(regs &regs, pins &pins) { // ADC [d],y
        switch(regs.TCU) {
        // ADC [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_78_MX(regs &regs, pins &pins) { // SEI i
        switch(regs.TCU) {
        // SEI i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_79_MX(regs &regs, pins &pins) { // ADC a,y
        switch(regs.TCU) {
        // ADC a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7A_MX(regs &regs, pins &pins) { // PLY s
        switch(regs.TCU) {
        // PLY s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7B_MX(regs &regs, pins &pins) { // TDC i
        switch(regs.TCU) {
        // TDC i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.D);
        regs.P.Z = +((regs.D) == 0);
        regs.P.N = ((regs.D) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7C_MX(regs &regs, pins &pins) { // JMP (a,x)
        switch(regs.TCU) {
        // JMP (a,x) E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        regs.TA = (regs.X + regs.TA) & 0xFFFF;
        pins.PDV = 0;
                break; }
            case 4:{
        pins.PDV = 1;
        pins.Addr = regs.TA; pins.BA = regs.PBR;
                break; }
            case 5:{
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7D_MX(regs &regs, pins &pins) { // ADC a,x
        switch(regs.TCU) {
        // ADC a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7E_MX(regs &regs, pins &pins) { // ROR a,x
        switch(regs.TCU) {
        // ROR a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7F_MX(regs &regs, pins &pins) { // ADC al,x
        switch(regs.TCU) {
        // ADC al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_80_MX(regs &regs, pins &pins) { // BRA r
        switch(regs.TCU) {
        // BRA r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_81_MX(regs &regs, pins &pins) { // STA (d,x)
        switch(regs.TCU) {
        // STA (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_82_MX(regs &regs, pins &pins) { // BRL rl
        switch(regs.TCU) {
        // BRL rl E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TA = (u32)(i16)(regs.TA + (pins.D << 8));
        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_83_MX(regs &regs, pins &pins) { // STA d,s
        switch(regs.TCU) {
        // STA d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_84_MX(regs &regs, pins &pins) { // STY d
        switch(regs.TCU) {
        // STY d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_85_MX(regs &regs, pins &pins) { // STA d
        switch(regs.TCU) {
        // STA d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_86_MX(regs &regs, pins &pins) { // STX d
        switch(regs.TCU) {
        // STX d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_87_MX(regs &regs, pins &pins) { // STA [d]
        switch(regs.TCU) {
        // STA [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_88_MX(regs &regs, pins &pins) { // DEY i
        switch(regs.TCU) {
        // DEY i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) - 1) & 0xFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_89_MX(regs &regs, pins &pins) { // BIT #
        switch(regs.TCU) {
        // BIT # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8A_MX(regs &regs, pins &pins) { // TXA i
        switch(regs.TCU) {
        // TXA i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.X) & 0xFF);
        regs.P.Z = +((regs.X & 0xFF) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8B_MX(regs &regs, pins &pins) { // PHB s
        switch(regs.TCU) {
        // PHB s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.DBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8C_MX(regs &regs, pins &pins) { // STY a
        switch(regs.TCU) {
        // STY a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8D_MX(regs &regs, pins &pins) { // STA a
        switch(regs.TCU) {
        // STA a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8E_MX(regs &regs, pins &pins) { // STX a
        switch(regs.TCU) {
        // STX a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8F_MX(regs &regs, pins &pins) { // STA al
        switch(regs.TCU) {
        // STA al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_90_MX(regs &regs, pins &pins) { // BCC r
        switch(regs.TCU) {
        // BCC r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_91_MX(regs &regs, pins &pins) { // STA (d),y
        switch(regs.TCU) {
        // STA (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_92_MX(regs &regs, pins &pins) { // STA (d)
        switch(regs.TCU) {
        // STA (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_93_MX(regs &regs, pins &pins) { // STA (d,s),y
        switch(regs.TCU) {
        // STA (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_94_MX(regs &regs, pins &pins) { // STY d,x
        switch(regs.TCU) {
        // STY d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_95_MX(regs &regs, pins &pins) { // STA d,x
        switch(regs.TCU) {
        // STA d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_96_MX(regs &regs, pins &pins) { // STX d,y
        switch(regs.TCU) {
        // STX d,y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_97_MX(regs &regs, pins &pins) { // STA [d],y
        switch(regs.TCU) {
        // STA [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_98_MX(regs &regs, pins &pins) { // TYA i
        switch(regs.TCU) {
        // TYA i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.Y) & 0xFF);
        regs.P.Z = +((regs.Y & 0xFF) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_99_MX(regs &regs, pins &pins) { // STA a,y
        switch(regs.TCU) {
        // STA a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9A_MX(regs &regs, pins &pins) { // TXS i
        switch(regs.TCU) {
        // TXS i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.X;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9B_MX(regs &regs, pins &pins) { // TXY i
        switch(regs.TCU) {
        // TXY i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.X) & 0xFF);
        regs.P.Z = +((regs.X & 0xFF) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9C_MX(regs &regs, pins &pins) { // STZ a
        switch(regs.TCU) {
        // STZ a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9D_MX(regs &regs, pins &pins) { // STA a,x
        switch(regs.TCU) {
        // STA a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9E_MX(regs &regs, pins &pins) { // STZ a,x
        switch(regs.TCU) {
        // STZ a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9F_MX(regs &regs, pins &pins) { // STA al,x
        switch(regs.TCU) {
        // STA al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A0_MX(regs &regs, pins &pins) { // LDY #
        switch(regs.TCU) {
        // LDY # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A1_MX(regs &regs, pins &pins) { // LDA (d,x)
        switch(regs.TCU) {
        // LDA (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A2_MX(regs &regs, pins &pins) { // LDX #
        switch(regs.TCU) {
        // LDX # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A3_MX(regs &regs, pins &pins) { // LDA d,s
        switch(regs.TCU) {
        // LDA d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A4_MX(regs &regs, pins &pins) { // LDY d
        switch(regs.TCU) {
        // LDY d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A5_MX(regs &regs, pins &pins) { // LDA d
        switch(regs.TCU) {
        // LDA d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A6_MX(regs &regs, pins &pins) { // LDX d
        switch(regs.TCU) {
        // LDX d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A7_MX(regs &regs, pins &pins) { // LDA [d]
        switch(regs.TCU) {
        // LDA [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A8_MX(regs &regs, pins &pins) { // TAY i
        switch(regs.TCU) {
        // TAY i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.C) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A9_MX(regs &regs, pins &pins) { // LDA #
        switch(regs.TCU) {
        // LDA # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AA_MX(regs &regs, pins &pins) { // TAX i
        switch(regs.TCU) {
        // TAX i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.C) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AB_MX(regs &regs, pins &pins) { // PLB s
        switch(regs.TCU) {
        // PLB s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AC_MX(regs &regs, pins &pins) { // LDY a
        switch(regs.TCU) {
        // LDY a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AD_MX(regs &regs, pins &pins) { // LDA a
        switch(regs.TCU) {
        // LDA a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AE_MX(regs &regs, pins &pins) { // LDX a
        switch(regs.TCU) {
        // LDX a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AF_MX(regs &regs, pins &pins) { // LDA al
        switch(regs.TCU) {
        // LDA al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B0_MX(regs &regs, pins &pins) { // BCS r
        switch(regs.TCU) {
        // BCS r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B1_MX(regs &regs, pins &pins) { // LDA (d),y
        switch(regs.TCU) {
        // LDA (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B2_MX(regs &regs, pins &pins) { // LDA (d)
        switch(regs.TCU) {
        // LDA (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B3_MX(regs &regs, pins &pins) { // LDA (d,s),y
        switch(regs.TCU) {
        // LDA (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B4_MX(regs &regs, pins &pins) { // LDY d,x
        switch(regs.TCU) {
        // LDY d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B5_MX(regs &regs, pins &pins) { // LDA d,x
        switch(regs.TCU) {
        // LDA d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B6_MX(regs &regs, pins &pins) { // LDX d,y
        switch(regs.TCU) {
        // LDX d,y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B7_MX(regs &regs, pins &pins) { // LDA [d],y
        switch(regs.TCU) {
        // LDA [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B8_MX(regs &regs, pins &pins) { // CLV i
        switch(regs.TCU) {
        // CLV i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.V = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B9_MX(regs &regs, pins &pins) { // LDA a,y
        switch(regs.TCU) {
        // LDA a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BA_MX(regs &regs, pins &pins) { // TSX i
        switch(regs.TCU) {
        // TSX i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X  = regs.S & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BB_MX(regs &regs, pins &pins) { // TYX i
        switch(regs.TCU) {
        // TYX i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.Y) & 0xFF);
        regs.P.Z = +((regs.Y & 0xFF) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BC_MX(regs &regs, pins &pins) { // LDY a,x
        switch(regs.TCU) {
        // LDY a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BD_MX(regs &regs, pins &pins) { // LDA a,x
        switch(regs.TCU) {
        // LDA a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BE_MX(regs &regs, pins &pins) { // LDX a,y
        switch(regs.TCU) {
        // LDX a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BF_MX(regs &regs, pins &pins) { // LDA al,x
        switch(regs.TCU) {
        // LDA al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C0_MX(regs &regs, pins &pins) { // CPY #
        switch(regs.TCU) {
        // CPY # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C1_MX(regs &regs, pins &pins) { // CMP (d,x)
        switch(regs.TCU) {
        // CMP (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C2_MX(regs &regs, pins &pins) { // REP #
        switch(regs.TCU) {
        // REP # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v &= (~regs.TR & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C3_MX(regs &regs, pins &pins) { // CMP d,s
        switch(regs.TCU) {
        // CMP d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C4_MX(regs &regs, pins &pins) { // CPY d
        switch(regs.TCU) {
        // CPY d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C5_MX(regs &regs, pins &pins) { // CMP d
        switch(regs.TCU) {
        // CMP d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C6_MX(regs &regs, pins &pins) { // DEC d
        switch(regs.TCU) {
        // DEC d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C7_MX(regs &regs, pins &pins) { // CMP [d]
        switch(regs.TCU) {
        // CMP [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C8_MX(regs &regs, pins &pins) { // INY i
        switch(regs.TCU) {
        // INY i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) + 1) & 0xFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C9_MX(regs &regs, pins &pins) { // CMP #
        switch(regs.TCU) {
        // CMP # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CA_MX(regs &regs, pins &pins) { // DEX i
        switch(regs.TCU) {
        // DEX i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) - 1) & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CB_MX(regs &regs, pins &pins) { // WAI i
        switch(regs.TCU) {
        // WAI i E=0 M=1 X=1
            case 1: {// 1
        regs.WAI = 1;
                break; }
            case 2: {// 2
        if (regs.WAI) {
            regs.TCU--;
            break;
        }
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 3: {// 3
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CC_MX(regs &regs, pins &pins) { // CPY a
        switch(regs.TCU) {
        // CPY a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CD_MX(regs &regs, pins &pins) { // CMP a
        switch(regs.TCU) {
        // CMP a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CE_MX(regs &regs, pins &pins) { // DEC a
        switch(regs.TCU) {
        // DEC a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CF_MX(regs &regs, pins &pins) { // CMP al
        switch(regs.TCU) {
        // CMP al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D0_MX(regs &regs, pins &pins) { // BNE r
        switch(regs.TCU) {
        // BNE r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 0;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D1_MX(regs &regs, pins &pins) { // CMP (d),y
        switch(regs.TCU) {
        // CMP (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D2_MX(regs &regs, pins &pins) { // CMP (d)
        switch(regs.TCU) {
        // CMP (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D3_MX(regs &regs, pins &pins) { // CMP (d,s),y
        switch(regs.TCU) {
        // CMP (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D4_MX(regs &regs, pins &pins) { // PEI s
        switch(regs.TCU) {
        // PEI s E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.D = regs.TR;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 7: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D5_MX(regs &regs, pins &pins) { // CMP d,x
        switch(regs.TCU) {
        // CMP d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D6_MX(regs &regs, pins &pins) { // DEC d,x
        switch(regs.TCU) {
        // DEC d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D7_MX(regs &regs, pins &pins) { // CMP [d],y
        switch(regs.TCU) {
        // CMP [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D8_MX(regs &regs, pins &pins) { // CLD i
        switch(regs.TCU) {
        // CLD i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D9_MX(regs &regs, pins &pins) { // CMP a,y
        switch(regs.TCU) {
        // CMP a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DA_MX(regs &regs, pins &pins) { // PHX s
        switch(regs.TCU) {
        // PHX s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.X) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DB_MX(regs &regs, pins &pins) { // STP i
        switch(regs.TCU) {
        // STP i E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// cleanup_custom
        regs.STP = 1;
        // Following is auto-generated code for instruction finish
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DC_MX(regs &regs, pins &pins) { // JML (a)
        switch(regs.TCU) {
        // JML (a) E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.PC = regs.TR + (pins.D << 8);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DD_MX(regs &regs, pins &pins) { // CMP a,x
        switch(regs.TCU) {
        // CMP a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DE_MX(regs &regs, pins &pins) { // DEC a,x
        switch(regs.TCU) {
        // DEC a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DF_MX(regs &regs, pins &pins) { // CMP al,x
        switch(regs.TCU) {
        // CMP al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E0_MX(regs &regs, pins &pins) { // CPX #
        switch(regs.TCU) {
        // CPX # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E1_MX(regs &regs, pins &pins) { // SBC (d,x)
        switch(regs.TCU) {
        // SBC (d,x) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E2_MX(regs &regs, pins &pins) { // SEP #
        switch(regs.TCU) {
        // SEP # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v |= regs.TR;
        if (regs.P.X) { regs.X &= 0xFF, regs.Y &= 0xFF; }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E3_MX(regs &regs, pins &pins) { // SBC d,s
        switch(regs.TCU) {
        // SBC d,s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E4_MX(regs &regs, pins &pins) { // CPX d
        switch(regs.TCU) {
        // CPX d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E5_MX(regs &regs, pins &pins) { // SBC d
        switch(regs.TCU) {
        // SBC d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E6_MX(regs &regs, pins &pins) { // INC d
        switch(regs.TCU) {
        // INC d E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E7_MX(regs &regs, pins &pins) { // SBC [d]
        switch(regs.TCU) {
        // SBC [d] E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E8_MX(regs &regs, pins &pins) { // INX i
        switch(regs.TCU) {
        // INX i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) + 1) & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E9_MX(regs &regs, pins &pins) { // SBC #
        switch(regs.TCU) {
        // SBC # E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EA_MX(regs &regs, pins &pins) { // NOP i
        switch(regs.TCU) {
        // NOP i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EB_MX(regs &regs, pins &pins) { // XBA i
        switch(regs.TCU) {
        // XBA i E=0 M=1 X=1
            case 1:{
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2:{
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >> 8) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EC_MX(regs &regs, pins &pins) { // CPX a
        switch(regs.TCU) {
        // CPX a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_ED_MX(regs &regs, pins &pins) { // SBC a
        switch(regs.TCU) {
        // SBC a E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EE_MX(regs &regs, pins &pins) { // INC a
        switch(regs.TCU) {
        // INC a E=0 M=1 X=1
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EF_MX(regs &regs, pins &pins) { // SBC al
        switch(regs.TCU) {
        // SBC al E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F0_MX(regs &regs, pins &pins) { // BEQ r
        switch(regs.TCU) {
        // BEQ r E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 1;
        regs.skipped_cycle = 0;
        regs.TCU++; regs.skipped_cycle++;           // skip cycle for no E
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F1_MX(regs &regs, pins &pins) { // SBC (d),y
        switch(regs.TCU) {
        // SBC (d),y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F2_MX(regs &regs, pins &pins) { // SBC (d)
        switch(regs.TCU) {
        // SBC (d) E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F3_MX(regs &regs, pins &pins) { // SBC (d,s),y
        switch(regs.TCU) {
        // SBC (d,s),y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F4_MX(regs &regs, pins &pins) { // PEA s
        switch(regs.TCU) {
        // PEA s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR;
                break; }
            case 5: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F5_MX(regs &regs, pins &pins) { // SBC d,x
        switch(regs.TCU) {
        // SBC d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F6_MX(regs &regs, pins &pins) { // INC d,x
        switch(regs.TCU) {
        // INC d,x E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F7_MX(regs &regs, pins &pins) { // SBC [d],y
        switch(regs.TCU) {
        // SBC [d],y E=0 M=1 X=1
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F8_MX(regs &regs, pins &pins) { // SED i
        switch(regs.TCU) {
        // SED i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F9_MX(regs &regs, pins &pins) { // SBC a,y
        switch(regs.TCU) {
        // SBC a,y E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FA_MX(regs &regs, pins &pins) { // PLX s
        switch(regs.TCU) {
        // PLX s E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FB_MX(regs &regs, pins &pins) { // XCE i
        switch(regs.TCU) {
        // XCE i E=0 M=1 X=1
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        u32 TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
        if (regs.E) {
            regs.P.X = regs.P.M = 1;
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
            regs.S = (regs.S & 0xFF) | 0x100;
        }
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FC_MX(regs &regs, pins &pins) { // JSR (a,x)
        switch(regs.TCU) {
        // JSR (a,x) E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.RW = 1;
        regs.TA = pins.D;
        pins.D = ((regs.PC) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 4
        pins.D = (regs.PC) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                break; }
            case 6: {// 7
        pins.PDV = 1;
        pins.Addr = regs.TA;
                break; }
            case 7: {// 8
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.PC = pins.D;
                break; }
            case 8: {// cleanup_custom
        regs.PC += (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FD_MX(regs &regs, pins &pins) { // SBC a,x
        switch(regs.TCU) {
        // SBC a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FE_MX(regs &regs, pins &pins) { // INC a,x
        switch(regs.TCU) {
        // INC a,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.RW = 1; pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FF_MX(regs &regs, pins &pins) { // SBC al,x
        switch(regs.TCU) {
        // SBC al,x E=0 M=1 X=1
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_100_MX(regs &regs, pins &pins) { // S_RESET s
        switch(regs.TCU) {
        // S_RESET s E=0 M=1 X=1
            case 1: {// 3
        pins.RW = 0; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFFC); pins.BA = (0);
        regs.DBR = 0;
        regs.D = 0;
        regs.PBR = 0;
        regs.X &= 0xFF;
        regs.Y &= 0xFF;
        regs.E = 1;
        regs.P.M = regs.P.X = regs.P.I = 1; regs.P.C = 0;
        regs.P.D = 0;
        regs.STP = regs.WAI = 0;
        regs.S = 0x1FF;
                break; }
            case 6: {// 8
        regs.PC = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.PC += (pins.D << 8);
        pins.PDV = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_101_MX(regs &regs, pins &pins) { // S_ABORT s
        switch(regs.TCU) {
        // S_ABORT s E=0 M=1 X=1
            case 1: {// 3
        regs.TR = regs.PC;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFE8); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFE9); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_102_MX(regs &regs, pins &pins) { // S_IRQ s
        switch(regs.TCU) {
        // S_IRQ s E=0 M=1 X=1
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEE); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEF); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_103_MX(regs &regs, pins &pins) { // S_NMI s
        switch(regs.TCU) {
        // S_NMI s E=0 M=1 X=1
            case 1: {// 3
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.RW = 1;
        pins.D = regs.PBR;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFEA); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFEB); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_00_E(regs &regs, pins &pins) { // BRK s
        switch(regs.TCU) {
        // BRK s E=1 M=0 X=0
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 4
        regs.TR = regs.PC;
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v | 0x38;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFFE); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFFF); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_01_E(regs &regs, pins &pins) { // ORA (d,x)
        switch(regs.TCU) {
        // ORA (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_02_E(regs &regs, pins &pins) { // COP s
        switch(regs.TCU) {
        // COP s E=1 M=0 X=0
        // instruction code follows
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 4
        regs.TR = regs.PC;
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v & 0xF7;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFF4); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 6: {// 8
        pins.Addr = (0xFFF5); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 7: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // instruction code ends
        regs.P.D = 0;
        regs.P.I = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_03_E(regs &regs, pins &pins) { // ORA d,s
        switch(regs.TCU) {
        // ORA d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_04_E(regs &regs, pins &pins) { // TSB d
        switch(regs.TCU) {
        // TSB d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_05_E(regs &regs, pins &pins) { // ORA d
        switch(regs.TCU) {
        // ORA d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_06_E(regs &regs, pins &pins) { // ASL d
        switch(regs.TCU) {
        // ASL d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_07_E(regs &regs, pins &pins) { // ORA [d]
        switch(regs.TCU) {
        // ORA [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_08_E(regs &regs, pins &pins) { // PHP s
        switch(regs.TCU) {
        // PHP s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.P.v;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_09_E(regs &regs, pins &pins) { // ORA #
        switch(regs.TCU) {
        // ORA # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0A_E(regs &regs, pins &pins) { // ASL A
        switch(regs.TCU) {
        // ASL A E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0B_E(regs &regs, pins &pins) { // PHD s
        switch(regs.TCU) {
        // PHD s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.D);
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
        regs.S = (regs.S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0C_E(regs &regs, pins &pins) { // TSB a
        switch(regs.TCU) {
        // TSB a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (regs.C | regs.TR) & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0D_E(regs &regs, pins &pins) { // ORA a
        switch(regs.TCU) {
        // ORA a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0E_E(regs &regs, pins &pins) { // ASL a
        switch(regs.TCU) {
        // ASL a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_0F_E(regs &regs, pins &pins) { // ORA al
        switch(regs.TCU) {
        // ORA al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_10_E(regs &regs, pins &pins) { // BPL r
        switch(regs.TCU) {
        // BPL r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 0;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_11_E(regs &regs, pins &pins) { // ORA (d),y
        switch(regs.TCU) {
        // ORA (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_12_E(regs &regs, pins &pins) { // ORA (d)
        switch(regs.TCU) {
        // ORA (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_13_E(regs &regs, pins &pins) { // ORA (d,s),y
        switch(regs.TCU) {
        // ORA (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_14_E(regs &regs, pins &pins) { // TRB d
        switch(regs.TCU) {
        // TRB d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_15_E(regs &regs, pins &pins) { // ORA d,x
        switch(regs.TCU) {
        // ORA d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_16_E(regs &regs, pins &pins) { // ASL d,x
        switch(regs.TCU) {
        // ASL d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_17_E(regs &regs, pins &pins) { // ORA [d],y
        switch(regs.TCU) {
        // ORA [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_18_E(regs &regs, pins &pins) { // CLC i
        switch(regs.TCU) {
        // CLC i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_19_E(regs &regs, pins &pins) { // ORA a,y
        switch(regs.TCU) {
        // ORA a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1A_E(regs &regs, pins &pins) { // INC A
        switch(regs.TCU) {
        // INC A E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1B_E(regs &regs, pins &pins) { // TCS i
        switch(regs.TCU) {
        // TCS i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.C;
        regs.S = (regs.S & 0xFF) + 0x100;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1C_E(regs &regs, pins &pins) { // TRB a
        switch(regs.TCU) {
        // TRB a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.Z = +((regs.TR & regs.C & 0xFF) == 0);
        regs.TR = (~regs.C) & regs.TR & 0xFF;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1D_E(regs &regs, pins &pins) { // ORA a,x
        switch(regs.TCU) {
        // ORA a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1E_E(regs &regs, pins &pins) { // ASL a,x
        switch(regs.TCU) {
        // ASL a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.RW = 1; pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = (regs.TR & 0x7F) << 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_1F_E(regs &regs, pins &pins) { // ORA al,x
        switch(regs.TCU) {
        // ORA al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.TR | regs.C) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_20_E(regs &regs, pins &pins) { // JSR a
        switch(regs.TCU) {
        // JSR a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.PDV = 0;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 6
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_21_E(regs &regs, pins &pins) { // AND (d,x)
        switch(regs.TCU) {
        // AND (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_22_E(regs &regs, pins &pins) { // JSL al
        switch(regs.TCU) {
        // JSL al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        regs.TA += pins.D << 8;
        pins.D = (regs.PBR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 5: {// 6
        pins.PDV = 1;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 6: {// 7
        regs.PBR = pins.D;
        pins.RW = 1;
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.D = ((regs.TR) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 7: {// 8
        pins.D = (regs.TR) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        regs.PC = regs.TA;
        // Following is auto-generated code for instruction finish
                break; }
            case 8: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_23_E(regs &regs, pins &pins) { // AND d,s
        switch(regs.TCU) {
        // AND d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_24_E(regs &regs, pins &pins) { // BIT d
        switch(regs.TCU) {
        // BIT d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_25_E(regs &regs, pins &pins) { // AND d
        switch(regs.TCU) {
        // AND d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_26_E(regs &regs, pins &pins) { // ROL d
        switch(regs.TCU) {
        // ROL d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_27_E(regs &regs, pins &pins) { // AND [d]
        switch(regs.TCU) {
        // AND [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_28_E(regs &regs, pins &pins) { // PLP s
        switch(regs.TCU) {
        // PLP s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.v = regs.TR | 0x30;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_29_E(regs &regs, pins &pins) { // AND #
        switch(regs.TCU) {
        // AND # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2A_E(regs &regs, pins &pins) { // ROL A
        switch(regs.TCU) {
        // ROL A E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2B_E(regs &regs, pins &pins) { // PLD s
        switch(regs.TCU) {
        // PLD s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        regs.S = (regs.S & 0xFF) + 0x100;
        // instruction code follows
        regs.D = regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x8000) >> 15;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2C_E(regs &regs, pins &pins) { // BIT a
        switch(regs.TCU) {
        // BIT a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2D_E(regs &regs, pins &pins) { // AND a
        switch(regs.TCU) {
        // AND a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2E_E(regs &regs, pins &pins) { // ROL a
        switch(regs.TCU) {
        // ROL a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_2F_E(regs &regs, pins &pins) { // AND al
        switch(regs.TCU) {
        // AND al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_30_E(regs &regs, pins &pins) { // BMI r
        switch(regs.TCU) {
        // BMI r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.N == 1;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_31_E(regs &regs, pins &pins) { // AND (d),y
        switch(regs.TCU) {
        // AND (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_32_E(regs &regs, pins &pins) { // AND (d)
        switch(regs.TCU) {
        // AND (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_33_E(regs &regs, pins &pins) { // AND (d,s),y
        switch(regs.TCU) {
        // AND (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_34_E(regs &regs, pins &pins) { // BIT d,x
        switch(regs.TCU) {
        // BIT d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_35_E(regs &regs, pins &pins) { // AND d,x
        switch(regs.TCU) {
        // AND d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_36_E(regs &regs, pins &pins) { // ROL d,x
        switch(regs.TCU) {
        // ROL d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_37_E(regs &regs, pins &pins) { // AND [d],y
        switch(regs.TCU) {
        // AND [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_38_E(regs &regs, pins &pins) { // SEC i
        switch(regs.TCU) {
        // SEC i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.C = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_39_E(regs &regs, pins &pins) { // AND a,y
        switch(regs.TCU) {
        // AND a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3A_E(regs &regs, pins &pins) { // DEC A
        switch(regs.TCU) {
        // DEC A E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3B_E(regs &regs, pins &pins) { // TSC i
        switch(regs.TCU) {
        // TSC i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.S);
        regs.P.Z = +((regs.S) == 0);
        regs.P.N = ((regs.S) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3C_E(regs &regs, pins &pins) { // BIT a,x
        switch(regs.TCU) {
        // BIT a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        regs.P.V = (regs.TR & 0x40) >> 6;
        regs.P.N = (regs.TR & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3D_E(regs &regs, pins &pins) { // AND a,x
        switch(regs.TCU) {
        // AND a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3E_E(regs &regs, pins &pins) { // ROL a,x
        switch(regs.TCU) {
        // ROL a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.RW = 1; pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        u32 carry = regs.P.C;
        regs.P.C = (regs.TR & 0x80) >> 7;
        regs.TR = ((regs.TR & 0x7F) << 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_3F_E(regs &regs, pins &pins) { // AND al,x
        switch(regs.TCU) {
        // AND al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & regs.TR & 0xFF;
        regs.P.Z = +((A) == 0);
        regs.P.N = ((A) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) + A;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_40_E(regs &regs, pins &pins) { // RTI s
        switch(regs.TCU) {
        // RTI s E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        pins.PDV = 1;
                break; }
            case 4: {// 5
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.P.v = pins.D | 0b00110000;
        if (regs.P.X) {
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
        }
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x100;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.TA = pins.D;
                break; }
            case 6: {// cleanup_custom
        regs.PC = regs.TA + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_41_E(regs &regs, pins &pins) { // EOR (d,x)
        switch(regs.TCU) {
        // EOR (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_42_E(regs &regs, pins &pins) { // WDM i
        switch(regs.TCU) {
        // WDM i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_43_E(regs &regs, pins &pins) { // EOR d,s
        switch(regs.TCU) {
        // EOR d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_44_E(regs &regs, pins &pins) { // MVP xyc
        switch(regs.TCU) {
        // MVP xyc E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = (regs.X); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = (regs.Y); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
                break; }
            case 7: {// cleanup_custom
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X - 1) & 0xFFFF;
        regs.Y = (regs.Y - 1) & 0xFFFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_45_E(regs &regs, pins &pins) { // EOR d
        switch(regs.TCU) {
        // EOR d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_46_E(regs &regs, pins &pins) { // LSR d
        switch(regs.TCU) {
        // LSR d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_47_E(regs &regs, pins &pins) { // EOR [d]
        switch(regs.TCU) {
        // EOR [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_48_E(regs &regs, pins &pins) { // PHA s
        switch(regs.TCU) {
        // PHA s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.C) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_49_E(regs &regs, pins &pins) { // EOR #
        switch(regs.TCU) {
        // EOR # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4A_E(regs &regs, pins &pins) { // LSR A
        switch(regs.TCU) {
        // LSR A E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4B_E(regs &regs, pins &pins) { // PHK s
        switch(regs.TCU) {
        // PHK s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.PBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4C_E(regs &regs, pins &pins) { // JMP a
        switch(regs.TCU) {
        // JMP a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4D_E(regs &regs, pins &pins) { // EOR a
        switch(regs.TCU) {
        // EOR a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4E_E(regs &regs, pins &pins) { // LSR a
        switch(regs.TCU) {
        // LSR a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_4F_E(regs &regs, pins &pins) { // EOR al
        switch(regs.TCU) {
        // EOR al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_50_E(regs &regs, pins &pins) { // BVC r
        switch(regs.TCU) {
        // BVC r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 0;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_51_E(regs &regs, pins &pins) { // EOR (d),y
        switch(regs.TCU) {
        // EOR (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_52_E(regs &regs, pins &pins) { // EOR (d)
        switch(regs.TCU) {
        // EOR (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_53_E(regs &regs, pins &pins) { // EOR (d,s),y
        switch(regs.TCU) {
        // EOR (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_54_E(regs &regs, pins &pins) { // MVN xyc
        switch(regs.TCU) {
        // MVN xyc E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.DBR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA = pins.D;
        pins.Addr = ((regs.X + regs.MD) & 0xFFFF); pins.BA = (regs.TA);
                break; }
            case 4: {// 5
        pins.RW = 1;
        pins.Addr = ((regs.Y + regs.MD) & 0xFFFF); pins.BA = (regs.DBR);
                break; }
            case 5: {// 6
        pins.RW = 0; pins.PDV = 0;
                break; }
            case 6: {// 7
        regs.C = (regs.C - 1) & 0xFFFF;
        regs.X = (regs.X + 1) & 0xFFFF;
        regs.Y = (regs.Y + 1) & 0xFFFF;
        if (regs.C != 0xFFFF) regs.PC = (regs.PC - 3) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_55_E(regs &regs, pins &pins) { // EOR d,x
        switch(regs.TCU) {
        // EOR d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_56_E(regs &regs, pins &pins) { // LSR d,x
        switch(regs.TCU) {
        // LSR d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_57_E(regs &regs, pins &pins) { // EOR [d],y
        switch(regs.TCU) {
        // EOR [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_58_E(regs &regs, pins &pins) { // CLI i
        switch(regs.TCU) {
        // CLI i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 0;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_59_E(regs &regs, pins &pins) { // EOR a,y
        switch(regs.TCU) {
        // EOR a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5A_E(regs &regs, pins &pins) { // PHY s
        switch(regs.TCU) {
        // PHY s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.Y) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5B_E(regs &regs, pins &pins) { // TCD i
        switch(regs.TCU) {
        // TCD i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.D = (regs.C);
        regs.P.Z = +((regs.C) == 0);
        regs.P.N = ((regs.C) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5C_E(regs &regs, pins &pins) { // JMP al
        switch(regs.TCU) {
        // JMP al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = regs.TA + (pins.D << 8);
                break; }
            case 4: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5D_E(regs &regs, pins &pins) { // EOR a,x
        switch(regs.TCU) {
        // EOR a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5E_E(regs &regs, pins &pins) { // LSR a,x
        switch(regs.TCU) {
        // LSR a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.RW = 1; pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.P.C = regs.TR & 1;
        regs.TR >>= 1;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_5F_E(regs &regs, pins &pins) { // EOR al,x
        switch(regs.TCU) {
        // EOR al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) ^ regs.TR;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_60_E(regs &regs, pins &pins) { // RTS s
        switch(regs.TCU) {
        // RTS s E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_61_E(regs &regs, pins &pins) { // ADC (d,x)
        switch(regs.TCU) {
        // ADC (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_62_E(regs &regs, pins &pins) { // PER s
        switch(regs.TCU) {
        // PER s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = (regs.PC + regs.TR + (pins.D << 8)) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.RW = 1; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 5: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR & 0xFF;
                break; }
            case 6: {// cleanup_custom
        regs.S = (regs.S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_63_E(regs &regs, pins &pins) { // ADC d,s
        switch(regs.TCU) {
        // ADC d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_64_E(regs &regs, pins &pins) { // STZ d
        switch(regs.TCU) {
        // STZ d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_65_E(regs &regs, pins &pins) { // ADC d
        switch(regs.TCU) {
        // ADC d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_66_E(regs &regs, pins &pins) { // ROR d
        switch(regs.TCU) {
        // ROR d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_67_E(regs &regs, pins &pins) { // ADC [d]
        switch(regs.TCU) {
        // ADC [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_68_E(regs &regs, pins &pins) { // PLA s
        switch(regs.TCU) {
        // PLA s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_69_E(regs &regs, pins &pins) { // ADC #
        switch(regs.TCU) {
        // ADC # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6A_E(regs &regs, pins &pins) { // ROR A
        switch(regs.TCU) {
        // ROR A E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
        regs.TR = regs.C & 0xFF;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        regs.C = (regs.C & 0xFF00) | (regs.TR & 0x00FF);
        // Following is auto-generated code for instruction finish
                break; }
            case 2: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6B_E(regs &regs, pins &pins) { // RTL s
        switch(regs.TCU) {
        // RTL s E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TA = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// 6
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
        regs.PC = (regs.TA + (pins.D << 8) + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        regs.S = (regs.S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6C_E(regs &regs, pins &pins) { // JMP (a)
        switch(regs.TCU) {
        // JMP (a) E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6D_E(regs &regs, pins &pins) { // ADC a
        switch(regs.TCU) {
        // ADC a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6E_E(regs &regs, pins &pins) { // ROR a
        switch(regs.TCU) {
        // ROR a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_6F_E(regs &regs, pins &pins) { // ADC al
        switch(regs.TCU) {
        // ADC al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_70_E(regs &regs, pins &pins) { // BVS r
        switch(regs.TCU) {
        // BVS r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.V == 1;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_71_E(regs &regs, pins &pins) { // ADC (d),y
        switch(regs.TCU) {
        // ADC (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_72_E(regs &regs, pins &pins) { // ADC (d)
        switch(regs.TCU) {
        // ADC (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_73_E(regs &regs, pins &pins) { // ADC (d,s),y
        switch(regs.TCU) {
        // ADC (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_74_E(regs &regs, pins &pins) { // STZ d,x
        switch(regs.TCU) {
        // STZ d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_75_E(regs &regs, pins &pins) { // ADC d,x
        switch(regs.TCU) {
        // ADC d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_76_E(regs &regs, pins &pins) { // ROR d,x
        switch(regs.TCU) {
        // ROR d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_77_E(regs &regs, pins &pins) { // ADC [d],y
        switch(regs.TCU) {
        // ADC [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_78_E(regs &regs, pins &pins) { // SEI i
        switch(regs.TCU) {
        // SEI i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2: {// cleanup_custom
        // instruction code follows
        regs.P.I = 1;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_79_E(regs &regs, pins &pins) { // ADC a,y
        switch(regs.TCU) {
        // ADC a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7A_E(regs &regs, pins &pins) { // PLY s
        switch(regs.TCU) {
        // PLY s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7B_E(regs &regs, pins &pins) { // TDC i
        switch(regs.TCU) {
        // TDC i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = (regs.D);
        regs.P.Z = +((regs.D) == 0);
        regs.P.N = ((regs.D) & 0x8000) >> 15;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7C_E(regs &regs, pins &pins) { // JMP (a,x)
        switch(regs.TCU) {
        // JMP (a,x) E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        regs.TA = (regs.X + regs.TA) & 0xFFFF;
        pins.PDV = 0;
                break; }
            case 4:{
        pins.PDV = 1;
        pins.Addr = regs.TA; pins.BA = regs.PBR;
                break; }
            case 5:{
        regs.TR = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// cleanup_custom
        regs.PC = regs.TR + (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7D_E(regs &regs, pins &pins) { // ADC a,x
        switch(regs.TCU) {
        // ADC a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7E_E(regs &regs, pins &pins) { // ROR a,x
        switch(regs.TCU) {
        // ROR a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.RW = 1; pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        u32 carry = regs.P.C << 7;
        regs.P.C = regs.TR & 0x1;
        regs.TR = ((regs.TR & 0xFF) >> 1) | carry;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_7F_E(regs &regs, pins &pins) { // ADC al,x
        switch(regs.TCU) {
        // ADC al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        u32 A = regs.C & 0xFF; regs.TR &= 0xFF;
        u32 result;
        if (!regs.P.D) result = A + regs.TR + regs.P.C;
        else {
            result = (A & 0x0F) + (regs.TR & 0x0F) + (regs.P.C << 0);
            if (result > 0x09) result += 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (regs.TR & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ regs.TR)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result > 0x9F) result += 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +(((result & 0xFF)) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_80_E(regs &regs, pins &pins) { // BRA r
        switch(regs.TCU) {
        // BRA r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = 1;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_81_E(regs &regs, pins &pins) { // STA (d,x)
        switch(regs.TCU) {
        // STA (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_82_E(regs &regs, pins &pins) { // BRL rl
        switch(regs.TCU) {
        // BRL rl E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TA = (u32)(i16)(regs.TA + (pins.D << 8));
        regs.PC = (regs.PC + regs.TA) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_83_E(regs &regs, pins &pins) { // STA d,s
        switch(regs.TCU) {
        // STA d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_84_E(regs &regs, pins &pins) { // STY d
        switch(regs.TCU) {
        // STY d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_85_E(regs &regs, pins &pins) { // STA d
        switch(regs.TCU) {
        // STA d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_86_E(regs &regs, pins &pins) { // STX d
        switch(regs.TCU) {
        // STX d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_87_E(regs &regs, pins &pins) { // STA [d]
        switch(regs.TCU) {
        // STA [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_88_E(regs &regs, pins &pins) { // DEY i
        switch(regs.TCU) {
        // DEY i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) - 1) & 0xFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_89_E(regs &regs, pins &pins) { // BIT #
        switch(regs.TCU) {
        // BIT # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.P.Z = +((regs.C & regs.TR & 0xFF) == 0);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8A_E(regs &regs, pins &pins) { // TXA i
        switch(regs.TCU) {
        // TXA i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.X) & 0xFF);
        regs.P.Z = +((regs.X & 0xFF) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8B_E(regs &regs, pins &pins) { // PHB s
        switch(regs.TCU) {
        // PHB s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.DBR) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 3: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8C_E(regs &regs, pins &pins) { // STY a
        switch(regs.TCU) {
        // STY a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8D_E(regs &regs, pins &pins) { // STA a
        switch(regs.TCU) {
        // STA a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8E_E(regs &regs, pins &pins) { // STX a
        switch(regs.TCU) {
        // STX a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_8F_E(regs &regs, pins &pins) { // STA al
        switch(regs.TCU) {
        // STA al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_90_E(regs &regs, pins &pins) { // BCC r
        switch(regs.TCU) {
        // BCC r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 0;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_91_E(regs &regs, pins &pins) { // STA (d),y
        switch(regs.TCU) {
        // STA (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_92_E(regs &regs, pins &pins) { // STA (d)
        switch(regs.TCU) {
        // STA (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_93_E(regs &regs, pins &pins) { // STA (d,s),y
        switch(regs.TCU) {
        // STA (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_94_E(regs &regs, pins &pins) { // STY d,x
        switch(regs.TCU) {
        // STY d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.Y & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_95_E(regs &regs, pins &pins) { // STA d,x
        switch(regs.TCU) {
        // STA d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_96_E(regs &regs, pins &pins) { // STX d,y
        switch(regs.TCU) {
        // STX d,y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFF); pins.BA = (0);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = regs.X & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_97_E(regs &regs, pins &pins) { // STA [d],y
        switch(regs.TCU) {
        // STA [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_98_E(regs &regs, pins &pins) { // TYA i
        switch(regs.TCU) {
        // TYA i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.Y) & 0xFF);
        regs.P.Z = +((regs.Y & 0xFF) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_99_E(regs &regs, pins &pins) { // STA a,y
        switch(regs.TCU) {
        // STA a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9A_E(regs &regs, pins &pins) { // TXS i
        switch(regs.TCU) {
        // TXS i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.S = regs.X;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9B_E(regs &regs, pins &pins) { // TXY i
        switch(regs.TCU) {
        // TXY i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.X) & 0xFF);
        regs.P.Z = +((regs.X & 0xFF) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9C_E(regs &regs, pins &pins) { // STZ a
        switch(regs.TCU) {
        // STZ a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
        pins.RW = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9D_E(regs &regs, pins &pins) { // STA a,x
        switch(regs.TCU) {
        // STA a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9E_E(regs &regs, pins &pins) { // STZ a,x
        switch(regs.TCU) {
        // STZ a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = 0;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_9F_E(regs &regs, pins &pins) { // STA al,x
        switch(regs.TCU) {
        // STA al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
        pins.RW = 1;
        // instruction code follows
        // #STA
        regs.TR = regs.C & 0xFF;
        // instruction code ends
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 5: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A0_E(regs &regs, pins &pins) { // LDY #
        switch(regs.TCU) {
        // LDY # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A1_E(regs &regs, pins &pins) { // LDA (d,x)
        switch(regs.TCU) {
        // LDA (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A2_E(regs &regs, pins &pins) { // LDX #
        switch(regs.TCU) {
        // LDX # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A3_E(regs &regs, pins &pins) { // LDA d,s
        switch(regs.TCU) {
        // LDA d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A4_E(regs &regs, pins &pins) { // LDY d
        switch(regs.TCU) {
        // LDY d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A5_E(regs &regs, pins &pins) { // LDA d
        switch(regs.TCU) {
        // LDA d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A6_E(regs &regs, pins &pins) { // LDX d
        switch(regs.TCU) {
        // LDX d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A7_E(regs &regs, pins &pins) { // LDA [d]
        switch(regs.TCU) {
        // LDA [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A8_E(regs &regs, pins &pins) { // TAY i
        switch(regs.TCU) {
        // TAY i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.C) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_A9_E(regs &regs, pins &pins) { // LDA #
        switch(regs.TCU) {
        // LDA # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AA_E(regs &regs, pins &pins) { // TAX i
        switch(regs.TCU) {
        // TAX i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.C) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AB_E(regs &regs, pins &pins) { // PLB s
        switch(regs.TCU) {
        // PLB s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.DBR = ((regs.DBR) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AC_E(regs &regs, pins &pins) { // LDY a
        switch(regs.TCU) {
        // LDY a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AD_E(regs &regs, pins &pins) { // LDA a
        switch(regs.TCU) {
        // LDA a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AE_E(regs &regs, pins &pins) { // LDX a
        switch(regs.TCU) {
        // LDX a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_AF_E(regs &regs, pins &pins) { // LDA al
        switch(regs.TCU) {
        // LDA al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B0_E(regs &regs, pins &pins) { // BCS r
        switch(regs.TCU) {
        // BCS r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.C == 1;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B1_E(regs &regs, pins &pins) { // LDA (d),y
        switch(regs.TCU) {
        // LDA (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B2_E(regs &regs, pins &pins) { // LDA (d)
        switch(regs.TCU) {
        // LDA (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B3_E(regs &regs, pins &pins) { // LDA (d,s),y
        switch(regs.TCU) {
        // LDA (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B4_E(regs &regs, pins &pins) { // LDY d,x
        switch(regs.TCU) {
        // LDY d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B5_E(regs &regs, pins &pins) { // LDA d,x
        switch(regs.TCU) {
        // LDA d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B6_E(regs &regs, pins &pins) { // LDX d,y
        switch(regs.TCU) {
        // LDX d,y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.Y + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B7_E(regs &regs, pins &pins) { // LDA [d],y
        switch(regs.TCU) {
        // LDA [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B8_E(regs &regs, pins &pins) { // CLV i
        switch(regs.TCU) {
        // CLV i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.V = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_B9_E(regs &regs, pins &pins) { // LDA a,y
        switch(regs.TCU) {
        // LDA a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BA_E(regs &regs, pins &pins) { // TSX i
        switch(regs.TCU) {
        // TSX i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X  = regs.S & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BB_E(regs &regs, pins &pins) { // TYX i
        switch(regs.TCU) {
        // TYX i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.Y) & 0xFF);
        regs.P.Z = +((regs.Y & 0xFF) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BC_E(regs &regs, pins &pins) { // LDY a,x
        switch(regs.TCU) {
        // LDY a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.Y = ((regs.Y) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BD_E(regs &regs, pins &pins) { // LDA a,x
        switch(regs.TCU) {
        // LDA a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BE_E(regs &regs, pins &pins) { // LDX a,y
        switch(regs.TCU) {
        // LDX a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_BF_E(regs &regs, pins &pins) { // LDA al,x
        switch(regs.TCU) {
        // LDA al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.C = ((regs.C) & 0xFF00) + ((regs.TR) & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C0_E(regs &regs, pins &pins) { // CPY #
        switch(regs.TCU) {
        // CPY # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C1_E(regs &regs, pins &pins) { // CMP (d,x)
        switch(regs.TCU) {
        // CMP (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C2_E(regs &regs, pins &pins) { // REP #
        switch(regs.TCU) {
        // REP # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v = ((regs.P.v | 0x30) & (~(regs.TR | 0x30) & 0xFF));
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C3_E(regs &regs, pins &pins) { // CMP d,s
        switch(regs.TCU) {
        // CMP d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C4_E(regs &regs, pins &pins) { // CPY d
        switch(regs.TCU) {
        // CPY d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C5_E(regs &regs, pins &pins) { // CMP d
        switch(regs.TCU) {
        // CMP d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C6_E(regs &regs, pins &pins) { // DEC d
        switch(regs.TCU) {
        // DEC d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C7_E(regs &regs, pins &pins) { // CMP [d]
        switch(regs.TCU) {
        // CMP [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C8_E(regs &regs, pins &pins) { // INY i
        switch(regs.TCU) {
        // INY i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.Y = ((regs.Y) + 1) & 0xFF;
        regs.P.Z = +((regs.Y) == 0);
        regs.P.N = ((regs.Y) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_C9_E(regs &regs, pins &pins) { // CMP #
        switch(regs.TCU) {
        // CMP # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CA_E(regs &regs, pins &pins) { // DEX i
        switch(regs.TCU) {
        // DEX i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) - 1) & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CB_E(regs &regs, pins &pins) { // WAI i
        switch(regs.TCU) {
        // WAI i E=1 M=0 X=0
            case 1: {// 1
        regs.WAI = 1;
                break; }
            case 2: {// 2
        if (regs.WAI) {
            regs.TCU--;
            break;
        }
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 3: {// 3
        regs.PC = (regs.PC + 1) & 0xFFFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CC_E(regs &regs, pins &pins) { // CPY a
        switch(regs.TCU) {
        // CPY a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.Y & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CD_E(regs &regs, pins &pins) { // CMP a
        switch(regs.TCU) {
        // CMP a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CE_E(regs &regs, pins &pins) { // DEC a
        switch(regs.TCU) {
        // DEC a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_CF_E(regs &regs, pins &pins) { // CMP al
        switch(regs.TCU) {
        // CMP al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D0_E(regs &regs, pins &pins) { // BNE r
        switch(regs.TCU) {
        // BNE r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 0;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D1_E(regs &regs, pins &pins) { // CMP (d),y
        switch(regs.TCU) {
        // CMP (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D2_E(regs &regs, pins &pins) { // CMP (d)
        switch(regs.TCU) {
        // CMP (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D3_E(regs &regs, pins &pins) { // CMP (d,s),y
        switch(regs.TCU) {
        // CMP (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D4_E(regs &regs, pins &pins) { // PEI s
        switch(regs.TCU) {
        // PEI s E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.D = regs.TR;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 7: {// cleanup_custom
        regs.S = (regs.S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D5_E(regs &regs, pins &pins) { // CMP d,x
        switch(regs.TCU) {
        // CMP d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D6_E(regs &regs, pins &pins) { // DEC d,x
        switch(regs.TCU) {
        // DEC d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D7_E(regs &regs, pins &pins) { // CMP [d],y
        switch(regs.TCU) {
        // CMP [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D8_E(regs &regs, pins &pins) { // CLD i
        switch(regs.TCU) {
        // CLD i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 0;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_D9_E(regs &regs, pins &pins) { // CMP a,y
        switch(regs.TCU) {
        // CMP a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DA_E(regs &regs, pins &pins) { // PHX s
        switch(regs.TCU) {
        // PHX s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
        pins.RW = 1; pins.PDV = 1;
        // instruction code follows
        regs.TR = (regs.X) & 0xFF;
        // instruction code ends
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR & 0xFF00) >> 8;
                break; }
            case 3:{
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 4: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DB_E(regs &regs, pins &pins) { // STP i
        switch(regs.TCU) {
        // STP i E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// cleanup_custom
        regs.STP = 1;
        // Following is auto-generated code for instruction finish
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DC_E(regs &regs, pins &pins) { // JML (a)
        switch(regs.TCU) {
        // JML (a) E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = regs.TA + (pins.D << 8); pins.BA = 0;
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.PC = regs.TR + (pins.D << 8);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// cleanup_custom
        regs.PBR = pins.D;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DD_E(regs &regs, pins &pins) { // CMP a,x
        switch(regs.TCU) {
        // CMP a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DE_E(regs &regs, pins &pins) { // DEC a,x
        switch(regs.TCU) {
        // DEC a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.RW = 1; pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = ((regs.TR) - 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_DF_E(regs &regs, pins &pins) { // CMP al,x
        switch(regs.TCU) {
        // CMP al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.C & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E0_E(regs &regs, pins &pins) { // CPX #
        switch(regs.TCU) {
        // CPX # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E1_E(regs &regs, pins &pins) { // SBC (d,x)
        switch(regs.TCU) {
        // SBC (d,x) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        regs.TA = (regs.TA + regs.D + regs.X) & 0xFFFF;
                break; }
            case 4: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// 5
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E2_E(regs &regs, pins &pins) { // SEP #
        switch(regs.TCU) {
        // SEP # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 2a for REP/SEP
        regs.TR = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.P.v = regs.P.v | 0x30 | regs.TR;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E3_E(regs &regs, pins &pins) { // SBC d,s
        switch(regs.TCU) {
        // SBC d,s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E4_E(regs &regs, pins &pins) { // CPX d
        switch(regs.TCU) {
        // CPX d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E5_E(regs &regs, pins &pins) { // SBC d
        switch(regs.TCU) {
        // SBC d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.Addr = ((regs.D + pins.D) & 0xFFFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E6_E(regs &regs, pins &pins) { // INC d
        switch(regs.TCU) {
        // INC d E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.D) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E7_E(regs &regs, pins &pins) { // SBC [d]
        switch(regs.TCU) {
        // SBC [d] E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = (regs.D + regs.TA & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 5: {// 5
        regs.TA += pins.D << 8;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA > 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E8_E(regs &regs, pins &pins) { // INX i
        switch(regs.TCU) {
        // INX i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.X = ((regs.X) + 1) & 0xFF;
        regs.P.Z = +((regs.X) == 0);
        regs.P.N = ((regs.X) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_E9_E(regs &regs, pins &pins) { // SBC #
        switch(regs.TCU) {
        // SBC # E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EA_E(regs &regs, pins &pins) { // NOP i
        switch(regs.TCU) {
        // NOP i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EB_E(regs &regs, pins &pins) { // XBA i
        switch(regs.TCU) {
        // XBA i E=1 M=0 X=0
            case 1:{
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
                break; }
            case 2:{
                break; }
            case 3: {// cleanup_custom
        // instruction code follows
        regs.C = ((regs.C << 8) & 0xFF00) + ((regs.C >> 8) & 0xFF);
        regs.P.Z = +((regs.C & 0xFF) == 0);
        regs.P.N = ((regs.C & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EC_E(regs &regs, pins &pins) { // CPX a
        switch(regs.TCU) {
        // CPX a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = (regs.X & 0xFF) - regs.TR;
        regs.P.C = +(regs.TR >= 0);
        regs.P.Z = +((regs.TR & 0xFF) == 0);
        regs.P.N = ((regs.TR & 0xFF) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_ED_E(regs &regs, pins &pins) { // SBC a
        switch(regs.TCU) {
        // SBC a E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.Addr = (regs.TA + (pins.D << 8)); pins.BA = (regs.DBR);
                break; }
            case 4: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EE_E(regs &regs, pins &pins) { // INC a
        switch(regs.TCU) {
        // INC a E=1 M=0 X=0
        //case AM.Ad
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = (regs.TA); pins.BA = (regs.DBR);
                break; }
            case 4: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 5: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 6: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_EF_E(regs &regs, pins &pins) { // SBC al
        switch(regs.TCU) {
        // SBC al E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = (regs.TA); pins.BA = (pins.D);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F0_E(regs &regs, pins &pins) { // BEQ r
        switch(regs.TCU) {
        // BEQ r E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TR = regs.P.Z == 1;
        regs.skipped_cycle = 0;
        if (!regs.TR) { regs.TCU++; regs.skipped_cycle++; } // skip cycle if NOT taken
                break; }
            case 2: {// 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// 2b
        if (regs.skipped_cycle == 1) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
                break; }
            case 4: {// cleanup_custom
        if (regs.skipped_cycle == 2) { regs.TA = pins.D; pins.RW = 0; pins.PDV = 0; } 
        if (regs.TR) regs.PC = (regs.PC + ((u32)(i8)(regs.TA))) & 0xFFFF;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F1_E(regs &regs, pins &pins) { // SBC (d),y
        switch(regs.TCU) {
        // SBC (d),y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + (regs.Y & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 5: {// 4a
        regs.TA += pins.D << 8;
        pins.Addr = (pins.D << 8) + (regs.TR & 0xFF); pins.BA = regs.DBR;
        pins.PDV = 0;
                break; }
            case 6: {// 5
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TR = regs.DBR;
        regs.TA += regs.Y;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F2_E(regs &regs, pins &pins) { // SBC (d)
        switch(regs.TCU) {
        // SBC (d) E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        pins.Addr = ((regs.TA + (pins.D << 8))); pins.BA = (regs.DBR);
                break; }
            case 6: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F3_E(regs &regs, pins &pins) { // SBC (d,s),y
        switch(regs.TCU) {
        // SBC (d,s),y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.PDV = 0;
        regs.TA = (pins.D + regs.S) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (0);
                break; }
            case 4: {// 5
        regs.TR = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        regs.TA = (regs.TR + (pins.D << 8) + regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.PDV = 0;
                break; }
            case 6: {// 7
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F4_E(regs &regs, pins &pins) { // PEA s
        switch(regs.TCU) {
        // PEA s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TR = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
                break; }
            case 4: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        pins.D = regs.TR;
                break; }
            case 5: {// cleanup_custom
        regs.S = (regs.S & 0xFF) + 0x100;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F5_E(regs &regs, pins &pins) { // SBC d,x
        switch(regs.TCU) {
        // SBC d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F6_E(regs &regs, pins &pins) { // INC d,x
        switch(regs.TCU) {
        // INC d,x E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
                break; }
            case 4: {// 4
        pins.PDV = 1;
        pins.Addr = ((regs.TA + regs.X + regs.D) & 0xFF); pins.BA = (0);
                break; }
            case 5: {// fetch_rmw_8or16 8
        regs.TR = pins.D;
        pins.RW = 1; pins.PDV = 0;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F7_E(regs &regs, pins &pins) { // SBC [d],y
        switch(regs.TCU) {
        // SBC [d],y E=1 M=0 X=0
            case 1: {// fetch_D0_and_skip_cycle 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        if ((regs.D & 0xFF) == 0) { regs.skipped_cycle = 1; regs.TCU++; }
                break; }
            case 2: {// fetch_D0_and_skip_cycle 2a
        regs.TA = pins.D;
        pins.PDV = 0;
                break; }
            case 3: {// fetch_D0_and_skip_cycle 3
        if (regs.skipped_cycle) {
            regs.TA = pins.D;
            pins.PDV = 0;
        }
        pins.PDV = 1;
        pins.Addr = ((regs.D + regs.TA) & 0xFFFF); pins.BA = (0);
                break; }
            case 4: {// 4
        regs.TA = pins.D;
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 5: {// 5
        regs.TA = (regs.TA + (pins.D << 8) + regs.Y);
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
                break; }
            case 6: {// 6
        regs.TR = pins.D;
        if (regs.TA >= 0x10000) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 7: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F8_E(regs &regs, pins &pins) { // SED i
        switch(regs.TCU) {
        // SED i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        regs.P.D = 1;
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_F9_E(regs &regs, pins &pins) { // SBC a,y
        switch(regs.TCU) {
        // SBC a,y E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.Y) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.Y ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.Y);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FA_E(regs &regs, pins &pins) { // PLX s
        switch(regs.TCU) {
        // PLX s E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        pins.PDV = 0;
                break; }
            case 2: {// 3
                break; }
            case 3: {// 4
        pins.PDV = 1;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 4: {// 4a
        regs.TR = pins.D;
        regs.S = (regs.S + 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.Addr = regs.S; pins.BA = 0;
                break; }
            case 5: {// cleanup_custom
        regs.TR += (pins.D << 8);
        // instruction code follows
        regs.X = ((regs.X) & 0xFF00) + (regs.TR & 0xFF);
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FB_E(regs &regs, pins &pins) { // XCE i
        switch(regs.TCU) {
        // XCE i E=1 M=0 X=0
            case 1: {// 2
        pins.PDV = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        // instruction code follows
        u32 TMP = regs.P.C; regs.P.C = regs.E; regs.E = TMP;
        if (regs.E) {
            regs.P.X = regs.P.M = 1;
            regs.X &= 0xFF;
            regs.Y &= 0xFF;
            regs.S = (regs.S & 0xFF) | 0x100;
        }
        // instruction code ends
                break; }
            case 2: {// cleanup_custom
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.PDV = 1;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FC_E(regs &regs, pins &pins) { // JSR (a,x)
        switch(regs.TCU) {
        // JSR (a,x) E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        pins.RW = 1;
        regs.TA = pins.D;
        pins.D = ((regs.PC) & 0xFF00) >> 8;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 4
        pins.D = (regs.PC) & 0xFF;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 5
        pins.RW = 0;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 5: {// 6
        pins.PDV = 0;
        regs.TA = (regs.TA + regs.X + (pins.D << 8)) & 0xFFFF;
                break; }
            case 6: {// 7
        pins.PDV = 1;
        pins.Addr = regs.TA;
                break; }
            case 7: {// 8
        pins.Addr = (pins.Addr + 1) & 0xFFFF;
        regs.PC = pins.D;
                break; }
            case 8: {// cleanup_custom
        regs.PC += (pins.D << 8);
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FD_E(regs &regs, pins &pins) { // SBC a,x
        switch(regs.TCU) {
        // SBC a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.skipped_cycle = 0;
        regs.TR = regs.TA + ((regs.X) & 0xFF);
        if (regs.TR < 0x100) { regs.skipped_cycle = 1; regs.TCU++; } 
                break; }
            case 3: {// 3a
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += pins.D << 8;
        pins.Addr = ((pins.D << 8) + (regs.TA + (regs.X ) & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 4
        if (regs.skipped_cycle) regs.TA += pins.D << 8;
        regs.TA += (regs.X);
        regs.TR = regs.DBR;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
        pins.PDV = 1;
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FE_E(regs &regs, pins &pins) { // INC a,x
        switch(regs.TCU) {
        // INC a,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        pins.PDV = 0;
        regs.TR = regs.DBR;
        regs.TA += (pins.D << 8) + regs.X;
        if (regs.TA > 0xFFFF) { regs.TA -= 0x10000; regs.TR = (regs.TR + 1) & 0xFF; }
        pins.Addr = ((pins.D << 8) + (regs.TA & 0xFF)); pins.BA = (regs.DBR);
                break; }
            case 4: {// 5
        pins.PDV = 1;
        pins.Addr = (regs.TA); pins.BA = (regs.TR);
                break; }
            case 5: {// 6
        pins.RW = 1; pins.PDV = 0;
        regs.TR = pins.D;
        // instruction code follows
        regs.TR = ((regs.TR) + 1) & 0xFF;
        regs.P.Z = +((regs.TR) == 0);
        regs.P.N = ((regs.TR) & 0x80) >> 7;
        // instruction code ends
                break; }
            case 6: {// finish_rmw mem8
        pins.PDV = 1;
        pins.D = regs.TR & 0xFF;
        // Following is auto-generated code for instruction finish
                break; }
            case 7: {// cleanup
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        pins.RW = 0;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_FF_E(regs &regs, pins &pins) { // SBC al,x
        switch(regs.TCU) {
        // SBC al,x E=1 M=0 X=0
            case 1: {// 2
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 2: {// 3
        regs.TA = pins.D;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 3: {// 4
        regs.TA += pins.D << 8;
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
                break; }
            case 4: {// 5
        regs.TA += (pins.D << 16) + regs.X;
        pins.Addr = (regs.TA & 0xFFFF); pins.BA = ((regs.TA >> 16) & 0xFF);
                break; }
            case 5: {// cleanup_custom
        regs.TR = pins.D;
        // instruction code follows
        i32 A = regs.C & 0xFF; i32 data = (~regs.TR) & 0xFF;
        i32 result;
        if (!regs.P.D) result = data + A + regs.P.C;
        else {
            result = (A & 0x0F) + (data & 0x0F) + (regs.P.C);
            if (result <= 0x0F) result -= 0x06;
            regs.P.C = +(result > 0x0F);
            result = (A & 0xF0) + (data & 0xF0) + (regs.P.C << 4) + (result & 0x0F);
        }
        regs.P.V = ((~(A ^ data)) & (A ^ result) & 0x80) >> 7;
        if (regs.P.D && result <= 0xFF) result -= 0x60;
        regs.P.C = +(result > 0xFF);
        regs.P.Z = +((result & 0xFF) == 0);
        regs.P.N = ((result) & 0x80) >> 7;
        regs.C = (regs.C & 0xFF00) | (result & 0xFF);
        // instruction code ends
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_100_E(regs &regs, pins &pins) { // S_RESET s
        switch(regs.TCU) {
        // S_RESET s E=1 M=0 X=0
            case 1: {// 3
        pins.RW = 0; pins.PDV = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 2: {// 4
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 3: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 4: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
                break; }
            case 5: {// 7
        pins.Addr = (0xFFFC); pins.BA = (0);
        regs.DBR = 0;
        regs.D = 0;
        regs.PBR = 0;
        regs.X &= 0xFF;
        regs.Y &= 0xFF;
        regs.E = 1;
        regs.P.M = regs.P.X = regs.P.I = 1; regs.P.C = 0;
        regs.P.D = 0;
        regs.STP = regs.WAI = 0;
        regs.S = 0x1FF;
                break; }
            case 6: {// 8
        regs.PC = pins.D;
        pins.Addr++; if (pins.Addr == 0x10000) { pins.Addr = 0; pins.BA = (pins.BA + 1) & 0xFF; };
                break; }
            case 7: {// cleanup_custom
        regs.PC += (pins.D << 8);
        pins.PDV = 1;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_101_E(regs &regs, pins &pins) { // S_ABORT s
        switch(regs.TCU) {
        // S_ABORT s E=1 M=0 X=0
            case 1: {// 4
        regs.TR = regs.PC;
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 2: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 3: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v & 0xF7;
                break; }
            case 4: {// 7
        pins.Addr = (0xFFF8); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 5: {// 8
        pins.Addr = (0xFFF9); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 6: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_102_E(regs &regs, pins &pins) { // S_IRQ s
        switch(regs.TCU) {
        // S_IRQ s E=1 M=0 X=0
            case 1: {// 4
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 2: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 3: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v & 0xF7;
                break; }
            case 4: {// 7
        pins.Addr = (0xFFFE); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 5: {// 8
        pins.Addr = (0xFFFF); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 6: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


static void opcode_103_E(regs &regs, pins &pins) { // S_NMI s
        switch(regs.TCU) {
        // S_NMI s E=1 M=0 X=0
            case 1: {// 4
        regs.TR = (regs.PC - 1) & 0xFFFF;
        pins.RW = 1;
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = (regs.TR >> 8) & 0xFF;
                break; }
            case 2: {// 5
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.TR & 0xFF;
                break; }
            case 3: {// 6
        pins.Addr = regs.S; pins.BA = 0;
        regs.S = (regs.S - 1) & 0xFFFF;
        if (regs.E) regs.S = (regs.S & 0xFF) | 0x0100;
        pins.D = regs.P.v & 0xF7;
                break; }
            case 4: {// 7
        pins.Addr = (0xFFFA); pins.BA = (0);
        pins.RW = 0;
                break; }
            case 5: {// 8
        pins.Addr = (0xFFFB); pins.BA = (0);
        regs.TA = pins.D;
        regs.PBR = 0;
                break; }
            case 6: {// cleanup_custom
        regs.PC = (pins.D << 8) + regs.TA;
        regs.P.I = 1;
        regs.P.D = 0;
        // Following is auto-generated code for instruction finish
        pins.Addr = regs.PC; pins.BA = regs.PBR;
        regs.PC = (regs.PC + 1) & 0xFFFF;
        regs.TCU = 0;
        break; }
        }

}


ins_func decoded_opcodes[5][0x104] = {
{    &opcode_00_mx, &opcode_01_mx, &opcode_02_mx, &opcode_03_mx, &opcode_04_mx, &opcode_05_mx, &opcode_06_mx, &opcode_07_mx, 
    &opcode_08_mx, &opcode_09_mx, &opcode_0A_mx, &opcode_0B_mx, &opcode_0C_mx, &opcode_0D_mx, &opcode_0E_mx, &opcode_0F_mx, 
    &opcode_10_mx, &opcode_11_mx, &opcode_12_mx, &opcode_13_mx, &opcode_14_mx, &opcode_15_mx, &opcode_16_mx, &opcode_17_mx, 
    &opcode_18_mx, &opcode_19_mx, &opcode_1A_mx, &opcode_1B_mx, &opcode_1C_mx, &opcode_1D_mx, &opcode_1E_mx, &opcode_1F_mx, 
    &opcode_20_mx, &opcode_21_mx, &opcode_22_mx, &opcode_23_mx, &opcode_24_mx, &opcode_25_mx, &opcode_26_mx, &opcode_27_mx, 
    &opcode_28_mx, &opcode_29_mx, &opcode_2A_mx, &opcode_2B_mx, &opcode_2C_mx, &opcode_2D_mx, &opcode_2E_mx, &opcode_2F_mx, 
    &opcode_30_mx, &opcode_31_mx, &opcode_32_mx, &opcode_33_mx, &opcode_34_mx, &opcode_35_mx, &opcode_36_mx, &opcode_37_mx, 
    &opcode_38_mx, &opcode_39_mx, &opcode_3A_mx, &opcode_3B_mx, &opcode_3C_mx, &opcode_3D_mx, &opcode_3E_mx, &opcode_3F_mx, 
    &opcode_40_mx, &opcode_41_mx, &opcode_42_mx, &opcode_43_mx, &opcode_44_mx, &opcode_45_mx, &opcode_46_mx, &opcode_47_mx, 
    &opcode_48_mx, &opcode_49_mx, &opcode_4A_mx, &opcode_4B_mx, &opcode_4C_mx, &opcode_4D_mx, &opcode_4E_mx, &opcode_4F_mx, 
    &opcode_50_mx, &opcode_51_mx, &opcode_52_mx, &opcode_53_mx, &opcode_54_mx, &opcode_55_mx, &opcode_56_mx, &opcode_57_mx, 
    &opcode_58_mx, &opcode_59_mx, &opcode_5A_mx, &opcode_5B_mx, &opcode_5C_mx, &opcode_5D_mx, &opcode_5E_mx, &opcode_5F_mx, 
    &opcode_60_mx, &opcode_61_mx, &opcode_62_mx, &opcode_63_mx, &opcode_64_mx, &opcode_65_mx, &opcode_66_mx, &opcode_67_mx, 
    &opcode_68_mx, &opcode_69_mx, &opcode_6A_mx, &opcode_6B_mx, &opcode_6C_mx, &opcode_6D_mx, &opcode_6E_mx, &opcode_6F_mx, 
    &opcode_70_mx, &opcode_71_mx, &opcode_72_mx, &opcode_73_mx, &opcode_74_mx, &opcode_75_mx, &opcode_76_mx, &opcode_77_mx, 
    &opcode_78_mx, &opcode_79_mx, &opcode_7A_mx, &opcode_7B_mx, &opcode_7C_mx, &opcode_7D_mx, &opcode_7E_mx, &opcode_7F_mx, 
    &opcode_80_mx, &opcode_81_mx, &opcode_82_mx, &opcode_83_mx, &opcode_84_mx, &opcode_85_mx, &opcode_86_mx, &opcode_87_mx, 
    &opcode_88_mx, &opcode_89_mx, &opcode_8A_mx, &opcode_8B_mx, &opcode_8C_mx, &opcode_8D_mx, &opcode_8E_mx, &opcode_8F_mx, 
    &opcode_90_mx, &opcode_91_mx, &opcode_92_mx, &opcode_93_mx, &opcode_94_mx, &opcode_95_mx, &opcode_96_mx, &opcode_97_mx, 
    &opcode_98_mx, &opcode_99_mx, &opcode_9A_mx, &opcode_9B_mx, &opcode_9C_mx, &opcode_9D_mx, &opcode_9E_mx, &opcode_9F_mx, 
    &opcode_A0_mx, &opcode_A1_mx, &opcode_A2_mx, &opcode_A3_mx, &opcode_A4_mx, &opcode_A5_mx, &opcode_A6_mx, &opcode_A7_mx, 
    &opcode_A8_mx, &opcode_A9_mx, &opcode_AA_mx, &opcode_AB_mx, &opcode_AC_mx, &opcode_AD_mx, &opcode_AE_mx, &opcode_AF_mx, 
    &opcode_B0_mx, &opcode_B1_mx, &opcode_B2_mx, &opcode_B3_mx, &opcode_B4_mx, &opcode_B5_mx, &opcode_B6_mx, &opcode_B7_mx, 
    &opcode_B8_mx, &opcode_B9_mx, &opcode_BA_mx, &opcode_BB_mx, &opcode_BC_mx, &opcode_BD_mx, &opcode_BE_mx, &opcode_BF_mx, 
    &opcode_C0_mx, &opcode_C1_mx, &opcode_C2_mx, &opcode_C3_mx, &opcode_C4_mx, &opcode_C5_mx, &opcode_C6_mx, &opcode_C7_mx, 
    &opcode_C8_mx, &opcode_C9_mx, &opcode_CA_mx, &opcode_CB_mx, &opcode_CC_mx, &opcode_CD_mx, &opcode_CE_mx, &opcode_CF_mx, 
    &opcode_D0_mx, &opcode_D1_mx, &opcode_D2_mx, &opcode_D3_mx, &opcode_D4_mx, &opcode_D5_mx, &opcode_D6_mx, &opcode_D7_mx, 
    &opcode_D8_mx, &opcode_D9_mx, &opcode_DA_mx, &opcode_DB_mx, &opcode_DC_mx, &opcode_DD_mx, &opcode_DE_mx, &opcode_DF_mx, 
    &opcode_E0_mx, &opcode_E1_mx, &opcode_E2_mx, &opcode_E3_mx, &opcode_E4_mx, &opcode_E5_mx, &opcode_E6_mx, &opcode_E7_mx, 
    &opcode_E8_mx, &opcode_E9_mx, &opcode_EA_mx, &opcode_EB_mx, &opcode_EC_mx, &opcode_ED_mx, &opcode_EE_mx, &opcode_EF_mx, 
    &opcode_F0_mx, &opcode_F1_mx, &opcode_F2_mx, &opcode_F3_mx, &opcode_F4_mx, &opcode_F5_mx, &opcode_F6_mx, &opcode_F7_mx, 
    &opcode_F8_mx, &opcode_F9_mx, &opcode_FA_mx, &opcode_FB_mx, &opcode_FC_mx, &opcode_FD_mx, &opcode_FE_mx, &opcode_FF_mx, 
    &opcode_100_mx, &opcode_101_mx, &opcode_102_mx, &opcode_103_mx, },
{    &opcode_00_Mx, &opcode_01_Mx, &opcode_02_Mx, &opcode_03_Mx, &opcode_04_Mx, &opcode_05_Mx, &opcode_06_Mx, &opcode_07_Mx, 
    &opcode_08_Mx, &opcode_09_Mx, &opcode_0A_Mx, &opcode_0B_Mx, &opcode_0C_Mx, &opcode_0D_Mx, &opcode_0E_Mx, &opcode_0F_Mx, 
    &opcode_10_Mx, &opcode_11_Mx, &opcode_12_Mx, &opcode_13_Mx, &opcode_14_Mx, &opcode_15_Mx, &opcode_16_Mx, &opcode_17_Mx, 
    &opcode_18_Mx, &opcode_19_Mx, &opcode_1A_Mx, &opcode_1B_Mx, &opcode_1C_Mx, &opcode_1D_Mx, &opcode_1E_Mx, &opcode_1F_Mx, 
    &opcode_20_Mx, &opcode_21_Mx, &opcode_22_Mx, &opcode_23_Mx, &opcode_24_Mx, &opcode_25_Mx, &opcode_26_Mx, &opcode_27_Mx, 
    &opcode_28_Mx, &opcode_29_Mx, &opcode_2A_Mx, &opcode_2B_Mx, &opcode_2C_Mx, &opcode_2D_Mx, &opcode_2E_Mx, &opcode_2F_Mx, 
    &opcode_30_Mx, &opcode_31_Mx, &opcode_32_Mx, &opcode_33_Mx, &opcode_34_Mx, &opcode_35_Mx, &opcode_36_Mx, &opcode_37_Mx, 
    &opcode_38_Mx, &opcode_39_Mx, &opcode_3A_Mx, &opcode_3B_Mx, &opcode_3C_Mx, &opcode_3D_Mx, &opcode_3E_Mx, &opcode_3F_Mx, 
    &opcode_40_Mx, &opcode_41_Mx, &opcode_42_Mx, &opcode_43_Mx, &opcode_44_Mx, &opcode_45_Mx, &opcode_46_Mx, &opcode_47_Mx, 
    &opcode_48_Mx, &opcode_49_Mx, &opcode_4A_Mx, &opcode_4B_Mx, &opcode_4C_Mx, &opcode_4D_Mx, &opcode_4E_Mx, &opcode_4F_Mx, 
    &opcode_50_Mx, &opcode_51_Mx, &opcode_52_Mx, &opcode_53_Mx, &opcode_54_Mx, &opcode_55_Mx, &opcode_56_Mx, &opcode_57_Mx, 
    &opcode_58_Mx, &opcode_59_Mx, &opcode_5A_Mx, &opcode_5B_Mx, &opcode_5C_Mx, &opcode_5D_Mx, &opcode_5E_Mx, &opcode_5F_Mx, 
    &opcode_60_Mx, &opcode_61_Mx, &opcode_62_Mx, &opcode_63_Mx, &opcode_64_Mx, &opcode_65_Mx, &opcode_66_Mx, &opcode_67_Mx, 
    &opcode_68_Mx, &opcode_69_Mx, &opcode_6A_Mx, &opcode_6B_Mx, &opcode_6C_Mx, &opcode_6D_Mx, &opcode_6E_Mx, &opcode_6F_Mx, 
    &opcode_70_Mx, &opcode_71_Mx, &opcode_72_Mx, &opcode_73_Mx, &opcode_74_Mx, &opcode_75_Mx, &opcode_76_Mx, &opcode_77_Mx, 
    &opcode_78_Mx, &opcode_79_Mx, &opcode_7A_Mx, &opcode_7B_Mx, &opcode_7C_Mx, &opcode_7D_Mx, &opcode_7E_Mx, &opcode_7F_Mx, 
    &opcode_80_Mx, &opcode_81_Mx, &opcode_82_Mx, &opcode_83_Mx, &opcode_84_Mx, &opcode_85_Mx, &opcode_86_Mx, &opcode_87_Mx, 
    &opcode_88_Mx, &opcode_89_Mx, &opcode_8A_Mx, &opcode_8B_Mx, &opcode_8C_Mx, &opcode_8D_Mx, &opcode_8E_Mx, &opcode_8F_Mx, 
    &opcode_90_Mx, &opcode_91_Mx, &opcode_92_Mx, &opcode_93_Mx, &opcode_94_Mx, &opcode_95_Mx, &opcode_96_Mx, &opcode_97_Mx, 
    &opcode_98_Mx, &opcode_99_Mx, &opcode_9A_Mx, &opcode_9B_Mx, &opcode_9C_Mx, &opcode_9D_Mx, &opcode_9E_Mx, &opcode_9F_Mx, 
    &opcode_A0_Mx, &opcode_A1_Mx, &opcode_A2_Mx, &opcode_A3_Mx, &opcode_A4_Mx, &opcode_A5_Mx, &opcode_A6_Mx, &opcode_A7_Mx, 
    &opcode_A8_Mx, &opcode_A9_Mx, &opcode_AA_Mx, &opcode_AB_Mx, &opcode_AC_Mx, &opcode_AD_Mx, &opcode_AE_Mx, &opcode_AF_Mx, 
    &opcode_B0_Mx, &opcode_B1_Mx, &opcode_B2_Mx, &opcode_B3_Mx, &opcode_B4_Mx, &opcode_B5_Mx, &opcode_B6_Mx, &opcode_B7_Mx, 
    &opcode_B8_Mx, &opcode_B9_Mx, &opcode_BA_Mx, &opcode_BB_Mx, &opcode_BC_Mx, &opcode_BD_Mx, &opcode_BE_Mx, &opcode_BF_Mx, 
    &opcode_C0_Mx, &opcode_C1_Mx, &opcode_C2_Mx, &opcode_C3_Mx, &opcode_C4_Mx, &opcode_C5_Mx, &opcode_C6_Mx, &opcode_C7_Mx, 
    &opcode_C8_Mx, &opcode_C9_Mx, &opcode_CA_Mx, &opcode_CB_Mx, &opcode_CC_Mx, &opcode_CD_Mx, &opcode_CE_Mx, &opcode_CF_Mx, 
    &opcode_D0_Mx, &opcode_D1_Mx, &opcode_D2_Mx, &opcode_D3_Mx, &opcode_D4_Mx, &opcode_D5_Mx, &opcode_D6_Mx, &opcode_D7_Mx, 
    &opcode_D8_Mx, &opcode_D9_Mx, &opcode_DA_Mx, &opcode_DB_Mx, &opcode_DC_Mx, &opcode_DD_Mx, &opcode_DE_Mx, &opcode_DF_Mx, 
    &opcode_E0_Mx, &opcode_E1_Mx, &opcode_E2_Mx, &opcode_E3_Mx, &opcode_E4_Mx, &opcode_E5_Mx, &opcode_E6_Mx, &opcode_E7_Mx, 
    &opcode_E8_Mx, &opcode_E9_Mx, &opcode_EA_Mx, &opcode_EB_Mx, &opcode_EC_Mx, &opcode_ED_Mx, &opcode_EE_Mx, &opcode_EF_Mx, 
    &opcode_F0_Mx, &opcode_F1_Mx, &opcode_F2_Mx, &opcode_F3_Mx, &opcode_F4_Mx, &opcode_F5_Mx, &opcode_F6_Mx, &opcode_F7_Mx, 
    &opcode_F8_Mx, &opcode_F9_Mx, &opcode_FA_Mx, &opcode_FB_Mx, &opcode_FC_Mx, &opcode_FD_Mx, &opcode_FE_Mx, &opcode_FF_Mx, 
    &opcode_100_Mx, &opcode_101_Mx, &opcode_102_Mx, &opcode_103_Mx, },
{    &opcode_00_mX, &opcode_01_mX, &opcode_02_mX, &opcode_03_mX, &opcode_04_mX, &opcode_05_mX, &opcode_06_mX, &opcode_07_mX, 
    &opcode_08_mX, &opcode_09_mX, &opcode_0A_mX, &opcode_0B_mX, &opcode_0C_mX, &opcode_0D_mX, &opcode_0E_mX, &opcode_0F_mX, 
    &opcode_10_mX, &opcode_11_mX, &opcode_12_mX, &opcode_13_mX, &opcode_14_mX, &opcode_15_mX, &opcode_16_mX, &opcode_17_mX, 
    &opcode_18_mX, &opcode_19_mX, &opcode_1A_mX, &opcode_1B_mX, &opcode_1C_mX, &opcode_1D_mX, &opcode_1E_mX, &opcode_1F_mX, 
    &opcode_20_mX, &opcode_21_mX, &opcode_22_mX, &opcode_23_mX, &opcode_24_mX, &opcode_25_mX, &opcode_26_mX, &opcode_27_mX, 
    &opcode_28_mX, &opcode_29_mX, &opcode_2A_mX, &opcode_2B_mX, &opcode_2C_mX, &opcode_2D_mX, &opcode_2E_mX, &opcode_2F_mX, 
    &opcode_30_mX, &opcode_31_mX, &opcode_32_mX, &opcode_33_mX, &opcode_34_mX, &opcode_35_mX, &opcode_36_mX, &opcode_37_mX, 
    &opcode_38_mX, &opcode_39_mX, &opcode_3A_mX, &opcode_3B_mX, &opcode_3C_mX, &opcode_3D_mX, &opcode_3E_mX, &opcode_3F_mX, 
    &opcode_40_mX, &opcode_41_mX, &opcode_42_mX, &opcode_43_mX, &opcode_44_mX, &opcode_45_mX, &opcode_46_mX, &opcode_47_mX, 
    &opcode_48_mX, &opcode_49_mX, &opcode_4A_mX, &opcode_4B_mX, &opcode_4C_mX, &opcode_4D_mX, &opcode_4E_mX, &opcode_4F_mX, 
    &opcode_50_mX, &opcode_51_mX, &opcode_52_mX, &opcode_53_mX, &opcode_54_mX, &opcode_55_mX, &opcode_56_mX, &opcode_57_mX, 
    &opcode_58_mX, &opcode_59_mX, &opcode_5A_mX, &opcode_5B_mX, &opcode_5C_mX, &opcode_5D_mX, &opcode_5E_mX, &opcode_5F_mX, 
    &opcode_60_mX, &opcode_61_mX, &opcode_62_mX, &opcode_63_mX, &opcode_64_mX, &opcode_65_mX, &opcode_66_mX, &opcode_67_mX, 
    &opcode_68_mX, &opcode_69_mX, &opcode_6A_mX, &opcode_6B_mX, &opcode_6C_mX, &opcode_6D_mX, &opcode_6E_mX, &opcode_6F_mX, 
    &opcode_70_mX, &opcode_71_mX, &opcode_72_mX, &opcode_73_mX, &opcode_74_mX, &opcode_75_mX, &opcode_76_mX, &opcode_77_mX, 
    &opcode_78_mX, &opcode_79_mX, &opcode_7A_mX, &opcode_7B_mX, &opcode_7C_mX, &opcode_7D_mX, &opcode_7E_mX, &opcode_7F_mX, 
    &opcode_80_mX, &opcode_81_mX, &opcode_82_mX, &opcode_83_mX, &opcode_84_mX, &opcode_85_mX, &opcode_86_mX, &opcode_87_mX, 
    &opcode_88_mX, &opcode_89_mX, &opcode_8A_mX, &opcode_8B_mX, &opcode_8C_mX, &opcode_8D_mX, &opcode_8E_mX, &opcode_8F_mX, 
    &opcode_90_mX, &opcode_91_mX, &opcode_92_mX, &opcode_93_mX, &opcode_94_mX, &opcode_95_mX, &opcode_96_mX, &opcode_97_mX, 
    &opcode_98_mX, &opcode_99_mX, &opcode_9A_mX, &opcode_9B_mX, &opcode_9C_mX, &opcode_9D_mX, &opcode_9E_mX, &opcode_9F_mX, 
    &opcode_A0_mX, &opcode_A1_mX, &opcode_A2_mX, &opcode_A3_mX, &opcode_A4_mX, &opcode_A5_mX, &opcode_A6_mX, &opcode_A7_mX, 
    &opcode_A8_mX, &opcode_A9_mX, &opcode_AA_mX, &opcode_AB_mX, &opcode_AC_mX, &opcode_AD_mX, &opcode_AE_mX, &opcode_AF_mX, 
    &opcode_B0_mX, &opcode_B1_mX, &opcode_B2_mX, &opcode_B3_mX, &opcode_B4_mX, &opcode_B5_mX, &opcode_B6_mX, &opcode_B7_mX, 
    &opcode_B8_mX, &opcode_B9_mX, &opcode_BA_mX, &opcode_BB_mX, &opcode_BC_mX, &opcode_BD_mX, &opcode_BE_mX, &opcode_BF_mX, 
    &opcode_C0_mX, &opcode_C1_mX, &opcode_C2_mX, &opcode_C3_mX, &opcode_C4_mX, &opcode_C5_mX, &opcode_C6_mX, &opcode_C7_mX, 
    &opcode_C8_mX, &opcode_C9_mX, &opcode_CA_mX, &opcode_CB_mX, &opcode_CC_mX, &opcode_CD_mX, &opcode_CE_mX, &opcode_CF_mX, 
    &opcode_D0_mX, &opcode_D1_mX, &opcode_D2_mX, &opcode_D3_mX, &opcode_D4_mX, &opcode_D5_mX, &opcode_D6_mX, &opcode_D7_mX, 
    &opcode_D8_mX, &opcode_D9_mX, &opcode_DA_mX, &opcode_DB_mX, &opcode_DC_mX, &opcode_DD_mX, &opcode_DE_mX, &opcode_DF_mX, 
    &opcode_E0_mX, &opcode_E1_mX, &opcode_E2_mX, &opcode_E3_mX, &opcode_E4_mX, &opcode_E5_mX, &opcode_E6_mX, &opcode_E7_mX, 
    &opcode_E8_mX, &opcode_E9_mX, &opcode_EA_mX, &opcode_EB_mX, &opcode_EC_mX, &opcode_ED_mX, &opcode_EE_mX, &opcode_EF_mX, 
    &opcode_F0_mX, &opcode_F1_mX, &opcode_F2_mX, &opcode_F3_mX, &opcode_F4_mX, &opcode_F5_mX, &opcode_F6_mX, &opcode_F7_mX, 
    &opcode_F8_mX, &opcode_F9_mX, &opcode_FA_mX, &opcode_FB_mX, &opcode_FC_mX, &opcode_FD_mX, &opcode_FE_mX, &opcode_FF_mX, 
    &opcode_100_mX, &opcode_101_mX, &opcode_102_mX, &opcode_103_mX, },
{    &opcode_00_MX, &opcode_01_MX, &opcode_02_MX, &opcode_03_MX, &opcode_04_MX, &opcode_05_MX, &opcode_06_MX, &opcode_07_MX, 
    &opcode_08_MX, &opcode_09_MX, &opcode_0A_MX, &opcode_0B_MX, &opcode_0C_MX, &opcode_0D_MX, &opcode_0E_MX, &opcode_0F_MX, 
    &opcode_10_MX, &opcode_11_MX, &opcode_12_MX, &opcode_13_MX, &opcode_14_MX, &opcode_15_MX, &opcode_16_MX, &opcode_17_MX, 
    &opcode_18_MX, &opcode_19_MX, &opcode_1A_MX, &opcode_1B_MX, &opcode_1C_MX, &opcode_1D_MX, &opcode_1E_MX, &opcode_1F_MX, 
    &opcode_20_MX, &opcode_21_MX, &opcode_22_MX, &opcode_23_MX, &opcode_24_MX, &opcode_25_MX, &opcode_26_MX, &opcode_27_MX, 
    &opcode_28_MX, &opcode_29_MX, &opcode_2A_MX, &opcode_2B_MX, &opcode_2C_MX, &opcode_2D_MX, &opcode_2E_MX, &opcode_2F_MX, 
    &opcode_30_MX, &opcode_31_MX, &opcode_32_MX, &opcode_33_MX, &opcode_34_MX, &opcode_35_MX, &opcode_36_MX, &opcode_37_MX, 
    &opcode_38_MX, &opcode_39_MX, &opcode_3A_MX, &opcode_3B_MX, &opcode_3C_MX, &opcode_3D_MX, &opcode_3E_MX, &opcode_3F_MX, 
    &opcode_40_MX, &opcode_41_MX, &opcode_42_MX, &opcode_43_MX, &opcode_44_MX, &opcode_45_MX, &opcode_46_MX, &opcode_47_MX, 
    &opcode_48_MX, &opcode_49_MX, &opcode_4A_MX, &opcode_4B_MX, &opcode_4C_MX, &opcode_4D_MX, &opcode_4E_MX, &opcode_4F_MX, 
    &opcode_50_MX, &opcode_51_MX, &opcode_52_MX, &opcode_53_MX, &opcode_54_MX, &opcode_55_MX, &opcode_56_MX, &opcode_57_MX, 
    &opcode_58_MX, &opcode_59_MX, &opcode_5A_MX, &opcode_5B_MX, &opcode_5C_MX, &opcode_5D_MX, &opcode_5E_MX, &opcode_5F_MX, 
    &opcode_60_MX, &opcode_61_MX, &opcode_62_MX, &opcode_63_MX, &opcode_64_MX, &opcode_65_MX, &opcode_66_MX, &opcode_67_MX, 
    &opcode_68_MX, &opcode_69_MX, &opcode_6A_MX, &opcode_6B_MX, &opcode_6C_MX, &opcode_6D_MX, &opcode_6E_MX, &opcode_6F_MX, 
    &opcode_70_MX, &opcode_71_MX, &opcode_72_MX, &opcode_73_MX, &opcode_74_MX, &opcode_75_MX, &opcode_76_MX, &opcode_77_MX, 
    &opcode_78_MX, &opcode_79_MX, &opcode_7A_MX, &opcode_7B_MX, &opcode_7C_MX, &opcode_7D_MX, &opcode_7E_MX, &opcode_7F_MX, 
    &opcode_80_MX, &opcode_81_MX, &opcode_82_MX, &opcode_83_MX, &opcode_84_MX, &opcode_85_MX, &opcode_86_MX, &opcode_87_MX, 
    &opcode_88_MX, &opcode_89_MX, &opcode_8A_MX, &opcode_8B_MX, &opcode_8C_MX, &opcode_8D_MX, &opcode_8E_MX, &opcode_8F_MX, 
    &opcode_90_MX, &opcode_91_MX, &opcode_92_MX, &opcode_93_MX, &opcode_94_MX, &opcode_95_MX, &opcode_96_MX, &opcode_97_MX, 
    &opcode_98_MX, &opcode_99_MX, &opcode_9A_MX, &opcode_9B_MX, &opcode_9C_MX, &opcode_9D_MX, &opcode_9E_MX, &opcode_9F_MX, 
    &opcode_A0_MX, &opcode_A1_MX, &opcode_A2_MX, &opcode_A3_MX, &opcode_A4_MX, &opcode_A5_MX, &opcode_A6_MX, &opcode_A7_MX, 
    &opcode_A8_MX, &opcode_A9_MX, &opcode_AA_MX, &opcode_AB_MX, &opcode_AC_MX, &opcode_AD_MX, &opcode_AE_MX, &opcode_AF_MX, 
    &opcode_B0_MX, &opcode_B1_MX, &opcode_B2_MX, &opcode_B3_MX, &opcode_B4_MX, &opcode_B5_MX, &opcode_B6_MX, &opcode_B7_MX, 
    &opcode_B8_MX, &opcode_B9_MX, &opcode_BA_MX, &opcode_BB_MX, &opcode_BC_MX, &opcode_BD_MX, &opcode_BE_MX, &opcode_BF_MX, 
    &opcode_C0_MX, &opcode_C1_MX, &opcode_C2_MX, &opcode_C3_MX, &opcode_C4_MX, &opcode_C5_MX, &opcode_C6_MX, &opcode_C7_MX, 
    &opcode_C8_MX, &opcode_C9_MX, &opcode_CA_MX, &opcode_CB_MX, &opcode_CC_MX, &opcode_CD_MX, &opcode_CE_MX, &opcode_CF_MX, 
    &opcode_D0_MX, &opcode_D1_MX, &opcode_D2_MX, &opcode_D3_MX, &opcode_D4_MX, &opcode_D5_MX, &opcode_D6_MX, &opcode_D7_MX, 
    &opcode_D8_MX, &opcode_D9_MX, &opcode_DA_MX, &opcode_DB_MX, &opcode_DC_MX, &opcode_DD_MX, &opcode_DE_MX, &opcode_DF_MX, 
    &opcode_E0_MX, &opcode_E1_MX, &opcode_E2_MX, &opcode_E3_MX, &opcode_E4_MX, &opcode_E5_MX, &opcode_E6_MX, &opcode_E7_MX, 
    &opcode_E8_MX, &opcode_E9_MX, &opcode_EA_MX, &opcode_EB_MX, &opcode_EC_MX, &opcode_ED_MX, &opcode_EE_MX, &opcode_EF_MX, 
    &opcode_F0_MX, &opcode_F1_MX, &opcode_F2_MX, &opcode_F3_MX, &opcode_F4_MX, &opcode_F5_MX, &opcode_F6_MX, &opcode_F7_MX, 
    &opcode_F8_MX, &opcode_F9_MX, &opcode_FA_MX, &opcode_FB_MX, &opcode_FC_MX, &opcode_FD_MX, &opcode_FE_MX, &opcode_FF_MX, 
    &opcode_100_MX, &opcode_101_MX, &opcode_102_MX, &opcode_103_MX, },
{    &opcode_00_E, &opcode_01_E, &opcode_02_E, &opcode_03_E, &opcode_04_E, &opcode_05_E, &opcode_06_E, &opcode_07_E, 
    &opcode_08_E, &opcode_09_E, &opcode_0A_E, &opcode_0B_E, &opcode_0C_E, &opcode_0D_E, &opcode_0E_E, &opcode_0F_E, 
    &opcode_10_E, &opcode_11_E, &opcode_12_E, &opcode_13_E, &opcode_14_E, &opcode_15_E, &opcode_16_E, &opcode_17_E, 
    &opcode_18_E, &opcode_19_E, &opcode_1A_E, &opcode_1B_E, &opcode_1C_E, &opcode_1D_E, &opcode_1E_E, &opcode_1F_E, 
    &opcode_20_E, &opcode_21_E, &opcode_22_E, &opcode_23_E, &opcode_24_E, &opcode_25_E, &opcode_26_E, &opcode_27_E, 
    &opcode_28_E, &opcode_29_E, &opcode_2A_E, &opcode_2B_E, &opcode_2C_E, &opcode_2D_E, &opcode_2E_E, &opcode_2F_E, 
    &opcode_30_E, &opcode_31_E, &opcode_32_E, &opcode_33_E, &opcode_34_E, &opcode_35_E, &opcode_36_E, &opcode_37_E, 
    &opcode_38_E, &opcode_39_E, &opcode_3A_E, &opcode_3B_E, &opcode_3C_E, &opcode_3D_E, &opcode_3E_E, &opcode_3F_E, 
    &opcode_40_E, &opcode_41_E, &opcode_42_E, &opcode_43_E, &opcode_44_E, &opcode_45_E, &opcode_46_E, &opcode_47_E, 
    &opcode_48_E, &opcode_49_E, &opcode_4A_E, &opcode_4B_E, &opcode_4C_E, &opcode_4D_E, &opcode_4E_E, &opcode_4F_E, 
    &opcode_50_E, &opcode_51_E, &opcode_52_E, &opcode_53_E, &opcode_54_E, &opcode_55_E, &opcode_56_E, &opcode_57_E, 
    &opcode_58_E, &opcode_59_E, &opcode_5A_E, &opcode_5B_E, &opcode_5C_E, &opcode_5D_E, &opcode_5E_E, &opcode_5F_E, 
    &opcode_60_E, &opcode_61_E, &opcode_62_E, &opcode_63_E, &opcode_64_E, &opcode_65_E, &opcode_66_E, &opcode_67_E, 
    &opcode_68_E, &opcode_69_E, &opcode_6A_E, &opcode_6B_E, &opcode_6C_E, &opcode_6D_E, &opcode_6E_E, &opcode_6F_E, 
    &opcode_70_E, &opcode_71_E, &opcode_72_E, &opcode_73_E, &opcode_74_E, &opcode_75_E, &opcode_76_E, &opcode_77_E, 
    &opcode_78_E, &opcode_79_E, &opcode_7A_E, &opcode_7B_E, &opcode_7C_E, &opcode_7D_E, &opcode_7E_E, &opcode_7F_E, 
    &opcode_80_E, &opcode_81_E, &opcode_82_E, &opcode_83_E, &opcode_84_E, &opcode_85_E, &opcode_86_E, &opcode_87_E, 
    &opcode_88_E, &opcode_89_E, &opcode_8A_E, &opcode_8B_E, &opcode_8C_E, &opcode_8D_E, &opcode_8E_E, &opcode_8F_E, 
    &opcode_90_E, &opcode_91_E, &opcode_92_E, &opcode_93_E, &opcode_94_E, &opcode_95_E, &opcode_96_E, &opcode_97_E, 
    &opcode_98_E, &opcode_99_E, &opcode_9A_E, &opcode_9B_E, &opcode_9C_E, &opcode_9D_E, &opcode_9E_E, &opcode_9F_E, 
    &opcode_A0_E, &opcode_A1_E, &opcode_A2_E, &opcode_A3_E, &opcode_A4_E, &opcode_A5_E, &opcode_A6_E, &opcode_A7_E, 
    &opcode_A8_E, &opcode_A9_E, &opcode_AA_E, &opcode_AB_E, &opcode_AC_E, &opcode_AD_E, &opcode_AE_E, &opcode_AF_E, 
    &opcode_B0_E, &opcode_B1_E, &opcode_B2_E, &opcode_B3_E, &opcode_B4_E, &opcode_B5_E, &opcode_B6_E, &opcode_B7_E, 
    &opcode_B8_E, &opcode_B9_E, &opcode_BA_E, &opcode_BB_E, &opcode_BC_E, &opcode_BD_E, &opcode_BE_E, &opcode_BF_E, 
    &opcode_C0_E, &opcode_C1_E, &opcode_C2_E, &opcode_C3_E, &opcode_C4_E, &opcode_C5_E, &opcode_C6_E, &opcode_C7_E, 
    &opcode_C8_E, &opcode_C9_E, &opcode_CA_E, &opcode_CB_E, &opcode_CC_E, &opcode_CD_E, &opcode_CE_E, &opcode_CF_E, 
    &opcode_D0_E, &opcode_D1_E, &opcode_D2_E, &opcode_D3_E, &opcode_D4_E, &opcode_D5_E, &opcode_D6_E, &opcode_D7_E, 
    &opcode_D8_E, &opcode_D9_E, &opcode_DA_E, &opcode_DB_E, &opcode_DC_E, &opcode_DD_E, &opcode_DE_E, &opcode_DF_E, 
    &opcode_E0_E, &opcode_E1_E, &opcode_E2_E, &opcode_E3_E, &opcode_E4_E, &opcode_E5_E, &opcode_E6_E, &opcode_E7_E, 
    &opcode_E8_E, &opcode_E9_E, &opcode_EA_E, &opcode_EB_E, &opcode_EC_E, &opcode_ED_E, &opcode_EE_E, &opcode_EF_E, 
    &opcode_F0_E, &opcode_F1_E, &opcode_F2_E, &opcode_F3_E, &opcode_F4_E, &opcode_F5_E, &opcode_F6_E, &opcode_F7_E, 
    &opcode_F8_E, &opcode_F9_E, &opcode_FA_E, &opcode_FB_E, &opcode_FC_E, &opcode_FD_E, &opcode_FE_E, &opcode_FF_E, 
    &opcode_100_E, &opcode_101_E, &opcode_102_E, &opcode_103_E, }
};
}
