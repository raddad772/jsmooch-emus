#include <stdio.h>
#include <cassert>
#include "helpers/int.h"
#include "helpers/debugger/debugger.h"
#include "huc6280_opcodes.h"
#include "huc6280.h"

// This file auto-generated byhuc6280_gen.py in JSMooCh

namespace HUC6280 {

// 
static void ins_00__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 4: {// push
            core.regs.P.T = 0;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u | 0x10;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.regs.P.D = 0; core.regs.P.I = 1;
            core.pins.Addr = core.regs.MPR[(0xFFF6)>>13] | ((0xFFF6) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 6: {// load16
            core.regs.PC = core.pins.D;
            core.pins.Addr = core.regs.MPR[(0xFFF7)>>13] | ((0xFFF7) & 0x1FFF);
            return; }
        case 7: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC |= core.regs.TA << 8;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_01__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_02__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup_custom
            core.regs.TA = core.regs.X;
            core.regs.X = core.regs.Y;
            core.regs.Y = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_03__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = 0x1FE000;
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_04__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 o = (core.regs.TR[0]) | core.regs.A;
            core.regs.P.Z = o == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) | core.regs.A;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_05__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.regs.A | (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_06__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_07__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 0);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_08__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = (core.regs.P.u | 0x10) & 0xDF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_09__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.A = core.regs.A | (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = ((core.regs.A) >> 7) & 1;
            core.regs.A = (core.regs.A << 1) & 0xFF;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.regs.A = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 o = (core.regs.TR[0]) | core.regs.A;
            core.regs.P.Z = o == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) | core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A | (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 1) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_10__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.N) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_11__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.A = core.regs.A | (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_12__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_13__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = 0x1FE002;
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_14__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.Z = (core.regs.A & (core.regs.TR[0])) == 0;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = ~core.regs.A & (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_15__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.regs.A | (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_16__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_17__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 1);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_18__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_19__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A | (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = ((core.regs.A) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.Z = (core.regs.A & (core.regs.TR[0])) == 0;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = ~core.regs.A & (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A | (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 2) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_20__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 6: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_21__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_22__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup_custom
            core.regs.TA = core.regs.A;
            core.regs.A = core.regs.X;
            core.regs.X = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_23__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = 0x1FE003;
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_24__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_25__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.regs.A & (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_26__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_27__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 2);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_28__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.u = core.pins.D;
            core.regs.P.u &= 0xEF;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_29__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.A = core.regs.A & (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.A) >> 7) & 1;
            core.regs.A = ((core.regs.A << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.A == 0;
            core.regs.P.N = ((core.regs.A) >> 7) & 1;
            core.regs.A = (core.regs.A);
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A & (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 4) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_30__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.N) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_31__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.A = core.regs.A & (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_32__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_33__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_34__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_35__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.regs.A & (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_36__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_37__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 3);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_38__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_39__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A & (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = ((core.regs.A) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A & (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 8) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_40__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// pull
            core.regs.P.u = core.pins.D;
            core.regs.P.u &= 0xEF;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 5: {// pull
            core.regs.PC = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 6: {// cleanup_custom
            core.regs.TA = core.pins.D;
            core.regs.PC |= core.regs.TA << 8;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_41__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_42__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup_custom
            core.regs.TA = core.regs.A;
            core.regs.A = core.regs.Y;
            core.regs.Y = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_43__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            if (core.regs.TR[0]) {
                core.regs.MPL = 0;
                for (u32 i = 0; i < 8; i++) { // inspired by Ares handling
                    u32 shift = 1 << i;
                    if (core.regs.TR[0] & shift)
                        core.regs.MPL |= (core.regs.MPR[i] >> 13);
                }
            }
            core.regs.A = core.regs.MPL;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_44__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (u32)(i8)core.regs.TA;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TR[0] = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.TR[0] >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.regs.PC += core.regs.TA;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.TR[0] & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.WR = 0;
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_45__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.regs.A ^ (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_46__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_47__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 4);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_48__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_49__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.A = core.regs.A ^ (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = (core.regs.A) & 1;
            core.regs.A = (core.regs.A) >> 1;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A ^ (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 16) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_50__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.V) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_51__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.A = core.regs.A ^ (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_52__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_53__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// idle
            if (core.regs.TA) {
                core.regs.MPL = core.regs.A;
                u32 mpl = core.regs.MPL << 13;
                for (u32 i = 0; i < 8; i++) {
                    u32 shifted = 1 << i;
                    if ((core.regs.TA & shifted) && (core.regs.MPR[i] != mpl)) {
                        debugger_interface_dirty_mem(core.dbg.interface, core.pins.debugger_mem_bus, mpl, ((i + 1) << 13) - 1);
                        core.regs.MPR[i] = mpl;
                    }
                }
            }
            // Following is auto-generated code for instruction finish
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_54__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.regs.clock_div = 12;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_55__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.regs.A ^ (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_56__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_57__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 5);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_58__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.I = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_59__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A ^ (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.A = core.regs.A ^ (core.pins.D);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 32) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_60__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// pull
            core.regs.PC = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 5: {// pull
            core.regs.TA = core.pins.D;
            core.regs.PC |= core.regs.TA << 8;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_61__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_62__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_63__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_64__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_65__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_66__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_67__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 6);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_68__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.pins.D;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_69__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.A) & 1;
            c = (((core.regs.A) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.A = c;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 6: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC |= core.regs.TR[0] << 8;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 64) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_70__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.V) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_71__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_72__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_73__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] + 1) & 0xFFFF;
            core.regs.TR[1] = (core.regs.TR[1] + 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_74__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_75__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_76__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_77__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 7);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_78__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.poll_IRQs();
            return; }
        case 2: {// cleanup_custom
            core.regs.P.I = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_79__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.Y = core.pins.D;
            core.regs.P.Z = (core.regs.Y) == 0;
            core.regs.P.N = ((core.regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 6: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC |= core.regs.TR[0] << 8;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 128) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_80__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_81__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X )) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_82__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_83__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TR[1]);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            core.regs.TA = core.pins.D;
            core.regs.P.Z = (core.regs.TR[0] & core.regs.TA) == 0;
            core.regs.P.V = (core.regs.TA >> 6) & 1;
            core.regs.P.N = (core.regs.TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_84__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.Y;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_85__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_86__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_87__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 0;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_88__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = ((core.regs.Y) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.Y) == 0;
            core.regs.P.N = ((core.regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_89__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = core.regs.X;
            core.regs.P.Z = core.regs.A == 0;
            core.regs.P.N = (core.regs.A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.Y;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 1) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_90__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.C) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_91__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.regs.TR[0] |= core.regs.TR[1] << 8;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = (core.regs.TR[0] + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_92__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_93__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 4: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[1] << 8;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[2] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 8: {// cleanup_custom
            core.regs.P.Z = (core.regs.TR[2] & core.regs.TR[0]) == 0;
            core.regs.P.V = (core.regs.TR[2] >> 6) & 1;
            core.regs.P.N = (core.regs.TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_94__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.Y;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_95__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_96__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_97__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 1;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_98__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = core.regs.Y;
            core.regs.P.Z = core.regs.A == 0;
            core.regs.P.N = (core.regs.A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_99__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9A__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.S = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9B__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9C__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9D__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9E__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9F__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 2) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A0__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A1__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = (core.regs.TR[0] >> 7) & 1;
            core.regs.A = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A2__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A3__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            core.regs.TR[1] = (core.regs.TR[1] + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TR[1]);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            core.regs.TA = core.pins.D;
            core.regs.P.Z = (core.regs.TR[0] & core.regs.TA) == 0;
            core.regs.P.V = (core.regs.TA >> 6) & 1;
            core.regs.P.N = (core.regs.TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A4__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A5__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A6__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A7__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 2;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A8__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = core.regs.A;
            core.regs.P.Z = core.regs.Y == 0;
            core.regs.P.N = (core.regs.Y >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A9__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AA__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = core.regs.A;
            core.regs.P.Z = core.regs.X == 0;
            core.regs.P.N = (core.regs.X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AB__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AC__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AD__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AE__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AF__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 4) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B0__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.C) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B1__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B2__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = (core.regs.TR[0] >> 7) & 1;
            core.regs.A = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B3__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 4: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[1] << 8;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[2] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 8: {// cleanup_custom
            core.regs.P.Z = (core.regs.TR[2] & core.regs.TR[0]) == 0;
            core.regs.P.V = (core.regs.TR[2] >> 6) & 1;
            core.regs.P.N = (core.regs.TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B4__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B5__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B6__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.Y)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B7__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 3;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B8__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.V = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B9__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BA__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = core.regs.S;
            core.regs.P.Z = core.regs.X == 0;
            core.regs.P.N = (core.regs.X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BB__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BC__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BD__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BE__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BF__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 8) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C0__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = core.regs.Y - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C1__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            u32 a = (core.regs.A - (core.regs.TR[0])) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C2__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C3__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] - 1) & 0xFFFF;
            core.regs.TR[1] = (core.regs.TR[1] - 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C4__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = core.regs.Y - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C5__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C6__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C7__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 4;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C8__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = ((core.regs.Y) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.Y) == 0;
            core.regs.P.N = ((core.regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C9__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CA__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = ((core.regs.X) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.X) == 0;
            core.regs.P.N = ((core.regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CB__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CC__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = core.regs.Y - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CD__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CE__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CF__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 16) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D0__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.Z) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D1__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D2__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            u32 a = (core.regs.A - (core.regs.TR[0])) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D3__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] + 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D4__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.regs.clock_div = 3;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D5__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D6__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D7__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 5;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D8__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D9__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DA__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DB__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DC__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DD__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DE__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DF__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 32) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E0__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = core.regs.X - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E1__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.TR[0] ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E2__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E3__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] + 1) & 0xFFFF;
            core.regs.TR[1] += core.regs.TR[3] ? -1 : 1;
            core.regs.TR[1] &= 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E4__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = core.regs.X - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E5__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E6__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E7__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 6;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E8__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = ((core.regs.X) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.X) == 0;
            core.regs.P.N = ((core.regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E9__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EA__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EB__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EC__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = core.regs.X - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_ED__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EE__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EF__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 64) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F0__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.Z) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F1__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F2__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.TR[0] ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F3__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] += core.regs.TR[3] ? -1 : 1;
            core.regs.TR[0] &= 0xFFFF;
            core.regs.TR[1] = (core.regs.TR[1] + 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F4__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.T = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F5__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F6__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F7__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F8__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.D = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F9__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FA__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.X = core.pins.D;
            core.regs.P.Z = (core.regs.X) == 0;
            core.regs.P.N = ((core.regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FB__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FC__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FD__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FE__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FF__t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 128) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_RESET_t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.RD = 0; 
            return; }
        case 2: {// 3
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 3: {// 4
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 4: {// 5
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// 6
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// 7
            core.regs.MPR[7] = 0;
            core.regs.MPL = 0;
            core.regs.P.I = 1;
            core.regs.P.D = core.regs.P.T = 0;
            core.regs.IRQD.u = 7;
            core.regs.timer_startstop = 0;
            core.regs.clock_div = 12;
            core.pins.Addr = 0x1FFE;
            core.regs.S = 0;
            core.pins.RD = 1; 
            return; }
        case 7: {// 8
            core.regs.PC = core.pins.D;
            core.pins.Addr++;
            return; }
        case 8: {// 9
            core.pins.RD = 0; 
            return; }
        case 9: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_IRQ2_t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            core.regs.PC = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u & 0xEF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.regs.P.I = 1;
            core.regs.P.D = 0;
            core.regs.P.T = 0;
            core.regs.TA = 0xFFF6;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_IRQ1_t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            core.regs.PC = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u & 0xEF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.regs.P.I = 1;
            core.regs.P.D = 0;
            core.regs.P.T = 0;
            core.regs.TA = 0xFFF8;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_TIQ_t0(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            core.regs.PC = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u & 0xEF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.regs.P.I = 1;
            core.regs.P.D = 0;
            core.regs.P.T = 0;
            core.regs.TA = 0xFFFA;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_00__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 4: {// push
            core.regs.P.T = 0;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u | 0x10;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.regs.P.D = 0; core.regs.P.I = 1;
            core.pins.Addr = core.regs.MPR[(0xFFF6)>>13] | ((0xFFF6) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 6: {// load16
            core.regs.PC = core.pins.D;
            core.pins.Addr = core.regs.MPR[(0xFFF7)>>13] | ((0xFFF7) & 0x1FFF);
            return; }
        case 7: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC |= core.regs.TA << 8;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_01__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_02__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup_custom
            core.regs.TA = core.regs.X;
            core.regs.X = core.regs.Y;
            core.regs.Y = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_03__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = 0x1FE000;
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_04__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 o = (core.regs.TR[0]) | core.regs.A;
            core.regs.P.Z = o == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) | core.regs.A;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_05__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_06__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_07__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 0);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_08__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = (core.regs.P.u | 0x10) & 0xDF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void ins_09__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 3: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TA);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = ((core.regs.A) >> 7) & 1;
            core.regs.A = (core.regs.A << 1) & 0xFF;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.regs.A = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 o = (core.regs.TR[0]) | core.regs.A;
            core.regs.P.Z = o == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) | core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_0D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_0F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 1) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_10__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.N) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void ins_11__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[3] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[3]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_12__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_13__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = 0x1FE002;
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_14__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.Z = (core.regs.A & (core.regs.TR[0])) == 0;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = ~core.regs.A & (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_15__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X )) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_16__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_17__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 1);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_18__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_19__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.Y)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = ((core.regs.A) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.Z = (core.regs.A & (core.regs.TR[0])) == 0;
            core.regs.P.V = ((core.regs.TR[0]) >> 6) & 1;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = ~core.regs.A & (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_1D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A | (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = (core.regs.TR[0] << 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[0]) == 0;
            core.regs.P.N = ((core.regs.TR[0]) & 0x80) >> 7;
            core.regs.TR[1] = core.regs.TR[0];
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_1F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 2) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_20__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 6: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_21__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_22__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup_custom
            core.regs.TA = core.regs.A;
            core.regs.A = core.regs.X;
            core.regs.X = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_23__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = 0x1FE003;
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_24__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_25__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_26__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_27__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 2);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_28__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.u = core.pins.D;
            core.regs.P.u &= 0xEF;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void ins_29__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 3: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TA);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.A) >> 7) & 1;
            core.regs.A = ((core.regs.A << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.A == 0;
            core.regs.P.N = ((core.regs.A) >> 7) & 1;
            core.regs.A = (core.regs.A);
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_2D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_2F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 4) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_30__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.N) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void ins_31__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[3] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[3]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_32__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_33__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_34__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_35__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X )) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_36__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_37__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 3);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_38__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_39__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.Y)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = ((core.regs.A) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_3D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A & (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C;
            core.regs.P.C = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[0] = ((core.regs.TR[0] << 1) & 0xFF) | c;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = ((core.regs.TR[0]) >> 7) & 1;
            core.regs.TR[1] = (core.regs.TR[0]);
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_3F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 8) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_40__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// pull
            core.regs.P.u = core.pins.D;
            core.regs.P.u &= 0xEF;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 5: {// pull
            core.regs.PC = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 6: {// cleanup_custom
            core.regs.TA = core.pins.D;
            core.regs.PC |= core.regs.TA << 8;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_41__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_42__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup_custom
            core.regs.TA = core.regs.A;
            core.regs.A = core.regs.Y;
            core.regs.Y = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_43__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            if (core.regs.TR[0]) {
                core.regs.MPL = 0;
                for (u32 i = 0; i < 8; i++) { // inspired by Ares handling
                    u32 shift = 1 << i;
                    if (core.regs.TR[0] & shift)
                        core.regs.MPL |= (core.regs.MPR[i] >> 13);
                }
            }
            core.regs.A = core.regs.MPL;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_44__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (u32)(i8)core.regs.TA;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TR[0] = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.TR[0] >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.regs.PC += core.regs.TA;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.TR[0] & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.WR = 0;
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_45__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_46__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_47__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 4);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_48__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void ins_49__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 3: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TA);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.C = (core.regs.A) & 1;
            core.regs.A = (core.regs.A) >> 1;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_4D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_4F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 16) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_50__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.V) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void ins_51__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[3] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[3]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_52__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 10: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_53__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// idle
            if (core.regs.TA) {
                core.regs.MPL = core.regs.A;
                u32 mpl = core.regs.MPL << 13;
                for (u32 i = 0; i < 8; i++) {
                    u32 shifted = 1 << i;
                    if ((core.regs.TA & shifted) && (core.regs.MPR[i] != mpl)) {
                        debugger_interface_dirty_mem(core.dbg.interface, core.pins.debugger_mem_bus, mpl, ((i + 1) << 13) - 1);
                        core.regs.MPR[i] = mpl;
                    }
                }
            }
            // Following is auto-generated code for instruction finish
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_54__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.regs.clock_div = 12;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_55__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X )) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_56__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_57__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 5);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_58__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.I = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_59__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.Y)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_5D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            core.regs.A = core.regs.A ^ (core.regs.TR[0]);
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.P.C = (core.regs.TR[0]) & 1;
            core.regs.TR[1] = (core.regs.TR[0]) >> 1;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_5F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 32) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_60__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// pull
            core.regs.PC = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 5: {// pull
            core.regs.TA = core.pins.D;
            core.regs.PC |= core.regs.TA << 8;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_61__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            return; }
        case 10: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 11: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_62__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_63__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_64__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_65__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_66__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_67__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 6);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_68__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.A = core.pins.D;
            core.regs.P.Z = (core.regs.A) == 0;
            core.regs.P.N = ((core.regs.A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void ins_69__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 3: {// load8
            core.regs.A = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TA) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TA)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TA) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TA) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.A) & 1;
            c = (((core.regs.A) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.A = c;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 6: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC |= core.regs.TR[0] << 8;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_6D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            return; }
        case 8: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 9: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_6F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 64) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_70__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.V) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void ins_71__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[3] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[3]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[3])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[3]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[3]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            return; }
        case 10: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 11: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void ins_72__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 8: {// load8
            core.regs.A = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 9: {// idle
            return; }
        case 10: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 11: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_73__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] + 1) & 0xFFFF;
            core.regs.TR[1] = (core.regs.TR[1] + 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_74__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void ins_75__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X )) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.A = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 5: {// load8
            core.regs.TR[0] = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_76__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_77__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] &= ~(1 << 7);
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_78__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.poll_IRQs();
            return; }
        case 2: {// cleanup_custom
            core.regs.P.I = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_79__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.Y)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            return; }
        case 8: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 9: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.Y = core.pins.D;
            core.regs.P.Z = (core.regs.Y) == 0;
            core.regs.P.N = ((core.regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 6: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC |= core.regs.TR[0] << 8;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void ins_7D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.regs.TR[2] = core.regs.A;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            return; }
        case 6: {// load8
            core.regs.A = core.pins.D;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.regs.TCU++;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out > 9) out += 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            return; }
        case 8: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.X);
            core.pins.D = core.regs.A;
            core.regs.A = core.regs.TR[2];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 9: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            u32 c = core.regs.P.C << 7;
            core.regs.P.C = (core.regs.TR[0]) & 1;
            c = (((core.regs.TR[0]) >> 1) | c) & 0xFF;
            core.regs.P.Z = c == 0;
            core.regs.P.N = (c >> 7) & 1;
            core.regs.TR[1] = c;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_7F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 128) != 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_80__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_81__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X )) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_82__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_83__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TR[1]);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            core.regs.TA = core.pins.D;
            core.regs.P.Z = (core.regs.TR[0] & core.regs.TA) == 0;
            core.regs.P.V = (core.regs.TA >> 6) & 1;
            core.regs.P.N = (core.regs.TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_84__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.Y;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_85__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_86__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_87__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 0;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_88__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = ((core.regs.Y) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.Y) == 0;
            core.regs.P.N = ((core.regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_89__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.V = ((core.pins.D) >> 6) & 1;
            core.regs.P.N = ((core.pins.D) >> 7) & 1;
            core.regs.P.Z = ((core.pins.D) & core.regs.A) == 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = core.regs.X;
            core.regs.P.Z = core.regs.A == 0;
            core.regs.P.N = (core.regs.A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.Y;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_8F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 1) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_90__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.C) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_91__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.regs.TR[0] |= core.regs.TR[1] << 8;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = (core.regs.TR[0] + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_92__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_93__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 4: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[1] << 8;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[2] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 8: {// cleanup_custom
            core.regs.P.Z = (core.regs.TR[2] & core.regs.TR[0]) == 0;
            core.regs.P.V = (core.regs.TR[2] >> 6) & 1;
            core.regs.P.N = (core.regs.TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_94__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.Y;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_95__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_96__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 4: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_97__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 1;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_98__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.A = core.regs.Y;
            core.regs.P.Z = core.regs.A == 0;
            core.regs.P.N = (core.regs.A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_99__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9A__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.S = core.regs.X;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9B__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9C__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9D__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.A;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9E__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 5: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_9F__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 2) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A0__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A1__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = (core.regs.TR[0] >> 7) & 1;
            core.regs.A = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A2__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A3__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            core.regs.TR[1] = (core.regs.TR[1] + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TR[1]);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            core.regs.TA = core.pins.D;
            core.regs.P.Z = (core.regs.TR[0] & core.regs.TA) == 0;
            core.regs.P.V = (core.regs.TA >> 6) & 1;
            core.regs.P.N = (core.regs.TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A4__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A5__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A6__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A7__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 2;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A8__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = core.regs.A;
            core.regs.P.Z = core.regs.Y == 0;
            core.regs.P.N = (core.regs.Y >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_A9__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AA__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = core.regs.A;
            core.regs.P.Z = core.regs.X == 0;
            core.regs.P.N = (core.regs.X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AB__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AC__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AD__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AE__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_AF__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 4) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B0__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.C) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B1__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B2__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.P.Z = core.regs.TR[0] == 0;
            core.regs.P.N = (core.regs.TR[0] >> 7) & 1;
            core.regs.A = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B3__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 4: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[1] << 8;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X ) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// load16
            core.regs.TR[2] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 8: {// cleanup_custom
            core.regs.P.Z = (core.regs.TR[2] & core.regs.TR[0]) == 0;
            core.regs.P.V = (core.regs.TR[2] >> 6) & 1;
            core.regs.P.N = (core.regs.TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B4__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B5__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B6__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.Y)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B7__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 3;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B8__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.V = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_B9__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BA__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = core.regs.S;
            core.regs.P.Z = core.regs.X == 0;
            core.regs.P.N = (core.regs.X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BB__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BC__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BD__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.A = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BE__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.regs.P.Z = core.pins.D == 0;
            core.regs.P.N = (core.pins.D >> 7) & 1;
            core.regs.X = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_BF__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 8) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C0__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = core.regs.Y - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C1__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            u32 a = (core.regs.A - (core.regs.TR[0])) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C2__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C3__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] - 1) & 0xFFFF;
            core.regs.TR[1] = (core.regs.TR[1] - 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C4__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = core.regs.Y - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C5__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C6__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C7__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 4;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C8__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.Y = ((core.regs.Y) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.Y) == 0;
            core.regs.P.N = ((core.regs.Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_C9__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CA__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = ((core.regs.X) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.X) == 0;
            core.regs.P.N = ((core.regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CB__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CC__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = core.regs.Y - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CD__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CE__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_CF__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 16) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D0__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!!core.regs.P.Z) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D1__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D2__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            u32 a = (core.regs.A - (core.regs.TR[0])) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D3__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] + 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D4__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.regs.clock_div = 3;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; 
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D5__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D6__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D7__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 5;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D8__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.D = 0;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_D9__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DA__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 3: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DB__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DC__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DD__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (core.regs.A - (core.pins.D)) & 0x1FF;
            core.regs.P.C = ((a >> 8) & 1) ^ 1;
            core.regs.P.Z = (a & 0xFF) == 0;
            core.regs.P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DE__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) - 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_DF__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 32) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E0__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = core.regs.X - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E1__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.TR[0] ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 8: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E2__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E3__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] = (core.regs.TR[0] + 1) & 0xFFFF;
            core.regs.TR[1] += core.regs.TR[3] ? -1 : 1;
            core.regs.TR[1] &= 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E4__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = core.regs.X - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E5__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E6__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E7__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 6;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E8__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.X = ((core.regs.X) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.X) == 0;
            core.regs.P.N = ((core.regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_E9__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EA__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EB__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EC__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = core.regs.X - (core.pins.D);
            core.regs.P.C = ((o >> 8) & 1) ^ 1;
            core.regs.P.Z = (o & 0xFF) == 0;
            core.regs.P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_ED__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EE__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_EF__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 64) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F0__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            if (!core.regs.P.Z) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.TA = (core.regs.PC + (u32)(i8)core.pins.D) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// idle
            core.pins.RD = 0; 
            return; }
        case 4: {// cleanup_custom
            core.regs.PC = core.regs.TA;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F1__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 8: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F2__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            return; }
        case 5: {// load8
            core.regs.TR[1] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TA = core.regs.TR[0] | (core.regs.TR[1] << 8);
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 7: {// cleanup_custom
            core.regs.TR[0] = core.pins.D;
            core.regs.TR[0] ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.regs.TR[0]) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.regs.TR[0])) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.regs.TR[0]) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.regs.TR[0]) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 8: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F3__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.Y;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.A;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.X;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 8: {// load16
            core.regs.TR[6] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[0] |= core.regs.TR[6] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 9: {// load16
            core.regs.TR[1] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 10: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[1] |= core.regs.TR[5] << 8;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 11: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 12: {// load16
            core.regs.TR[5] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TR[2] |= core.regs.TR[5] << 8;
            core.pins.RD = 0; 
            return; }
        case 13: {// idle
            core.pins.BM = 1;
            core.regs.TR[3] = 0;
            return; }
        case 14: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[0])>>13] | ((core.regs.TR[0]) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 15: {// load16
            core.regs.TR[4] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 16: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.TR[1]) >> 13] | ((core.regs.TR[1]) & 0x1FFF);
            core.pins.D = core.regs.TR[4];
            core.pins.WR = 1;
            return; }
        case 17: {// store16
            core.regs.TR[0] += core.regs.TR[3] ? -1 : 1;
            core.regs.TR[0] &= 0xFFFF;
            core.regs.TR[1] = (core.regs.TR[1] + 1) & 0xFFFF;
            core.regs.TR[3] ^= 1;
            core.pins.WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            core.regs.TR[2] = (core.regs.TR[2] - 1) & 0xFFFF;
            if (core.regs.TR[2]) core.regs.TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 21: {// pull
            core.regs.X = core.pins.D;
            core.pins.BM = 0;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 22: {// pull
            core.regs.A = core.pins.D;
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            return; }
        case 23: {// cleanup_custom
            core.regs.Y = core.pins.D;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F4__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.T = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F5__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F6__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 6: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F7__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 4: {// load8
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            core.regs.TR[0] |= 1 << 7;
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.D = core.regs.TR[0];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F8__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            core.regs.P.D = 1;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_F9__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.Y) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FA__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.regs.S = (core.regs.S + 1) & 0xFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.RD = 1; 
            return; }
        case 4: {// cleanup_custom
            core.regs.X = core.pins.D;
            core.regs.P.Z = (core.regs.X) == 0;
            core.regs.P.N = ((core.regs.X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FB__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FC__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FD__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + core.regs.X) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// cleanup_custom
            core.pins.D ^= 0xFF;
            i16 out = (i16)core.regs.A + (i16)(core.pins.D) + (i16)core.regs.P.C;
            if (!core.regs.P.D) {
                core.regs.P.C = out > 0xFF;
                core.regs.P.V = ((~(core.regs.A ^ (core.pins.D)) & (core.regs.A ^ out)) >> 7) & 1;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            else { // if decimal
                out = (core.regs.A & 15) + ((core.pins.D) & 15) + core.regs.P.C;
                if (out <= 15) out -= 6;
                out = ((core.pins.D) & 0xF0) + (core.regs.A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                core.regs.P.C = out > 0xFF;
                out &= 0xFF;
            core.regs.P.Z = (out) == 0;
            core.regs.P.N = ((out) & 0x80) >> 7;
            core.regs.A = out;
            }
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FE__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 3: {// load16
            core.regs.TR[0] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.regs.TA |= core.regs.TR[0] << 8;
            core.pins.RD = 0; 
            return; }
        case 4: {// idle
            core.regs.TA = (core.regs.TA + (core.regs.X)) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 5: {// load16
            core.regs.TR[0] = core.pins.D;
            core.pins.RD = 0; 
            return; }
        case 6: {// idle
            core.regs.TR[1] = ((core.regs.TR[0]) + 1) & 0xFF;
            core.regs.P.Z = (core.regs.TR[1]) == 0;
            core.regs.P.N = ((core.regs.TR[1]) & 0x80) >> 7;
            core.pins.Addr = core.regs.MPR[(core.regs.TA) >> 13] | ((core.regs.TA) & 0x1FFF);
            core.pins.D = core.regs.TR[1];
            // Following is auto-generated code for instruction finish
            core.pins.WR = 1;
            return; }
        case 7: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; core.pins.WR = 0;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_FF__t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            return; }
        case 2: {// load16
            core.regs.TA = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 3: {// idle
            core.pins.Addr = core.regs.MPR[(core.regs.PC)>>13] | ((core.regs.PC) & 0x1FFF);
            core.pins.RD = 1; 
            return; }
        case 4: {// load16
            core.regs.TR[2] = core.pins.D;
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 5: {// idle
            core.pins.Addr = core.regs.MPR[1] | (core.regs.TA);
            core.pins.RD = 1; 
            return; }
        case 6: {// load8
            if ((core.pins.D & 128) == 0) {
                core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
                core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
                core.pins.RD = 1;
                core.regs.P.T = 0;
                core.poll_IRQs();
                core.regs.TCU = 0;
                return;
            }
            core.regs.PC = (core.regs.PC + (u32)(i8)core.regs.TR[2]) & 0xFFFF;
            core.pins.RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_RESET_t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.RD = 0; 
            return; }
        case 2: {// 3
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 3: {// 4
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 4: {// 5
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// 6
            core.pins.Addr = core.regs.S | 0x100;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// 7
            core.regs.MPR[7] = 0;
            core.regs.MPL = 0;
            core.regs.P.I = 1;
            core.regs.P.D = core.regs.P.T = 0;
            core.regs.IRQD.u = 7;
            core.regs.timer_startstop = 0;
            core.regs.clock_div = 12;
            core.pins.Addr = 0x1FFE;
            core.regs.S = 0;
            core.pins.RD = 1; 
            return; }
        case 7: {// 8
            core.regs.PC = core.pins.D;
            core.pins.Addr++;
            return; }
        case 8: {// 9
            core.pins.RD = 0; 
            return; }
        case 9: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.pins.RD = 1; 
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_IRQ2_t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            core.regs.PC = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u & 0xEF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.regs.P.I = 1;
            core.regs.P.D = 0;
            core.regs.P.T = 0;
            core.regs.TA = 0xFFF6;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_IRQ1_t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            core.regs.PC = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u & 0xEF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.regs.P.I = 1;
            core.regs.P.D = 0;
            core.regs.P.T = 0;
            core.regs.TA = 0xFFF8;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}


// 
static void ins_TIQ_t1(core &core)
{
    switch(core.regs.TCU) {
        case 1: {// start cycle
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            core.regs.PC = (core.regs.PC - 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC >> 8;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            core.pins.RD = 0; core.pins.WR = 1;
            return; }
        case 4: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.PC & 0xFF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 5: {// push
            core.pins.Addr = core.regs.MPR[1] | 0x100 | core.regs.S;
            core.pins.D = core.regs.P.u & 0xEF;
            core.regs.S = (core.regs.S - 1) & 0xFF;
            return; }
        case 6: {// push
            core.regs.P.I = 1;
            core.regs.P.D = 0;
            core.regs.P.T = 0;
            core.regs.TA = 0xFFFA;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            core.pins.RD = 1; core.pins.WR = 0;
            return; }
        case 7: {// load16
            core.regs.PC = core.pins.D;
            core.regs.TA = (core.regs.TA + 1) & 0xFFFF;
            core.pins.Addr = core.regs.MPR[(core.regs.TA)>>13] | ((core.regs.TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            core.regs.PC |= core.pins.D << 8;
            // Following is auto-generated code for instruction finish
            core.pins.Addr = core.regs.MPR[core.regs.PC >> 13] | (core.regs.PC & 0x1FFF);
            core.regs.PC = (core.regs.PC + 1) & 0xFFFF;
            core.poll_IRQs();
            core.regs.P.T = 0;
            core.regs.TCU = 0;
            return;
        }
    }
}




ins_func decoded_opcodes[2][0x104] = {
        &ins_00__t0,  &ins_01__t0,  &ins_02__t0,  &ins_03__t0,  &ins_04__t0,  &ins_05__t0,  &ins_06__t0,  &ins_07__t0,
      &ins_08__t0,  &ins_09__t0,  &ins_0A__t0,  &ins_0B__t0,  &ins_0C__t0,  &ins_0D__t0,  &ins_0E__t0,  &ins_0F__t0,
      &ins_10__t0,  &ins_11__t0,  &ins_12__t0,  &ins_13__t0,  &ins_14__t0,  &ins_15__t0,  &ins_16__t0,  &ins_17__t0,
      &ins_18__t0,  &ins_19__t0,  &ins_1A__t0,  &ins_1B__t0,  &ins_1C__t0,  &ins_1D__t0,  &ins_1E__t0,  &ins_1F__t0,
      &ins_20__t0,  &ins_21__t0,  &ins_22__t0,  &ins_23__t0,  &ins_24__t0,  &ins_25__t0,  &ins_26__t0,  &ins_27__t0,
      &ins_28__t0,  &ins_29__t0,  &ins_2A__t0,  &ins_2B__t0,  &ins_2C__t0,  &ins_2D__t0,  &ins_2E__t0,  &ins_2F__t0,
      &ins_30__t0,  &ins_31__t0,  &ins_32__t0,  &ins_33__t0,  &ins_34__t0,  &ins_35__t0,  &ins_36__t0,  &ins_37__t0,
      &ins_38__t0,  &ins_39__t0,  &ins_3A__t0,  &ins_3B__t0,  &ins_3C__t0,  &ins_3D__t0,  &ins_3E__t0,  &ins_3F__t0,
      &ins_40__t0,  &ins_41__t0,  &ins_42__t0,  &ins_43__t0,  &ins_44__t0,  &ins_45__t0,  &ins_46__t0,  &ins_47__t0,
      &ins_48__t0,  &ins_49__t0,  &ins_4A__t0,  &ins_4B__t0,  &ins_4C__t0,  &ins_4D__t0,  &ins_4E__t0,  &ins_4F__t0,
      &ins_50__t0,  &ins_51__t0,  &ins_52__t0,  &ins_53__t0,  &ins_54__t0,  &ins_55__t0,  &ins_56__t0,  &ins_57__t0,
      &ins_58__t0,  &ins_59__t0,  &ins_5A__t0,  &ins_5B__t0,  &ins_5C__t0,  &ins_5D__t0,  &ins_5E__t0,  &ins_5F__t0,
      &ins_60__t0,  &ins_61__t0,  &ins_62__t0,  &ins_63__t0,  &ins_64__t0,  &ins_65__t0,  &ins_66__t0,  &ins_67__t0,
      &ins_68__t0,  &ins_69__t0,  &ins_6A__t0,  &ins_6B__t0,  &ins_6C__t0,  &ins_6D__t0,  &ins_6E__t0,  &ins_6F__t0,
      &ins_70__t0,  &ins_71__t0,  &ins_72__t0,  &ins_73__t0,  &ins_74__t0,  &ins_75__t0,  &ins_76__t0,  &ins_77__t0,
      &ins_78__t0,  &ins_79__t0,  &ins_7A__t0,  &ins_7B__t0,  &ins_7C__t0,  &ins_7D__t0,  &ins_7E__t0,  &ins_7F__t0,
      &ins_80__t0,  &ins_81__t0,  &ins_82__t0,  &ins_83__t0,  &ins_84__t0,  &ins_85__t0,  &ins_86__t0,  &ins_87__t0,
      &ins_88__t0,  &ins_89__t0,  &ins_8A__t0,  &ins_8B__t0,  &ins_8C__t0,  &ins_8D__t0,  &ins_8E__t0,  &ins_8F__t0,
      &ins_90__t0,  &ins_91__t0,  &ins_92__t0,  &ins_93__t0,  &ins_94__t0,  &ins_95__t0,  &ins_96__t0,  &ins_97__t0,
      &ins_98__t0,  &ins_99__t0,  &ins_9A__t0,  &ins_9B__t0,  &ins_9C__t0,  &ins_9D__t0,  &ins_9E__t0,  &ins_9F__t0,
      &ins_A0__t0,  &ins_A1__t0,  &ins_A2__t0,  &ins_A3__t0,  &ins_A4__t0,  &ins_A5__t0,  &ins_A6__t0,  &ins_A7__t0,
      &ins_A8__t0,  &ins_A9__t0,  &ins_AA__t0,  &ins_AB__t0,  &ins_AC__t0,  &ins_AD__t0,  &ins_AE__t0,  &ins_AF__t0,
      &ins_B0__t0,  &ins_B1__t0,  &ins_B2__t0,  &ins_B3__t0,  &ins_B4__t0,  &ins_B5__t0,  &ins_B6__t0,  &ins_B7__t0,
      &ins_B8__t0,  &ins_B9__t0,  &ins_BA__t0,  &ins_BB__t0,  &ins_BC__t0,  &ins_BD__t0,  &ins_BE__t0,  &ins_BF__t0,
      &ins_C0__t0,  &ins_C1__t0,  &ins_C2__t0,  &ins_C3__t0,  &ins_C4__t0,  &ins_C5__t0,  &ins_C6__t0,  &ins_C7__t0,
      &ins_C8__t0,  &ins_C9__t0,  &ins_CA__t0,  &ins_CB__t0,  &ins_CC__t0,  &ins_CD__t0,  &ins_CE__t0,  &ins_CF__t0,
      &ins_D0__t0,  &ins_D1__t0,  &ins_D2__t0,  &ins_D3__t0,  &ins_D4__t0,  &ins_D5__t0,  &ins_D6__t0,  &ins_D7__t0,
      &ins_D8__t0,  &ins_D9__t0,  &ins_DA__t0,  &ins_DB__t0,  &ins_DC__t0,  &ins_DD__t0,  &ins_DE__t0,  &ins_DF__t0,
      &ins_E0__t0,  &ins_E1__t0,  &ins_E2__t0,  &ins_E3__t0,  &ins_E4__t0,  &ins_E5__t0,  &ins_E6__t0,  &ins_E7__t0,
      &ins_E8__t0,  &ins_E9__t0,  &ins_EA__t0,  &ins_EB__t0,  &ins_EC__t0,  &ins_ED__t0,  &ins_EE__t0,  &ins_EF__t0,
      &ins_F0__t0,  &ins_F1__t0,  &ins_F2__t0,  &ins_F3__t0,  &ins_F4__t0,  &ins_F5__t0,  &ins_F6__t0,  &ins_F7__t0,
      &ins_F8__t0,  &ins_F9__t0,  &ins_FA__t0,  &ins_FB__t0,  &ins_FC__t0,  &ins_FD__t0,  &ins_FE__t0,  &ins_FF__t0,
      &ins_RESET_t0,  &ins_IRQ2_t0,  &ins_IRQ1_t0,  &ins_TIQ_t0,  &ins_00__t1,  &ins_01__t1,  &ins_02__t1,  &ins_03__t1,
      &ins_04__t1,  &ins_05__t1,  &ins_06__t1,  &ins_07__t1,  &ins_08__t1,  &ins_09__t1,  &ins_0A__t1,  &ins_0B__t1,
      &ins_0C__t1,  &ins_0D__t1,  &ins_0E__t1,  &ins_0F__t1,  &ins_10__t1,  &ins_11__t1,  &ins_12__t1,  &ins_13__t1,
      &ins_14__t1,  &ins_15__t1,  &ins_16__t1,  &ins_17__t1,  &ins_18__t1,  &ins_19__t1,  &ins_1A__t1,  &ins_1B__t1,
      &ins_1C__t1,  &ins_1D__t1,  &ins_1E__t1,  &ins_1F__t1,  &ins_20__t1,  &ins_21__t1,  &ins_22__t1,  &ins_23__t1,
      &ins_24__t1,  &ins_25__t1,  &ins_26__t1,  &ins_27__t1,  &ins_28__t1,  &ins_29__t1,  &ins_2A__t1,  &ins_2B__t1,
      &ins_2C__t1,  &ins_2D__t1,  &ins_2E__t1,  &ins_2F__t1,  &ins_30__t1,  &ins_31__t1,  &ins_32__t1,  &ins_33__t1,
      &ins_34__t1,  &ins_35__t1,  &ins_36__t1,  &ins_37__t1,  &ins_38__t1,  &ins_39__t1,  &ins_3A__t1,  &ins_3B__t1,
      &ins_3C__t1,  &ins_3D__t1,  &ins_3E__t1,  &ins_3F__t1,  &ins_40__t1,  &ins_41__t1,  &ins_42__t1,  &ins_43__t1,
      &ins_44__t1,  &ins_45__t1,  &ins_46__t1,  &ins_47__t1,  &ins_48__t1,  &ins_49__t1,  &ins_4A__t1,  &ins_4B__t1,
      &ins_4C__t1,  &ins_4D__t1,  &ins_4E__t1,  &ins_4F__t1,  &ins_50__t1,  &ins_51__t1,  &ins_52__t1,  &ins_53__t1,
      &ins_54__t1,  &ins_55__t1,  &ins_56__t1,  &ins_57__t1,  &ins_58__t1,  &ins_59__t1,  &ins_5A__t1,  &ins_5B__t1,
      &ins_5C__t1,  &ins_5D__t1,  &ins_5E__t1,  &ins_5F__t1,  &ins_60__t1,  &ins_61__t1,  &ins_62__t1,  &ins_63__t1,
      &ins_64__t1,  &ins_65__t1,  &ins_66__t1,  &ins_67__t1,  &ins_68__t1,  &ins_69__t1,  &ins_6A__t1,  &ins_6B__t1,
      &ins_6C__t1,  &ins_6D__t1,  &ins_6E__t1,  &ins_6F__t1,  &ins_70__t1,  &ins_71__t1,  &ins_72__t1,  &ins_73__t1,
      &ins_74__t1,  &ins_75__t1,  &ins_76__t1,  &ins_77__t1,  &ins_78__t1,  &ins_79__t1,  &ins_7A__t1,  &ins_7B__t1,
      &ins_7C__t1,  &ins_7D__t1,  &ins_7E__t1,  &ins_7F__t1,  &ins_80__t1,  &ins_81__t1,  &ins_82__t1,  &ins_83__t1,
      &ins_84__t1,  &ins_85__t1,  &ins_86__t1,  &ins_87__t1,  &ins_88__t1,  &ins_89__t1,  &ins_8A__t1,  &ins_8B__t1,
      &ins_8C__t1,  &ins_8D__t1,  &ins_8E__t1,  &ins_8F__t1,  &ins_90__t1,  &ins_91__t1,  &ins_92__t1,  &ins_93__t1,
      &ins_94__t1,  &ins_95__t1,  &ins_96__t1,  &ins_97__t1,  &ins_98__t1,  &ins_99__t1,  &ins_9A__t1,  &ins_9B__t1,
      &ins_9C__t1,  &ins_9D__t1,  &ins_9E__t1,  &ins_9F__t1,  &ins_A0__t1,  &ins_A1__t1,  &ins_A2__t1,  &ins_A3__t1,
      &ins_A4__t1,  &ins_A5__t1,  &ins_A6__t1,  &ins_A7__t1,  &ins_A8__t1,  &ins_A9__t1,  &ins_AA__t1,  &ins_AB__t1,
      &ins_AC__t1,  &ins_AD__t1,  &ins_AE__t1,  &ins_AF__t1,  &ins_B0__t1,  &ins_B1__t1,  &ins_B2__t1,  &ins_B3__t1,
      &ins_B4__t1,  &ins_B5__t1,  &ins_B6__t1,  &ins_B7__t1,  &ins_B8__t1,  &ins_B9__t1,  &ins_BA__t1,  &ins_BB__t1,
      &ins_BC__t1,  &ins_BD__t1,  &ins_BE__t1,  &ins_BF__t1,  &ins_C0__t1,  &ins_C1__t1,  &ins_C2__t1,  &ins_C3__t1,
      &ins_C4__t1,  &ins_C5__t1,  &ins_C6__t1,  &ins_C7__t1,  &ins_C8__t1,  &ins_C9__t1,  &ins_CA__t1,  &ins_CB__t1,
      &ins_CC__t1,  &ins_CD__t1,  &ins_CE__t1,  &ins_CF__t1,  &ins_D0__t1,  &ins_D1__t1,  &ins_D2__t1,  &ins_D3__t1,
      &ins_D4__t1,  &ins_D5__t1,  &ins_D6__t1,  &ins_D7__t1,  &ins_D8__t1,  &ins_D9__t1,  &ins_DA__t1,  &ins_DB__t1,
      &ins_DC__t1,  &ins_DD__t1,  &ins_DE__t1,  &ins_DF__t1,  &ins_E0__t1,  &ins_E1__t1,  &ins_E2__t1,  &ins_E3__t1,
      &ins_E4__t1,  &ins_E5__t1,  &ins_E6__t1,  &ins_E7__t1,  &ins_E8__t1,  &ins_E9__t1,  &ins_EA__t1,  &ins_EB__t1,
      &ins_EC__t1,  &ins_ED__t1,  &ins_EE__t1,  &ins_EF__t1,  &ins_F0__t1,  &ins_F1__t1,  &ins_F2__t1,  &ins_F3__t1,
      &ins_F4__t1,  &ins_F5__t1,  &ins_F6__t1,  &ins_F7__t1,  &ins_F8__t1,  &ins_F9__t1,  &ins_FA__t1,  &ins_FB__t1,
      &ins_FC__t1,  &ins_FD__t1,  &ins_FE__t1,  &ins_FF__t1,  &ins_RESET_t1,  &ins_IRQ2_t1,  &ins_IRQ1_t1,  &ins_TIQ_t1
  
};

}
