#include <stdio.h>
#include <assert.h>
#include "helpers/int.h"
#include "helpers/debugger/debugger.h"
#include "huc6280_opcodes.h"
#include "huc6280.h"

// This file auto-generated byhuc6280_gen.py in JSMooCh

// 
static void HUC6280_ins_00__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 4: {// push
            regs->P.T = 0;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u | 0x10;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            regs->P.D = 0; regs->P.I = 1;
            pins->Addr = regs->MPR[(0xFFF6)>>13] | ((0xFFF6) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 6: {// load16
            regs->PC = pins->D;
            pins->Addr = regs->MPR[(0xFFF7)>>13] | ((0xFFF7) & 0x1FFF);
            return; }
        case 7: {// load16
            regs->TA = pins->D;
            regs->PC |= regs->TA << 8;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_01__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_02__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// cleanup_custom
            regs->TA = regs->X;
            regs->X = regs->Y;
            regs->Y = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_03__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = 0x1FE000;
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_04__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 o = (regs->TR[0]) | regs->A;
            regs->P.Z = o == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->TR[1] = (regs->TR[0]) | regs->A;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_05__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = regs->A | (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_06__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_07__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 0);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_08__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = (regs->P.u | 0x10) & 0xDF;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_09__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->A = regs->A | (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = ((regs->A) >> 7) & 1;
            regs->A = (regs->A << 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 o = (regs->TR[0]) | regs->A;
            regs->P.Z = o == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->TR[1] = (regs->TR[0]) | regs->A;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A | (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 1) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_10__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.N) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_11__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->A = regs->A | (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_12__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_13__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = 0x1FE002;
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_14__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.Z = (regs->A & (regs->TR[0])) == 0;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = ~regs->A & (regs->TR[0]);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_15__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = regs->A | (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_16__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_17__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 1);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_18__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_19__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A | (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = ((regs->A) + 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.Z = (regs->A & (regs->TR[0])) == 0;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = ~regs->A & (regs->TR[0]);
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A | (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 2) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_20__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_21__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_22__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// cleanup_custom
            regs->TA = regs->A;
            regs->A = regs->X;
            regs->X = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_23__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = 0x1FE003;
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_24__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_25__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = regs->A & (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_26__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_27__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 2);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_28__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.u = pins->D;
            regs->P.u &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_29__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->A = regs->A & (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = regs->P.C;
            regs->P.C = ((regs->A) >> 7) & 1;
            regs->A = ((regs->A << 1) & 0xFF) | c;
            regs->P.Z = regs->A == 0;
            regs->P.N = ((regs->A) >> 7) & 1;
            regs->A = (regs->A);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A & (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 4) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_30__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.N) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_31__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->A = regs->A & (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_32__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_33__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_34__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_35__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = regs->A & (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_36__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_37__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 3);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_38__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_39__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A & (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = ((regs->A) - 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A & (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 8) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_40__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// pull
            regs->P.u = pins->D;
            regs->P.u &= 0xEF;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 5: {// pull
            regs->PC = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 6: {// cleanup_custom
            regs->TA = pins->D;
            regs->PC |= regs->TA << 8;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_41__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_42__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// cleanup_custom
            regs->TA = regs->A;
            regs->A = regs->Y;
            regs->Y = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_43__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            if (regs->TR[0]) {
                regs->MPL = 0;
                for (u32 i = 0; i < 8; i++) { // inspired by Ares handling
                    u32 shift = 1 << i;
                    if (regs->TR[0] & shift)
                        regs->MPL |= (regs->MPR[i] >> 13);
                }
            }
            regs->A = regs->MPL;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_44__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (u32)(i8)regs->TA;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TR[0] = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->TR[0] >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            regs->PC += regs->TA;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->TR[0] & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->WR = 0;
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_45__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = regs->A ^ (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_46__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_47__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 4);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_48__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_49__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->A = regs->A ^ (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = (regs->A) & 1;
            regs->A = (regs->A) >> 1;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A ^ (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 16) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_50__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.V) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_51__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->A = regs->A ^ (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_52__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_53__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// idle
            if (regs->TA) {
                regs->MPL = regs->A;
                u32 mpl = regs->MPL << 13;
                for (u32 i = 0; i < 8; i++) {
                    u32 shifted = 1 << i;
                    if ((regs->TA & shifted) && (regs->MPR[i] != mpl)) {
                        debugger_interface_dirty_mem(pins->debugger_interface, pins->debugger_mem_bus, mpl, ((i + 1) << 13) - 1);
                        regs->MPR[i] = mpl;
                    }
                }
            }
            // Following is auto-generated code for instruction finish
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_54__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            regs->clock_div = 12;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_55__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = regs->A ^ (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_56__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_57__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 5);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_58__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.I = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_59__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A ^ (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->A = regs->A ^ (pins->D);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 32) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_60__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// pull
            regs->PC = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 5: {// pull
            regs->TA = pins->D;
            regs->PC |= regs->TA << 8;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_61__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_62__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_63__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_64__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_65__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_66__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_67__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 6);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_68__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = pins->D;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_69__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->A) & 1;
            c = (((regs->A) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->A = c;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            regs->PC |= regs->TR[0] << 8;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 64) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_70__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.V) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_71__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_72__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_73__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] + 1) & 0xFFFF;
            regs->TR[1] = (regs->TR[1] + 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_74__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->X) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_75__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_76__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_77__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 7);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_78__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            HUC6280_poll_IRQs(regs, pins);
            return; }
        case 2: {// cleanup_custom
            regs->P.I = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_79__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->Y = pins->D;
            regs->P.Z = (regs->Y) == 0;
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            regs->PC |= regs->TR[0] << 8;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 128) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_80__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_81__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_82__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_83__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TR[1]);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            regs->TA = pins->D;
            regs->P.Z = (regs->TR[0] & regs->TA) == 0;
            regs->P.V = (regs->TA >> 6) & 1;
            regs->P.N = (regs->TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_84__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->Y;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_85__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_86__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->X;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_87__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 0;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_88__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = ((regs->Y) - 1) & 0xFF;
            regs->P.Z = (regs->Y) == 0;
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_89__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = regs->X;
            regs->P.Z = regs->A == 0;
            regs->P.N = (regs->A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->Y;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->X;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 1) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_90__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.C) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_91__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            regs->TR[0] |= regs->TR[1] << 8;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = (regs->TR[0] + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_92__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_93__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 4: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[1] << 8;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[2] = pins->D;
            pins->RD = 0; 
            return; }
        case 8: {// cleanup_custom
            regs->P.Z = (regs->TR[2] & regs->TR[0]) == 0;
            regs->P.V = (regs->TR[2] >> 6) & 1;
            regs->P.N = (regs->TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_94__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->X) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->Y;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_95__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->X) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_96__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->Y) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->X;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_97__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 1;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_98__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = regs->Y;
            regs->P.Z = regs->A == 0;
            regs->P.N = (regs->A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_99__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9A__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->S = regs->X;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9B__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9C__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9D__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9E__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9F__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 2) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A0__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A1__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = (regs->TR[0] >> 7) & 1;
            regs->A = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A2__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A3__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            regs->TR[1] = (regs->TR[1] + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TR[1]);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            regs->TA = pins->D;
            regs->P.Z = (regs->TR[0] & regs->TA) == 0;
            regs->P.V = (regs->TA >> 6) & 1;
            regs->P.N = (regs->TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A4__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A5__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A6__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A7__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 2;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A8__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = regs->A;
            regs->P.Z = regs->Y == 0;
            regs->P.N = (regs->Y >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A9__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AA__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = regs->A;
            regs->P.Z = regs->X == 0;
            regs->P.N = (regs->X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AB__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AC__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AD__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AE__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AF__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 4) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B0__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.C) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B1__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B2__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = (regs->TR[0] >> 7) & 1;
            regs->A = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B3__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 4: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[1] << 8;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TA = (regs->TA + regs->X ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[2] = pins->D;
            pins->RD = 0; 
            return; }
        case 8: {// cleanup_custom
            regs->P.Z = (regs->TR[2] & regs->TR[0]) == 0;
            regs->P.V = (regs->TR[2] >> 6) & 1;
            regs->P.N = (regs->TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B4__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B5__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B6__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B7__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 3;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B8__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.V = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B9__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BA__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = regs->S;
            regs->P.Z = regs->X == 0;
            regs->P.N = (regs->X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BB__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BC__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BD__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BE__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BF__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 8) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C0__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = regs->Y - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C1__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            u32 a = (regs->A - (regs->TR[0])) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C2__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C3__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] - 1) & 0xFFFF;
            regs->TR[1] = (regs->TR[1] - 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C4__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = regs->Y - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C5__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C6__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C7__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 4;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C8__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = ((regs->Y) + 1) & 0xFF;
            regs->P.Z = (regs->Y) == 0;
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C9__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CA__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = ((regs->X) - 1) & 0xFF;
            regs->P.Z = (regs->X) == 0;
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CB__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CC__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = regs->Y - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CD__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CE__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CF__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 16) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D0__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.Z) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D1__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D2__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            u32 a = (regs->A - (regs->TR[0])) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D3__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] + 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D4__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            regs->clock_div = 3;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D5__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D6__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D7__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 5;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D8__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.D = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D9__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DA__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DB__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DC__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DD__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DE__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DF__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 32) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E0__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = regs->X - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E1__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->TR[0] ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E2__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E3__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] + 1) & 0xFFFF;
            regs->TR[1] += regs->TR[3] ? -1 : 1;
            regs->TR[1] &= 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E4__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = regs->X - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E5__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E6__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E7__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 6;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E8__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = ((regs->X) + 1) & 0xFF;
            regs->P.Z = (regs->X) == 0;
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E9__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EA__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EB__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EC__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = regs->X - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_ED__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EE__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EF__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 64) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F0__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.Z) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F1__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F2__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->TR[0] ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 8: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F3__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] += regs->TR[3] ? -1 : 1;
            regs->TR[0] &= 0xFFFF;
            regs->TR[1] = (regs->TR[1] + 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F4__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.T = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F5__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 5: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F6__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F7__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F8__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.D = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F9__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FA__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->X = pins->D;
            regs->P.Z = (regs->X) == 0;
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FB__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FC__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FD__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 6: {// dummy read...
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FE__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FF__t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 128) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_RESET_t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->RD = 0; 
            return; }
        case 2: {// 3
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 3: {// 4
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 4: {// 5
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// 6
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// 7
            regs->MPR[7] = 0;
            regs->MPL = 0;
            regs->P.I = 1;
            regs->P.D = regs->P.T = 0;
            regs->IRQD.u = 7;
            regs->timer_startstop = 0;
            regs->clock_div = 12;
            pins->Addr = 0x1FFE;
            regs->S = 0;
            pins->RD = 1; 
            return; }
        case 7: {// 8
            regs->PC = pins->D;
            pins->Addr++;
            return; }
        case 8: {// 9
            pins->RD = 0; 
            return; }
        case 9: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_IRQ2_t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            regs->PC = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u & 0xEF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            regs->P.I = 1;
            regs->P.D = 0;
            regs->P.T = 0;
            regs->TA = 0xFFF6;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_IRQ1_t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            regs->PC = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u & 0xEF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            regs->P.I = 1;
            regs->P.D = 0;
            regs->P.T = 0;
            regs->TA = 0xFFF8;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_TIQ_t0(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            regs->PC = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u & 0xEF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            regs->P.I = 1;
            regs->P.D = 0;
            regs->P.T = 0;
            regs->TA = 0xFFFA;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_00__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 4: {// push
            regs->P.T = 0;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u | 0x10;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            regs->P.D = 0; regs->P.I = 1;
            pins->Addr = regs->MPR[(0xFFF6)>>13] | ((0xFFF6) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 6: {// load16
            regs->PC = pins->D;
            pins->Addr = regs->MPR[(0xFFF7)>>13] | ((0xFFF7) & 0x1FFF);
            return; }
        case 7: {// load16
            regs->TA = pins->D;
            regs->PC |= regs->TA << 8;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_01__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_02__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// cleanup_custom
            regs->TA = regs->X;
            regs->X = regs->Y;
            regs->Y = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_03__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = 0x1FE000;
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_04__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 o = (regs->TR[0]) | regs->A;
            regs->P.Z = o == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->TR[1] = (regs->TR[0]) | regs->A;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_05__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_06__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_07__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 0);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_08__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = (regs->P.u | 0x10) & 0xDF;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void HUC6280_ins_09__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 3: {// load8
            regs->A = pins->D;
            regs->A = regs->A | (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = ((regs->A) >> 7) & 1;
            regs->A = (regs->A << 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            regs->A = regs->A;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 o = (regs->TR[0]) | regs->A;
            regs->P.Z = o == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->TR[1] = (regs->TR[0]) | regs->A;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_0D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_0F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 1) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_10__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.N) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void HUC6280_ins_11__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[3] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A | (regs->TR[3]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_12__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_13__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = 0x1FE002;
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_14__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.Z = (regs->A & (regs->TR[0])) == 0;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = ~regs->A & (regs->TR[0]);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_15__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_16__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_17__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 1);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_18__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_19__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = ((regs->A) + 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.Z = (regs->A & (regs->TR[0])) == 0;
            regs->P.V = ((regs->TR[0]) >> 6) & 1;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = ~regs->A & (regs->TR[0]);
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_1D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A | (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = (regs->TR[0] << 1) & 0xFF;
            regs->P.Z = (regs->TR[0]) == 0;
            regs->P.N = ((regs->TR[0]) & 0x80) >> 7;
            regs->TR[1] = regs->TR[0];
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_1F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 2) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_20__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_21__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_22__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// cleanup_custom
            regs->TA = regs->A;
            regs->A = regs->X;
            regs->X = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_23__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = 0x1FE003;
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_24__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_25__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_26__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_27__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 2);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_28__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.u = pins->D;
            regs->P.u &= 0xEF;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void HUC6280_ins_29__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 3: {// load8
            regs->A = pins->D;
            regs->A = regs->A & (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = regs->P.C;
            regs->P.C = ((regs->A) >> 7) & 1;
            regs->A = ((regs->A << 1) & 0xFF) | c;
            regs->P.Z = regs->A == 0;
            regs->P.N = ((regs->A) >> 7) & 1;
            regs->A = (regs->A);
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_2D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_2F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 4) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_30__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.N) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void HUC6280_ins_31__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[3] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A & (regs->TR[3]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_32__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_33__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_34__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_35__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_36__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_37__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 3);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_38__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_39__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = ((regs->A) - 1) & 0xFF;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_3D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A & (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C;
            regs->P.C = ((regs->TR[0]) >> 7) & 1;
            regs->TR[0] = ((regs->TR[0] << 1) & 0xFF) | c;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = ((regs->TR[0]) >> 7) & 1;
            regs->TR[1] = (regs->TR[0]);
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_3F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 8) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_40__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// pull
            regs->P.u = pins->D;
            regs->P.u &= 0xEF;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 5: {// pull
            regs->PC = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 6: {// cleanup_custom
            regs->TA = pins->D;
            regs->PC |= regs->TA << 8;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_41__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_42__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// cleanup_custom
            regs->TA = regs->A;
            regs->A = regs->Y;
            regs->Y = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_43__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            if (regs->TR[0]) {
                regs->MPL = 0;
                for (u32 i = 0; i < 8; i++) { // inspired by Ares handling
                    u32 shift = 1 << i;
                    if (regs->TR[0] & shift)
                        regs->MPL |= (regs->MPR[i] >> 13);
                }
            }
            regs->A = regs->MPL;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_44__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (u32)(i8)regs->TA;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TR[0] = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->TR[0] >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            regs->PC += regs->TA;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->TR[0] & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->WR = 0;
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_45__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_46__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_47__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 4);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_48__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void HUC6280_ins_49__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 3: {// load8
            regs->A = pins->D;
            regs->A = regs->A ^ (regs->TA);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.C = (regs->A) & 1;
            regs->A = (regs->A) >> 1;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_4D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_4F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 16) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_50__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.V) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void HUC6280_ins_51__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[3] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A ^ (regs->TR[3]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_52__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 9: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 10: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_53__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// idle
            if (regs->TA) {
                regs->MPL = regs->A;
                u32 mpl = regs->MPL << 13;
                for (u32 i = 0; i < 8; i++) {
                    u32 shifted = 1 << i;
                    if ((regs->TA & shifted) && (regs->MPR[i] != mpl)) {
                        debugger_interface_dirty_mem(pins->debugger_interface, pins->debugger_mem_bus, mpl, ((i + 1) << 13) - 1);
                        regs->MPR[i] = mpl;
                    }
                }
            }
            // Following is auto-generated code for instruction finish
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_54__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            regs->clock_div = 12;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_55__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_56__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_57__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 5);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_58__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.I = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_59__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_5D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            regs->A = regs->A ^ (regs->TR[0]);
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->P.C = (regs->TR[0]) & 1;
            regs->TR[1] = (regs->TR[0]) >> 1;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_5F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 32) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_60__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// pull
            regs->PC = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 5: {// pull
            regs->TA = pins->D;
            regs->PC |= regs->TA << 8;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->PC = (regs->PC + 1) & 0xFFFF;
            // Following is auto-generated code for instruction finish
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_61__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 9: {// idle
            return; }
        case 10: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_62__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_63__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_64__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_65__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_66__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_67__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 6);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_68__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->A = pins->D;
            regs->P.Z = (regs->A) == 0;
            regs->P.N = ((regs->A) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// immediate_memory
static void HUC6280_ins_69__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 3: {// load8
            regs->A = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TA) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TA)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TA) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TA) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->A) & 1;
            c = (((regs->A) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->A = c;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            regs->PC |= regs->TR[0] << 8;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_6D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 7: {// idle
            return; }
        case 8: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_6F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 64) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_70__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.V) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_y_read_memory
static void HUC6280_ins_71__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[3] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[3]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[3])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[3]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[3]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 9: {// idle
            return; }
        case 10: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// indirect_read_memory
static void HUC6280_ins_72__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 8: {// load8
            regs->A = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 9: {// idle
            return; }
        case 10: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 11: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_73__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] + 1) & 0xFFFF;
            regs->TR[1] = (regs->TR[1] + 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_74__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->X) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// zero_page_read_memory
static void HUC6280_ins_75__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->A = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 5: {// load8
            regs->TR[0] = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 6: {// idle
            return; }
        case 7: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_76__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_77__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] &= ~(1 << 7);
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_78__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            HUC6280_poll_IRQs(regs, pins);
            return; }
        case 2: {// cleanup_custom
            regs->P.I = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_79__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 7: {// idle
            return; }
        case 8: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->Y = pins->D;
            regs->P.Z = (regs->Y) == 0;
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 6: {// load16
            regs->TR[0] = pins->D;
            regs->PC |= regs->TR[0] << 8;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// absolute_read_memory
static void HUC6280_ins_7D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            regs->TR[2] = regs->A;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->Addr = regs->MPR[1] | (regs->X);
            return; }
        case 6: {// load8
            regs->A = pins->D;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                regs->TCU++;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out > 9) out += 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out > 0x9F) out += 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 7: {// idle
            return; }
        case 8: {// idle
            pins->Addr = regs->MPR[1] | (regs->X);
            pins->D = regs->A;
            regs->A = regs->TR[2];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 9: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            u32 c = regs->P.C << 7;
            regs->P.C = (regs->TR[0]) & 1;
            c = (((regs->TR[0]) >> 1) | c) & 0xFF;
            regs->P.Z = c == 0;
            regs->P.N = (c >> 7) & 1;
            regs->TR[1] = c;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_7F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 128) != 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_80__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_81__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X )) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_82__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_83__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TR[1]);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            regs->TA = pins->D;
            regs->P.Z = (regs->TR[0] & regs->TA) == 0;
            regs->P.V = (regs->TA >> 6) & 1;
            regs->P.N = (regs->TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_84__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->Y;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_85__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_86__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->X;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_87__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 0;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_88__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = ((regs->Y) - 1) & 0xFF;
            regs->P.Z = (regs->Y) == 0;
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_89__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.V = ((pins->D) >> 6) & 1;
            regs->P.N = ((pins->D) >> 7) & 1;
            regs->P.Z = ((pins->D) & regs->A) == 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = regs->X;
            regs->P.Z = regs->A == 0;
            regs->P.N = (regs->A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->Y;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->X;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_8F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 1) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_90__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.C) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_91__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            regs->TR[0] |= regs->TR[1] << 8;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = (regs->TR[0] + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_92__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->RD = 0; 
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_93__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 4: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[1] << 8;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[2] = pins->D;
            pins->RD = 0; 
            return; }
        case 8: {// cleanup_custom
            regs->P.Z = (regs->TR[2] & regs->TR[0]) == 0;
            regs->P.V = (regs->TR[2] >> 6) & 1;
            regs->P.N = (regs->TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_94__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->X) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->Y;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_95__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->X) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_96__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + regs->Y) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->X;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 4: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_97__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 1;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_98__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->A = regs->Y;
            regs->P.Z = regs->A == 0;
            regs->P.N = (regs->A >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_99__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9A__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->S = regs->X;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9B__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9C__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9D__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->A;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9E__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = 0;
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 5: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_9F__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 2) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A0__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A1__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = (regs->TR[0] >> 7) & 1;
            regs->A = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A2__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A3__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            return; }
        case 5: {// idle
            regs->TR[1] = (regs->TR[1] + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TR[1]);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            regs->TA = pins->D;
            regs->P.Z = (regs->TR[0] & regs->TA) == 0;
            regs->P.V = (regs->TA >> 6) & 1;
            regs->P.N = (regs->TA >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A4__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A5__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A6__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A7__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 2;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A8__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = regs->A;
            regs->P.Z = regs->Y == 0;
            regs->P.N = (regs->Y >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_A9__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AA__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = regs->A;
            regs->P.Z = regs->X == 0;
            regs->P.N = (regs->X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AB__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AC__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AD__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AE__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_AF__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 4) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B0__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.C) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B1__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B2__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->P.Z = regs->TR[0] == 0;
            regs->P.N = (regs->TR[0] >> 7) & 1;
            regs->A = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B3__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 4: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[1] << 8;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TA = (regs->TA + regs->X ) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// load16
            regs->TR[2] = pins->D;
            pins->RD = 0; 
            return; }
        case 8: {// cleanup_custom
            regs->P.Z = (regs->TR[2] & regs->TR[0]) == 0;
            regs->P.V = (regs->TR[2] >> 6) & 1;
            regs->P.N = (regs->TR[2] >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B4__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B5__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B6__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->Y)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B7__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 3;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B8__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.V = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_B9__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BA__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = regs->S;
            regs->P.Z = regs->X == 0;
            regs->P.N = (regs->X >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BB__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BC__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BD__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->A = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BE__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            regs->P.Z = pins->D == 0;
            regs->P.N = (pins->D >> 7) & 1;
            regs->X = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_BF__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 8) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C0__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = regs->Y - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C1__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            u32 a = (regs->A - (regs->TR[0])) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C2__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C3__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] - 1) & 0xFFFF;
            regs->TR[1] = (regs->TR[1] - 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C4__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = regs->Y - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C5__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C6__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C7__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 4;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C8__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->Y = ((regs->Y) + 1) & 0xFF;
            regs->P.Z = (regs->Y) == 0;
            regs->P.N = ((regs->Y) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_C9__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CA__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = ((regs->X) - 1) & 0xFF;
            regs->P.Z = (regs->X) == 0;
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CB__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CC__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = regs->Y - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CD__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CE__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_CF__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 16) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D0__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!!regs->P.Z) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D1__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D2__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            u32 a = (regs->A - (regs->TR[0])) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D3__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] + 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D4__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            regs->clock_div = 3;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; 
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D5__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D6__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D7__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 5;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D8__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.D = 0;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_D9__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DA__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            // Following is auto-generated code for instruction finish
            pins->RD = 0; pins->WR = 1;
            return; }
        case 3: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DB__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DC__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DD__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 a = (regs->A - (pins->D)) & 0x1FF;
            regs->P.C = ((a >> 8) & 1) ^ 1;
            regs->P.Z = (a & 0xFF) == 0;
            regs->P.N = (a >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DE__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) - 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_DF__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 32) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E0__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            u32 o = regs->X - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E1__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->TR[0] ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 8: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E2__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E3__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] = (regs->TR[0] + 1) & 0xFFFF;
            regs->TR[1] += regs->TR[3] ? -1 : 1;
            regs->TR[1] &= 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E4__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            u32 o = regs->X - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E5__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 5: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E6__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E7__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 6;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E8__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->X = ((regs->X) + 1) & 0xFF;
            regs->P.Z = (regs->X) == 0;
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_E9__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            return; }
        case 2: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 3: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EA__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EB__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EC__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            u32 o = regs->X - (pins->D);
            regs->P.C = ((o >> 8) & 1) ^ 1;
            regs->P.Z = (o & 0xFF) == 0;
            regs->P.N = (o >> 7) & 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_ED__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 6: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EE__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_EF__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 64) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F0__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            if (!regs->P.Z) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->TA = (regs->PC + (u32)(i8)pins->D) & 0xFFFF;
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// idle
            pins->RD = 0; 
            return; }
        case 4: {// cleanup_custom
            regs->PC = regs->TA;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F1__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 8: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F2__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            regs->TA = (regs->TA + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            return; }
        case 5: {// load8
            regs->TR[1] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TA = regs->TR[0] | (regs->TR[1] << 8);
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 7: {// cleanup_custom
            regs->TR[0] = pins->D;
            regs->TR[0] ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(regs->TR[0]) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (regs->TR[0])) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((regs->TR[0]) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((regs->TR[0]) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 8: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F3__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->Y;
            regs->S = (regs->S - 1) & 0xFF;
            pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->A;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->X;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 8: {// load16
            regs->TR[6] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[0] |= regs->TR[6] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 9: {// load16
            regs->TR[1] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 10: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[1] |= regs->TR[5] << 8;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 11: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 12: {// load16
            regs->TR[5] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TR[2] |= regs->TR[5] << 8;
            pins->RD = 0; 
            return; }
        case 13: {// idle
            pins->BM = 1;
            regs->TR[3] = 0;
            return; }
        case 14: {// idle
            pins->Addr = regs->MPR[(regs->TR[0])>>13] | ((regs->TR[0]) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 15: {// load16
            regs->TR[4] = pins->D;
            pins->RD = 0; 
            return; }
        case 16: {// idle
            pins->Addr = regs->MPR[(regs->TR[1]) >> 13] | ((regs->TR[1]) & 0x1FFF);
            pins->D = regs->TR[4];
            pins->WR = 1;
            return; }
        case 17: {// store16
            regs->TR[0] += regs->TR[3] ? -1 : 1;
            regs->TR[0] &= 0xFFFF;
            regs->TR[1] = (regs->TR[1] + 1) & 0xFFFF;
            regs->TR[3] ^= 1;
            pins->WR = 0;
            return; }
        case 18: {// idle in loop
            return; }
        case 19: {// idle in loop
            regs->TR[2] = (regs->TR[2] - 1) & 0xFFFF;
            if (regs->TR[2]) regs->TCU -= 6; // TESTME!
            return; }
        case 20: {// idle out loop
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 21: {// pull
            regs->X = pins->D;
            pins->BM = 0;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 22: {// pull
            regs->A = pins->D;
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            return; }
        case 23: {// cleanup_custom
            regs->Y = pins->D;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F4__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.T = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F5__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 5: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F6__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFF;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 6: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F7__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 4: {// load8
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            return; }
        case 6: {// idle
            regs->TR[0] |= 1 << 7;
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->D = regs->TR[0];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F8__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// cleanup_custom
            regs->P.D = 1;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_F9__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->Y) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 6: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FA__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->RD = 0; 
            return; }
        case 3: {// idle
            regs->S = (regs->S + 1) & 0xFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->RD = 1; 
            return; }
        case 4: {// cleanup_custom
            regs->X = pins->D;
            regs->P.Z = (regs->X) == 0;
            regs->P.N = ((regs->X) & 0x80) >> 7;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FB__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FC__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            // Following is auto-generated code for instruction finish
            return; }
        case 2: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FD__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + regs->X) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// cleanup_custom
            pins->D ^= 0xFF;
            i16 out = (i16)regs->A + (i16)(pins->D) + (i16)regs->P.C;
            if (!regs->P.D) {
                regs->P.C = out > 0xFF;
                regs->P.V = ((~(regs->A ^ (pins->D)) & (regs->A ^ out)) >> 7) & 1;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            else { // if decimal
                out = (regs->A & 15) + ((pins->D) & 15) + regs->P.C;
                if (out <= 15) out -= 6;
                out = ((pins->D) & 0xF0) + (regs->A & 0xF0) + (out > 15 ? 0x10 : 0) + (out & 15);
                if (out <= 0xFF) out -= 0x60;
                regs->P.C = out > 0xFF;
                out &= 0xFF;
            regs->P.Z = (out) == 0;
            regs->P.N = ((out) & 0x80) >> 7;
            regs->A = out;
            }
            pins->RD = 0; 
            return; }
        case 6: {// idle
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FE__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 3: {// load16
            regs->TR[0] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            regs->TA |= regs->TR[0] << 8;
            pins->RD = 0; 
            return; }
        case 4: {// idle
            regs->TA = (regs->TA + (regs->X)) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 5: {// load16
            regs->TR[0] = pins->D;
            pins->RD = 0; 
            return; }
        case 6: {// idle
            regs->TR[1] = ((regs->TR[0]) + 1) & 0xFF;
            regs->P.Z = (regs->TR[1]) == 0;
            regs->P.N = ((regs->TR[1]) & 0x80) >> 7;
            pins->Addr = regs->MPR[(regs->TA) >> 13] | ((regs->TA) & 0x1FFF);
            pins->D = regs->TR[1];
            // Following is auto-generated code for instruction finish
            pins->WR = 1;
            return; }
        case 7: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; pins->WR = 0;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_FF__t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            return; }
        case 2: {// load16
            regs->TA = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 3: {// idle
            pins->Addr = regs->MPR[(regs->PC)>>13] | ((regs->PC) & 0x1FFF);
            pins->RD = 1; 
            return; }
        case 4: {// load16
            regs->TR[2] = pins->D;
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 5: {// idle
            pins->Addr = regs->MPR[1] | (regs->TA);
            pins->RD = 1; 
            return; }
        case 6: {// load8
            if ((pins->D & 128) == 0) {
                pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
                regs->PC = (regs->PC + 1) & 0xFFFF;
                pins->RD = 1;
                regs->P.T = 0;
                HUC6280_poll_IRQs(regs, pins);
                regs->TCU = 0;
                return;
            }
            regs->PC = (regs->PC + (u32)(i8)regs->TR[2]) & 0xFFFF;
            pins->RD = 0; 
            return; }
        case 7: {// idle
            // Following is auto-generated code for instruction finish
            return; }
        case 8: {// cleanup
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_RESET_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->RD = 0; 
            return; }
        case 2: {// 3
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 3: {// 4
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 4: {// 5
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// 6
            pins->Addr = regs->S | 0x100;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// 7
            regs->MPR[7] = 0;
            regs->MPL = 0;
            regs->P.I = 1;
            regs->P.D = regs->P.T = 0;
            regs->IRQD.u = 7;
            regs->timer_startstop = 0;
            regs->clock_div = 12;
            pins->Addr = 0x1FFE;
            regs->S = 0;
            pins->RD = 1; 
            return; }
        case 7: {// 8
            regs->PC = pins->D;
            pins->Addr++;
            return; }
        case 8: {// 9
            pins->RD = 0; 
            return; }
        case 9: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            pins->RD = 1; 
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_IRQ2_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            regs->PC = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u & 0xEF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            regs->P.I = 1;
            regs->P.D = 0;
            regs->P.T = 0;
            regs->TA = 0xFFF6;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_IRQ1_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            regs->PC = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u & 0xEF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            regs->P.I = 1;
            regs->P.D = 0;
            regs->P.T = 0;
            regs->TA = 0xFFF8;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}


// 
static void HUC6280_ins_TIQ_t1(struct HUC6280_regs *regs, struct HUC6280_pins *pins)
{
    switch(regs->TCU) {
        case 1: {// start cycle
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 2: {// dummy read...
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            return; }
        case 3: {// dummy read...
            regs->PC = (regs->PC - 1) & 0xFFFF;
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC >> 8;
            regs->S = (regs->S - 1) & 0xFF;
            pins->RD = 0; pins->WR = 1;
            return; }
        case 4: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->PC & 0xFF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 5: {// push
            pins->Addr = regs->MPR[1] | 0x100 | regs->S;
            pins->D = regs->P.u & 0xEF;
            regs->S = (regs->S - 1) & 0xFF;
            return; }
        case 6: {// push
            regs->P.I = 1;
            regs->P.D = 0;
            regs->P.T = 0;
            regs->TA = 0xFFFA;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            pins->RD = 1; pins->WR = 0;
            return; }
        case 7: {// load16
            regs->PC = pins->D;
            regs->TA = (regs->TA + 1) & 0xFFFF;
            pins->Addr = regs->MPR[(regs->TA)>>13] | ((regs->TA) & 0x1FFF);
            return; }
        case 8: {// cleanup_custom
            regs->PC |= pins->D << 8;
            // Following is auto-generated code for instruction finish
            pins->Addr = regs->MPR[regs->PC >> 13] | (regs->PC & 0x1FFF);
            regs->PC = (regs->PC + 1) & 0xFFFF;
            HUC6280_poll_IRQs(regs, pins);
            regs->P.T = 0;
            regs->TCU = 0;
            return;
        }
    }
}




HUC6280_ins_func HUC6280_decoded_opcodes[2][0x104] = {
        &HUC6280_ins_00__t0,  &HUC6280_ins_01__t0,  &HUC6280_ins_02__t0,  &HUC6280_ins_03__t0,  &HUC6280_ins_04__t0,  &HUC6280_ins_05__t0,  &HUC6280_ins_06__t0,  &HUC6280_ins_07__t0,
      &HUC6280_ins_08__t0,  &HUC6280_ins_09__t0,  &HUC6280_ins_0A__t0,  &HUC6280_ins_0B__t0,  &HUC6280_ins_0C__t0,  &HUC6280_ins_0D__t0,  &HUC6280_ins_0E__t0,  &HUC6280_ins_0F__t0,
      &HUC6280_ins_10__t0,  &HUC6280_ins_11__t0,  &HUC6280_ins_12__t0,  &HUC6280_ins_13__t0,  &HUC6280_ins_14__t0,  &HUC6280_ins_15__t0,  &HUC6280_ins_16__t0,  &HUC6280_ins_17__t0,
      &HUC6280_ins_18__t0,  &HUC6280_ins_19__t0,  &HUC6280_ins_1A__t0,  &HUC6280_ins_1B__t0,  &HUC6280_ins_1C__t0,  &HUC6280_ins_1D__t0,  &HUC6280_ins_1E__t0,  &HUC6280_ins_1F__t0,
      &HUC6280_ins_20__t0,  &HUC6280_ins_21__t0,  &HUC6280_ins_22__t0,  &HUC6280_ins_23__t0,  &HUC6280_ins_24__t0,  &HUC6280_ins_25__t0,  &HUC6280_ins_26__t0,  &HUC6280_ins_27__t0,
      &HUC6280_ins_28__t0,  &HUC6280_ins_29__t0,  &HUC6280_ins_2A__t0,  &HUC6280_ins_2B__t0,  &HUC6280_ins_2C__t0,  &HUC6280_ins_2D__t0,  &HUC6280_ins_2E__t0,  &HUC6280_ins_2F__t0,
      &HUC6280_ins_30__t0,  &HUC6280_ins_31__t0,  &HUC6280_ins_32__t0,  &HUC6280_ins_33__t0,  &HUC6280_ins_34__t0,  &HUC6280_ins_35__t0,  &HUC6280_ins_36__t0,  &HUC6280_ins_37__t0,
      &HUC6280_ins_38__t0,  &HUC6280_ins_39__t0,  &HUC6280_ins_3A__t0,  &HUC6280_ins_3B__t0,  &HUC6280_ins_3C__t0,  &HUC6280_ins_3D__t0,  &HUC6280_ins_3E__t0,  &HUC6280_ins_3F__t0,
      &HUC6280_ins_40__t0,  &HUC6280_ins_41__t0,  &HUC6280_ins_42__t0,  &HUC6280_ins_43__t0,  &HUC6280_ins_44__t0,  &HUC6280_ins_45__t0,  &HUC6280_ins_46__t0,  &HUC6280_ins_47__t0,
      &HUC6280_ins_48__t0,  &HUC6280_ins_49__t0,  &HUC6280_ins_4A__t0,  &HUC6280_ins_4B__t0,  &HUC6280_ins_4C__t0,  &HUC6280_ins_4D__t0,  &HUC6280_ins_4E__t0,  &HUC6280_ins_4F__t0,
      &HUC6280_ins_50__t0,  &HUC6280_ins_51__t0,  &HUC6280_ins_52__t0,  &HUC6280_ins_53__t0,  &HUC6280_ins_54__t0,  &HUC6280_ins_55__t0,  &HUC6280_ins_56__t0,  &HUC6280_ins_57__t0,
      &HUC6280_ins_58__t0,  &HUC6280_ins_59__t0,  &HUC6280_ins_5A__t0,  &HUC6280_ins_5B__t0,  &HUC6280_ins_5C__t0,  &HUC6280_ins_5D__t0,  &HUC6280_ins_5E__t0,  &HUC6280_ins_5F__t0,
      &HUC6280_ins_60__t0,  &HUC6280_ins_61__t0,  &HUC6280_ins_62__t0,  &HUC6280_ins_63__t0,  &HUC6280_ins_64__t0,  &HUC6280_ins_65__t0,  &HUC6280_ins_66__t0,  &HUC6280_ins_67__t0,
      &HUC6280_ins_68__t0,  &HUC6280_ins_69__t0,  &HUC6280_ins_6A__t0,  &HUC6280_ins_6B__t0,  &HUC6280_ins_6C__t0,  &HUC6280_ins_6D__t0,  &HUC6280_ins_6E__t0,  &HUC6280_ins_6F__t0,
      &HUC6280_ins_70__t0,  &HUC6280_ins_71__t0,  &HUC6280_ins_72__t0,  &HUC6280_ins_73__t0,  &HUC6280_ins_74__t0,  &HUC6280_ins_75__t0,  &HUC6280_ins_76__t0,  &HUC6280_ins_77__t0,
      &HUC6280_ins_78__t0,  &HUC6280_ins_79__t0,  &HUC6280_ins_7A__t0,  &HUC6280_ins_7B__t0,  &HUC6280_ins_7C__t0,  &HUC6280_ins_7D__t0,  &HUC6280_ins_7E__t0,  &HUC6280_ins_7F__t0,
      &HUC6280_ins_80__t0,  &HUC6280_ins_81__t0,  &HUC6280_ins_82__t0,  &HUC6280_ins_83__t0,  &HUC6280_ins_84__t0,  &HUC6280_ins_85__t0,  &HUC6280_ins_86__t0,  &HUC6280_ins_87__t0,
      &HUC6280_ins_88__t0,  &HUC6280_ins_89__t0,  &HUC6280_ins_8A__t0,  &HUC6280_ins_8B__t0,  &HUC6280_ins_8C__t0,  &HUC6280_ins_8D__t0,  &HUC6280_ins_8E__t0,  &HUC6280_ins_8F__t0,
      &HUC6280_ins_90__t0,  &HUC6280_ins_91__t0,  &HUC6280_ins_92__t0,  &HUC6280_ins_93__t0,  &HUC6280_ins_94__t0,  &HUC6280_ins_95__t0,  &HUC6280_ins_96__t0,  &HUC6280_ins_97__t0,
      &HUC6280_ins_98__t0,  &HUC6280_ins_99__t0,  &HUC6280_ins_9A__t0,  &HUC6280_ins_9B__t0,  &HUC6280_ins_9C__t0,  &HUC6280_ins_9D__t0,  &HUC6280_ins_9E__t0,  &HUC6280_ins_9F__t0,
      &HUC6280_ins_A0__t0,  &HUC6280_ins_A1__t0,  &HUC6280_ins_A2__t0,  &HUC6280_ins_A3__t0,  &HUC6280_ins_A4__t0,  &HUC6280_ins_A5__t0,  &HUC6280_ins_A6__t0,  &HUC6280_ins_A7__t0,
      &HUC6280_ins_A8__t0,  &HUC6280_ins_A9__t0,  &HUC6280_ins_AA__t0,  &HUC6280_ins_AB__t0,  &HUC6280_ins_AC__t0,  &HUC6280_ins_AD__t0,  &HUC6280_ins_AE__t0,  &HUC6280_ins_AF__t0,
      &HUC6280_ins_B0__t0,  &HUC6280_ins_B1__t0,  &HUC6280_ins_B2__t0,  &HUC6280_ins_B3__t0,  &HUC6280_ins_B4__t0,  &HUC6280_ins_B5__t0,  &HUC6280_ins_B6__t0,  &HUC6280_ins_B7__t0,
      &HUC6280_ins_B8__t0,  &HUC6280_ins_B9__t0,  &HUC6280_ins_BA__t0,  &HUC6280_ins_BB__t0,  &HUC6280_ins_BC__t0,  &HUC6280_ins_BD__t0,  &HUC6280_ins_BE__t0,  &HUC6280_ins_BF__t0,
      &HUC6280_ins_C0__t0,  &HUC6280_ins_C1__t0,  &HUC6280_ins_C2__t0,  &HUC6280_ins_C3__t0,  &HUC6280_ins_C4__t0,  &HUC6280_ins_C5__t0,  &HUC6280_ins_C6__t0,  &HUC6280_ins_C7__t0,
      &HUC6280_ins_C8__t0,  &HUC6280_ins_C9__t0,  &HUC6280_ins_CA__t0,  &HUC6280_ins_CB__t0,  &HUC6280_ins_CC__t0,  &HUC6280_ins_CD__t0,  &HUC6280_ins_CE__t0,  &HUC6280_ins_CF__t0,
      &HUC6280_ins_D0__t0,  &HUC6280_ins_D1__t0,  &HUC6280_ins_D2__t0,  &HUC6280_ins_D3__t0,  &HUC6280_ins_D4__t0,  &HUC6280_ins_D5__t0,  &HUC6280_ins_D6__t0,  &HUC6280_ins_D7__t0,
      &HUC6280_ins_D8__t0,  &HUC6280_ins_D9__t0,  &HUC6280_ins_DA__t0,  &HUC6280_ins_DB__t0,  &HUC6280_ins_DC__t0,  &HUC6280_ins_DD__t0,  &HUC6280_ins_DE__t0,  &HUC6280_ins_DF__t0,
      &HUC6280_ins_E0__t0,  &HUC6280_ins_E1__t0,  &HUC6280_ins_E2__t0,  &HUC6280_ins_E3__t0,  &HUC6280_ins_E4__t0,  &HUC6280_ins_E5__t0,  &HUC6280_ins_E6__t0,  &HUC6280_ins_E7__t0,
      &HUC6280_ins_E8__t0,  &HUC6280_ins_E9__t0,  &HUC6280_ins_EA__t0,  &HUC6280_ins_EB__t0,  &HUC6280_ins_EC__t0,  &HUC6280_ins_ED__t0,  &HUC6280_ins_EE__t0,  &HUC6280_ins_EF__t0,
      &HUC6280_ins_F0__t0,  &HUC6280_ins_F1__t0,  &HUC6280_ins_F2__t0,  &HUC6280_ins_F3__t0,  &HUC6280_ins_F4__t0,  &HUC6280_ins_F5__t0,  &HUC6280_ins_F6__t0,  &HUC6280_ins_F7__t0,
      &HUC6280_ins_F8__t0,  &HUC6280_ins_F9__t0,  &HUC6280_ins_FA__t0,  &HUC6280_ins_FB__t0,  &HUC6280_ins_FC__t0,  &HUC6280_ins_FD__t0,  &HUC6280_ins_FE__t0,  &HUC6280_ins_FF__t0,
      &HUC6280_ins_RESET_t0,  &HUC6280_ins_IRQ2_t0,  &HUC6280_ins_IRQ1_t0,  &HUC6280_ins_TIQ_t0,  &HUC6280_ins_00__t1,  &HUC6280_ins_01__t1,  &HUC6280_ins_02__t1,  &HUC6280_ins_03__t1,
      &HUC6280_ins_04__t1,  &HUC6280_ins_05__t1,  &HUC6280_ins_06__t1,  &HUC6280_ins_07__t1,  &HUC6280_ins_08__t1,  &HUC6280_ins_09__t1,  &HUC6280_ins_0A__t1,  &HUC6280_ins_0B__t1,
      &HUC6280_ins_0C__t1,  &HUC6280_ins_0D__t1,  &HUC6280_ins_0E__t1,  &HUC6280_ins_0F__t1,  &HUC6280_ins_10__t1,  &HUC6280_ins_11__t1,  &HUC6280_ins_12__t1,  &HUC6280_ins_13__t1,
      &HUC6280_ins_14__t1,  &HUC6280_ins_15__t1,  &HUC6280_ins_16__t1,  &HUC6280_ins_17__t1,  &HUC6280_ins_18__t1,  &HUC6280_ins_19__t1,  &HUC6280_ins_1A__t1,  &HUC6280_ins_1B__t1,
      &HUC6280_ins_1C__t1,  &HUC6280_ins_1D__t1,  &HUC6280_ins_1E__t1,  &HUC6280_ins_1F__t1,  &HUC6280_ins_20__t1,  &HUC6280_ins_21__t1,  &HUC6280_ins_22__t1,  &HUC6280_ins_23__t1,
      &HUC6280_ins_24__t1,  &HUC6280_ins_25__t1,  &HUC6280_ins_26__t1,  &HUC6280_ins_27__t1,  &HUC6280_ins_28__t1,  &HUC6280_ins_29__t1,  &HUC6280_ins_2A__t1,  &HUC6280_ins_2B__t1,
      &HUC6280_ins_2C__t1,  &HUC6280_ins_2D__t1,  &HUC6280_ins_2E__t1,  &HUC6280_ins_2F__t1,  &HUC6280_ins_30__t1,  &HUC6280_ins_31__t1,  &HUC6280_ins_32__t1,  &HUC6280_ins_33__t1,
      &HUC6280_ins_34__t1,  &HUC6280_ins_35__t1,  &HUC6280_ins_36__t1,  &HUC6280_ins_37__t1,  &HUC6280_ins_38__t1,  &HUC6280_ins_39__t1,  &HUC6280_ins_3A__t1,  &HUC6280_ins_3B__t1,
      &HUC6280_ins_3C__t1,  &HUC6280_ins_3D__t1,  &HUC6280_ins_3E__t1,  &HUC6280_ins_3F__t1,  &HUC6280_ins_40__t1,  &HUC6280_ins_41__t1,  &HUC6280_ins_42__t1,  &HUC6280_ins_43__t1,
      &HUC6280_ins_44__t1,  &HUC6280_ins_45__t1,  &HUC6280_ins_46__t1,  &HUC6280_ins_47__t1,  &HUC6280_ins_48__t1,  &HUC6280_ins_49__t1,  &HUC6280_ins_4A__t1,  &HUC6280_ins_4B__t1,
      &HUC6280_ins_4C__t1,  &HUC6280_ins_4D__t1,  &HUC6280_ins_4E__t1,  &HUC6280_ins_4F__t1,  &HUC6280_ins_50__t1,  &HUC6280_ins_51__t1,  &HUC6280_ins_52__t1,  &HUC6280_ins_53__t1,
      &HUC6280_ins_54__t1,  &HUC6280_ins_55__t1,  &HUC6280_ins_56__t1,  &HUC6280_ins_57__t1,  &HUC6280_ins_58__t1,  &HUC6280_ins_59__t1,  &HUC6280_ins_5A__t1,  &HUC6280_ins_5B__t1,
      &HUC6280_ins_5C__t1,  &HUC6280_ins_5D__t1,  &HUC6280_ins_5E__t1,  &HUC6280_ins_5F__t1,  &HUC6280_ins_60__t1,  &HUC6280_ins_61__t1,  &HUC6280_ins_62__t1,  &HUC6280_ins_63__t1,
      &HUC6280_ins_64__t1,  &HUC6280_ins_65__t1,  &HUC6280_ins_66__t1,  &HUC6280_ins_67__t1,  &HUC6280_ins_68__t1,  &HUC6280_ins_69__t1,  &HUC6280_ins_6A__t1,  &HUC6280_ins_6B__t1,
      &HUC6280_ins_6C__t1,  &HUC6280_ins_6D__t1,  &HUC6280_ins_6E__t1,  &HUC6280_ins_6F__t1,  &HUC6280_ins_70__t1,  &HUC6280_ins_71__t1,  &HUC6280_ins_72__t1,  &HUC6280_ins_73__t1,
      &HUC6280_ins_74__t1,  &HUC6280_ins_75__t1,  &HUC6280_ins_76__t1,  &HUC6280_ins_77__t1,  &HUC6280_ins_78__t1,  &HUC6280_ins_79__t1,  &HUC6280_ins_7A__t1,  &HUC6280_ins_7B__t1,
      &HUC6280_ins_7C__t1,  &HUC6280_ins_7D__t1,  &HUC6280_ins_7E__t1,  &HUC6280_ins_7F__t1,  &HUC6280_ins_80__t1,  &HUC6280_ins_81__t1,  &HUC6280_ins_82__t1,  &HUC6280_ins_83__t1,
      &HUC6280_ins_84__t1,  &HUC6280_ins_85__t1,  &HUC6280_ins_86__t1,  &HUC6280_ins_87__t1,  &HUC6280_ins_88__t1,  &HUC6280_ins_89__t1,  &HUC6280_ins_8A__t1,  &HUC6280_ins_8B__t1,
      &HUC6280_ins_8C__t1,  &HUC6280_ins_8D__t1,  &HUC6280_ins_8E__t1,  &HUC6280_ins_8F__t1,  &HUC6280_ins_90__t1,  &HUC6280_ins_91__t1,  &HUC6280_ins_92__t1,  &HUC6280_ins_93__t1,
      &HUC6280_ins_94__t1,  &HUC6280_ins_95__t1,  &HUC6280_ins_96__t1,  &HUC6280_ins_97__t1,  &HUC6280_ins_98__t1,  &HUC6280_ins_99__t1,  &HUC6280_ins_9A__t1,  &HUC6280_ins_9B__t1,
      &HUC6280_ins_9C__t1,  &HUC6280_ins_9D__t1,  &HUC6280_ins_9E__t1,  &HUC6280_ins_9F__t1,  &HUC6280_ins_A0__t1,  &HUC6280_ins_A1__t1,  &HUC6280_ins_A2__t1,  &HUC6280_ins_A3__t1,
      &HUC6280_ins_A4__t1,  &HUC6280_ins_A5__t1,  &HUC6280_ins_A6__t1,  &HUC6280_ins_A7__t1,  &HUC6280_ins_A8__t1,  &HUC6280_ins_A9__t1,  &HUC6280_ins_AA__t1,  &HUC6280_ins_AB__t1,
      &HUC6280_ins_AC__t1,  &HUC6280_ins_AD__t1,  &HUC6280_ins_AE__t1,  &HUC6280_ins_AF__t1,  &HUC6280_ins_B0__t1,  &HUC6280_ins_B1__t1,  &HUC6280_ins_B2__t1,  &HUC6280_ins_B3__t1,
      &HUC6280_ins_B4__t1,  &HUC6280_ins_B5__t1,  &HUC6280_ins_B6__t1,  &HUC6280_ins_B7__t1,  &HUC6280_ins_B8__t1,  &HUC6280_ins_B9__t1,  &HUC6280_ins_BA__t1,  &HUC6280_ins_BB__t1,
      &HUC6280_ins_BC__t1,  &HUC6280_ins_BD__t1,  &HUC6280_ins_BE__t1,  &HUC6280_ins_BF__t1,  &HUC6280_ins_C0__t1,  &HUC6280_ins_C1__t1,  &HUC6280_ins_C2__t1,  &HUC6280_ins_C3__t1,
      &HUC6280_ins_C4__t1,  &HUC6280_ins_C5__t1,  &HUC6280_ins_C6__t1,  &HUC6280_ins_C7__t1,  &HUC6280_ins_C8__t1,  &HUC6280_ins_C9__t1,  &HUC6280_ins_CA__t1,  &HUC6280_ins_CB__t1,
      &HUC6280_ins_CC__t1,  &HUC6280_ins_CD__t1,  &HUC6280_ins_CE__t1,  &HUC6280_ins_CF__t1,  &HUC6280_ins_D0__t1,  &HUC6280_ins_D1__t1,  &HUC6280_ins_D2__t1,  &HUC6280_ins_D3__t1,
      &HUC6280_ins_D4__t1,  &HUC6280_ins_D5__t1,  &HUC6280_ins_D6__t1,  &HUC6280_ins_D7__t1,  &HUC6280_ins_D8__t1,  &HUC6280_ins_D9__t1,  &HUC6280_ins_DA__t1,  &HUC6280_ins_DB__t1,
      &HUC6280_ins_DC__t1,  &HUC6280_ins_DD__t1,  &HUC6280_ins_DE__t1,  &HUC6280_ins_DF__t1,  &HUC6280_ins_E0__t1,  &HUC6280_ins_E1__t1,  &HUC6280_ins_E2__t1,  &HUC6280_ins_E3__t1,
      &HUC6280_ins_E4__t1,  &HUC6280_ins_E5__t1,  &HUC6280_ins_E6__t1,  &HUC6280_ins_E7__t1,  &HUC6280_ins_E8__t1,  &HUC6280_ins_E9__t1,  &HUC6280_ins_EA__t1,  &HUC6280_ins_EB__t1,
      &HUC6280_ins_EC__t1,  &HUC6280_ins_ED__t1,  &HUC6280_ins_EE__t1,  &HUC6280_ins_EF__t1,  &HUC6280_ins_F0__t1,  &HUC6280_ins_F1__t1,  &HUC6280_ins_F2__t1,  &HUC6280_ins_F3__t1,
      &HUC6280_ins_F4__t1,  &HUC6280_ins_F5__t1,  &HUC6280_ins_F6__t1,  &HUC6280_ins_F7__t1,  &HUC6280_ins_F8__t1,  &HUC6280_ins_F9__t1,  &HUC6280_ins_FA__t1,  &HUC6280_ins_FB__t1,
      &HUC6280_ins_FC__t1,  &HUC6280_ins_FD__t1,  &HUC6280_ins_FE__t1,  &HUC6280_ins_FF__t1,  &HUC6280_ins_RESET_t1,  &HUC6280_ins_IRQ2_t1,  &HUC6280_ins_IRQ1_t1,  &HUC6280_ins_TIQ_t1
  
};
